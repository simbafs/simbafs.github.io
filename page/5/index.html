<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Simba's Blog</title><meta name=keywords content="simba-fs,SimbaFs"><meta name=description content="雜七雜八的東西"><meta name=author content="simba-fs"><link rel=canonical href=https://blog.simba-fs.dev/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=/images/icon/icon.png as=image><link rel=icon href=https://blog.simba-fs.dev/images/icon/icon.png><link rel=icon type=image/png sizes=16x16 href=https://blog.simba-fs.dev/images/icon/icon-16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.simba-fs.dev/images/icon/icon-32.png><link rel=apple-touch-icon href=https://blog.simba-fs.dev/images/icon/icon.png><link rel=mask-icon href=https://blog.simba-fs.dev/images/icon/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.96.0"><link rel=alternate type=application/rss+xml href=https://blog.simba-fs.dev/index.xml><link rel=alternate type=application/json href=https://blog.simba-fs.dev/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-175823992-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Simba's Blog"><meta property="og:description" content="雜七雜八的東西"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.simba-fs.dev/"><meta property="og:image" content="https://blog.simba-fs.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Simba 的喵窩"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.simba-fs.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Simba's Blog"><meta name=twitter:description content="雜七雜八的東西"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Simba's Blog","url":"https://blog.simba-fs.dev/","description":"雜七雜八的東西","thumbnailUrl":"https://blog.simba-fs.dev/images/icon/icon.png","sameAs":["https://github.com/simba-fs","https://t.me/simbafs","https://twitter.com/simbafs"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.simba-fs.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.simba-fs.dev/images/icon/icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.simba-fs.dev/posts/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.simba-fs.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.simba-fs.dev/archive/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.simba-fs.dev/resource/ title=Resource><span>Resource</span></a></li><li><a href=https://blog.simba-fs.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>node-vm</h2></header><section class=entry-content><p>node.js VM 模組 VM 是 node.js 的核心模組，提供安全的環境 (沙箱) 來測試不信任的程式碼。
基本概念 在 VM 模組裡面，有兩個基本的物件，script 和 context。script 是經過「編譯」程式，context 是給在沙箱裡面的程式碼的全域物件 (global) 。沙箱中的程式只能存取透過 context 指定的物件。
建立 script VM 模組提供 Script 建構子，可以透過他來建立 Script 物件。
const vm = require('vm'); const script = new vm.Script('i++'); 也可以用 vm.createScript
const vm = require('vm'); const script = vm.createScript('i++'); vm.Script
vm.createScript 在 nodejs docs 上我沒有找到，但是我在自己的電腦上 (node v14.15.0) 測試是可以用的
建立 context vm 模組沒有提供建立 context 的建構子，我們只能透過 vm.createContext 來建立 context。...</p></section><footer class=entry-footer><span title="2021-01-13 00:00:00 +0000 UTC">2021-January-13</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to node-vm" href=https://blog.simba-fs.dev/posts/nodejs/node-vm/></a></article><article class=post-entry><header class=entry-header><h2>hCaptcha</h2></header><section class=entry-content><p>前情提要 我們社團的短網址服務裡面常常出現一些奇怪的網址，我猜可能是有機器人在刷，所以我想加入 captcha 減少這類問題。我選擇的是 hCaptcha 這套，能不依賴 Google 就盡量不要。
安裝步驟 申請帳號 先到 hCaptcha 註冊、新增一個網站，複製 sitekey (Sites > site setting) 和 secret key (Settings)，我們等等會用到
前端 首先引入 script ，在 &lt;head> 加入 &lt;script src="https://hcaptcha.com/1/api.js" async defer>&lt;/script> 接著在你的 &lt;form> 裡面加入，這邊的 your_site_key 就是剛剛複製的那個。記得 &lt;form> 的 method 要設成 post &lt;div class="h-captcha" data-sitekey="your_site_key">&lt;/div> 後端（node express） SECRET
首先，你要把剛剛的 SECRET 給 server 知道，我用的是 dotenv，當然其他的套件也是可以。
簡而言之，剛剛複製下來的 SECRET 就是用在這裡。
驗證 後端我選用的套件是 express-hcaptcha ，它提供一個 middleware 驗證 hcaptcha 的 token。 按照 README....</p></section><footer class=entry-footer><span title="2021-01-05 00:00:00 +0000 UTC">2021-January-5</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to hCaptcha" href=https://blog.simba-fs.dev/posts/nodejs/hcaptcha/></a></article><article class=post-entry><header class=entry-header><h2>docker login error</h2></header><section class=entry-content><p>錯誤說明 昨天我在 terminal 登入 docker 的時候發現不知道為什麼不能登入，我先透過網頁登入確認過密碼沒有問題，也不是打錯字的關係，但還是不能當入。總是會有類似以下的錯誤訊息。
Error saving credentials: error storing credentials - err: exit status 1, out: `exit status 1: gpg: simbafs: 已跳過: 沒有公鑰 gpg: [stdin]: encryption failed: 沒有公鑰 Password encryption aborted.` 解決方法 經過搜尋之後，我按照 https://github.com/docker/docker-credential-helpers/issues/102#issuecomment-388634452 的方法成功登入了，但是在這之前要先安裝 gpg 和 pass
apt install gnupg2 pass 接下來是我用的指令
apt install gnupg2 wget https://github.com/docker/docker-credential-helpers/releases/download/v0.6.3/docker-credential-pass-v0.6.3-amd64.tar.gz tar xvf docker-credential-pass-v0.6.3-amd64.tar.gz chmod 755 docker-credential-pass sudo mv docker-credential-pass /usr/bin/ ass insert docker-credential-helpers/docker-pass-initialized-check pass insert docker-credential-helpers/docker-pass-initialized-check pass show docker-credential-helpers/docker-pass-initialized-check docker-credential-pass list docker login 參考連結 https://github....</p></section><footer class=entry-footer><span title="2020-12-05 00:00:00 +0000 UTC">2020-December-5</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to docker login error" href=https://blog.simba-fs.dev/posts/linux/docker/docker-login-error/></a></article><article class=post-entry><header class=entry-header><h2>connect to ethernet in docker container</h2></header><section class=entry-content><p>如何在 docker container 裡連接 ethernet 今天突然有個需求是在一個已經開啟的 container 弄東西，需要網路，但是不知道為什麼一直不上，後來發現是 docker 沒有設定 DNS 的問題，只要在外面輸入兩行指令就可以了
DOCKER_OPTS="--dns 8.8.8.8" systemctl restart docker 然後重新啟動 docker</p></section><footer class=entry-footer><span title="2020-11-28 00:00:00 +0000 UTC">2020-November-28</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to connect to ethernet in docker container" href=https://blog.simba-fs.dev/posts/linux/docker/connect-to-ethernet-in-docker-container/></a></article><article class=post-entry><header class=entry-header><h2>docker commit</h2></header><section class=entry-content><p>前言 上次提到可以用 Dockerfile 建立 docker image，但我們還有令一個方法可以建立 docker image，那就是 docker commit 指令
和 Dockerfile 差別 docker commit 有點像是手動版的 Dockerfile，在用 Dockerfile 建構 docker image 的時候，docker build 的工作就像是自動根據 Dockerfile 操作 docker commit。 Dockerfile 比較適合用在自動化交付和部屬，例如說你有一份程式碼，要將他包成 Docker 就很適合用 Dockerfile 自動化操作，因為程式碼會改變，但是包裝的流程基本上都是一樣的。 docker commit 適合用在建構環境，因為會有比較麻煩的操作，如果寫成 Dockerfile 會比較麻煩，當然如果可以的話還是寫成 Dockerfile 會比較好，因為更新的時候會比較方便。 在建構 image 的時候要用哪個方法就看個人取捨了。
docker commit 指令 docker commit 可以把運行中的 comtainer 轉成 images，有點類似令存新檔的概念。先來看看參數吧！
參數 $ docker commit --help Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] Create a new image from a container's changes Options: -a, --author string Author (e....</p></section><footer class=entry-footer><span title="2020-11-27 00:00:00 +0000 UTC">2020-November-27</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to docker commit" href=https://blog.simba-fs.dev/posts/linux/docker/docker-commit/></a></article><article class=post-entry><header class=entry-header><h2>bash number loop</h2></header><section class=entry-content><p>今天在某的地方剛好看到一個 bash 的小技巧，當我們要從 1 數到 100 時，通常會用 seq 指令來做，但是如果我們的需求剛剛好是每次遞增（遞減）1 的話，就可以使用 {start..end} 縮寫，下面兩個範例的效果是一樣的：
# for 迴圈 + seq 的寫法 for i in $(seq 1 1 100); do echo $i done # 用 {start..end} echo {1..100} 這個技巧也可以用在建立檔案，像這樣：
touch user{1..100}</p></section><footer class=entry-footer><span title="2020-11-15 00:00:00 +0000 UTC">2020-November-15</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to bash number loop" href=https://blog.simba-fs.dev/posts/linux/bash/bash-number-loop/></a></article><article class=post-entry><header class=entry-header><h2>bash completion</h2></header><section class=entry-content><p>需求 今天寫了一個 bash script 幫我管理 mongodb docker，在使用的時候一些子命令，像是 up、down、clean。我希望可以讓 bash 當我自動補齊這些選項。
bash_completion bash_completion 是一個可以幫我們做程式化補齊的工具，像是 git 就有使用到這個工具，在 commit、push 的時候按 tab 都會顯示出當下我們可以用的東西，像是 git push&lt;tab>&lt;tab> 就會自動補齊 origin 而不是給我們看檔案（bash 預設只會補齊檔案和命令）。我們這次只須要用基本的 complete 就可以了
complete complete 可以幫命令加上簡單的自動完成，其實 bash_completion 也是去呼叫這個命令來達成自動補齊。complete 傻用非常簡單，像下面這樣就可以幫 mongodb 這個命令加上自動補齊
complete -W "up down clean" mongodb -W 選項代表後面是字詞列表，用 -F 後面可以接一個函數，但是這個我沒研究，也許下一個專案就是研究 complete 也說不定。</p></section><footer class=entry-footer><span title="2020-11-14 00:00:00 +0000 UTC">2020-November-14</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to bash completion" href=https://blog.simba-fs.dev/posts/linux/bash/bash-completion/></a></article><article class=post-entry><header class=entry-header><h2>Mongoose Model</h2></header><section class=entry-content><p>Mongoose Model 環境設定 這是這次實驗用的 code
const mongoose = require('mongoose'); mongoose.connect('mongodb://127.0.0.1:27017', {useNewUrlParser: true, useUnifiedTopology: true}) .then(() => console.log('Connected to DB')) .catch(e => console.error(e)); const requiredString = { type: String, required: true } const UserSchema = new mongoose.Schema({ username: requiredString, password: requiredString }); const UserModel = mongoose.model('User', UserSchema); mongo db 用 docker 開一個實驗用的 server
version: '3' services: db: image: 'mongo' container_name: 'aurl-mongodb' volumes: - ....</p></section><footer class=entry-footer><span title="2020-11-10 00:00:00 +0000 UTC">2020-November-10</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to Mongoose Model" href=https://blog.simba-fs.dev/posts/nodejs/mongoose-model/></a></article><article class=post-entry><header class=entry-header><h2>docker 基礎指令</h2></header><section class=entry-content><p>Install apt install docker docker.io docker-compose What is docker Docker 是一個容器化的技術，基本上使用的時候可以把他當成虛擬機，雖然他們的使用的技術完全不一樣。對新手來說，在 Docker 裡面有四個重要的名詞：dockerfile, docker image, docker container, docker-compose。
dockerfile
純文字檔，定義建立 docker image 的步驟，有點像是一個 bash shell。通常命名成 Dockerfile ，在 build 的時候會預設用這個，也可以用 -f 來指定其他的檔案。 docker image
這是透過 docker build 編譯出來的東西。可以想成 docker container 的藍圖，在 docker pull 的時候也是下載 docker image 而不是 dockerfile。基本上 image 裡面已經包括了編譯好的執行檔和基本的環境設定，所以在 docker 外面是不用做他設定的，這也是 docker 的魅力所在。 docker container
每個 docker image 可以產生很多個 container，也就是執行中的程式。在這裡你已經可以用 docker 來建立各種服務了。這裡也可以想像成虛擬機，用 docker exec -it container_name bash 可以進到 container 裡面(如果裡面有 bash 的話) docker-compose...</p></section><footer class=entry-footer><span title="2020-09-10 00:00:00 +0000 UTC">2020-September-10</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to docker 基礎指令" href=https://blog.simba-fs.dev/posts/linux/docker/docker-%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/></a></article><article class=post-entry><header class=entry-header><h2>mxlinux boot with systemd</h2></header><section class=entry-content><p>問題 在 mxlinux 裡面，預設的 init 不是 systmed，這導致如果想用 systemctl 的時候就會跳出錯誤說
System has not been booted with systemd as init system 像是在安裝 mongodb-org 的時候他就要用到 systemctl 然後就會出錯。
解法 其實 mxlinux 已經幫我們想好解法了，在開機選項時選 Advence > Systemd 就會以 systemd 開機</p></section><footer class=entry-footer><span title="2020-09-05 00:00:00 +0000 UTC">2020-September-5</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;simba-fs</footer><a class=entry-link aria-label="post link to mxlinux boot with systemd" href=https://blog.simba-fs.dev/posts/linux/mxlinux-boot-with-systemd/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.simba-fs.dev/page/4/>« 上一篇</a>
<a class=next href=https://blog.simba-fs.dev/page/6/>下一篇 »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://blog.simba-fs.dev/>Simba's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>