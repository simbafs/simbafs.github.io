[{"content":"目的  驗證不同設計的生產效率差異 用科學的方式檢驗下面這些毫無根據、隨意編造的偏見   實驗方法 相同的物品源、相同的生產建築數量、相同的輸出軌數和時間，以不同的輸入方法配置，計算每秒生產量。\n 相同物品源：就一樣數量的物品源，本次實驗用兩組實驗，所以是四個沙、兩個煤 相同生產建築：八個煉矽廠 相同輸出軌數：各兩條 相同輸出時間：連接到同一個能量源，計時一段時間後拆除能量源，計算雙方生產數量   因為輸送帶用的是最低階，可能會補給不足或是消化不夠快，但是因為兩個都是相同的限制（輸出軌數），要卡一定是兩個一起卡，頂多被卡成平手。這個時候如果還輸，那就不知道是誰的問題了喔！\n 原始數據和計算結果 結果與討論 在時間拉長後，因為被卡住的東西被平均掉，因此兩個都生產效率都下降，這個很正常\n根據結果，即便都被限制，生產效率都還是 B 配置比較高，無論時間拉多長。\n根據我個人的猜測，B 因為輸入和輸出沒有混雜在一起，因此不會造成堵塞（仔細觀察 A，最後在反向分類器那邊常常會堵住，這就是輸入輸出混雜的後果），導致即使輸入比例不對，效率依舊比較高。\nA 的穩定性高了那麼一點點，不重要\n結果比較 根據可擴張性而言，B 的設計是可以橫向無限擴張，不像 A，縱向擴張受到輸送帶效率影響、橫向擴張受到輸入比須滿管影響（不滿管比例就不對，這個設計也就跟垃圾一樣毫無意義，因此必須滿管）。另外，一套 B 可以有比 A 更彈性的輸入和輸出輸送帶數量，因此可以適應更多的狀況。\nB 唯一的缺點是佔體積大了一點點，但我個人認為，沒有任何事物是完美的，因此用一點點小缺點換取最多的優點，這個是比追求無謂的小體積來的更重要。\n更重要的是，B 的設計更為簡單，建造成本低、可以無限擴張\n後續實驗 根據 Magicaltank 和 a0000778 的建議，換成溢流器的確會增加效率，但即使沒換，但還是比 A 設計效率高。\n結論 哥白尼#3565 可憐問錯人\na0000778#4614 不錯的建議，受教了\n(Magicaltank)魔缸#2487 不錯的建議，受教了\n(Silicon God)D號香蕉#5904 追求精簡設計，很有想法\nacopika#3895 看不清現實，連個簡單的實驗都沒做，喜新厭舊\npopolol456#7199 不求甚解，看起來會動、比例對就不研究了，還算 ok\n(我叫美鳳 姑且就叫我美麗吧)酥炸牡蠣#4962 燥鬱症+不會看空氣，給它台階還不會下，硬要吵\n","permalink":"https://blog.simba-fs.dev/posts/game/mindustry/two-input-compare/","summary":"目的  驗證不同設計的生產效率差異 用科學的方式檢驗下面這些毫無根據、隨意編造的偏見   實驗方法 相同的物品源、相同的生產建築數量、相同的輸出軌數和時間，以不同的輸入方法配置，計算每秒生產量。\n 相同物品源：就一樣數量的物品源，本次實驗用兩組實驗，所以是四個沙、兩個煤 相同生產建築：八個煉矽廠 相同輸出軌數：各兩條 相同輸出時間：連接到同一個能量源，計時一段時間後拆除能量源，計算雙方生產數量   因為輸送帶用的是最低階，可能會補給不足或是消化不夠快，但是因為兩個都是相同的限制（輸出軌數），要卡一定是兩個一起卡，頂多被卡成平手。這個時候如果還輸，那就不知道是誰的問題了喔！\n 原始數據和計算結果 結果與討論 在時間拉長後，因為被卡住的東西被平均掉，因此兩個都生產效率都下降，這個很正常\n根據結果，即便都被限制，生產效率都還是 B 配置比較高，無論時間拉多長。\n根據我個人的猜測，B 因為輸入和輸出沒有混雜在一起，因此不會造成堵塞（仔細觀察 A，最後在反向分類器那邊常常會堵住，這就是輸入輸出混雜的後果），導致即使輸入比例不對，效率依舊比較高。\nA 的穩定性高了那麼一點點，不重要\n結果比較 根據可擴張性而言，B 的設計是可以橫向無限擴張，不像 A，縱向擴張受到輸送帶效率影響、橫向擴張受到輸入比須滿管影響（不滿管比例就不對，這個設計也就跟垃圾一樣毫無意義，因此必須滿管）。另外，一套 B 可以有比 A 更彈性的輸入和輸出輸送帶數量，因此可以適應更多的狀況。\nB 唯一的缺點是佔體積大了一點點，但我個人認為，沒有任何事物是完美的，因此用一點點小缺點換取最多的優點，這個是比追求無謂的小體積來的更重要。\n更重要的是，B 的設計更為簡單，建造成本低、可以無限擴張\n後續實驗 根據 Magicaltank 和 a0000778 的建議，換成溢流器的確會增加效率，但即使沒換，但還是比 A 設計效率高。\n結論 哥白尼#3565 可憐問錯人\na0000778#4614 不錯的建議，受教了\n(Magicaltank)魔缸#2487 不錯的建議，受教了\n(Silicon God)D號香蕉#5904 追求精簡設計，很有想法\nacopika#3895 看不清現實，連個簡單的實驗都沒做，喜新厭舊\npopolol456#7199 不求甚解，看起來會動、比例對就不研究了，還算 ok\n(我叫美鳳 姑且就叫我美麗吧)酥炸牡蠣#4962 燥鬱症+不會看空氣，給它台階還不會下，硬要吵","title":"兩輸入生產單位的比較"},{"content":"用處理器可以控制砲台們打的方向和什麼時候打，這樣只要有一群受控的砲台，就可以在射程範圍內指哪打哪\n單一砲台 如圖所示，砲台跟著玩家瞄準的方向打\n以下是程式碼\nradar player any any distance duo1 1 player sensor x player @shootX sensor y player @shootY sensor shoot player @shooting control shoot duo1 x y shoot 0    command description     radar 取得玩家物件   sensor 抽出玩家物件的 shootX、shootY（瞄準的點）和 shooting（是否正在開火）   control 控制 duo1 砲台       variable description     player 玩家物件   x 瞄準的 X 座標   y 瞄準的 Y 座標   shooting 是否開火    多個砲台 上面的指令只能控制一個砲台，那麼要怎麼控制多個砲台呢？答案是 loop，但是 Mindustry 沒有提供 loop，我們只能用 jump，那麼就來看看程式吧！\nset n 0 getlink result n radar player any any distance result 1 player sensor x player @shootX sensor y player @shootY sensor shoot player @shooting control shoot result x y shoot 0 op add n n 1 op mod n n @links jump 1 always x false  以下重複的就不會再多講了\n    command description     set 初始化一個變數 n 值為 0   getlink 取得連結的第 n 個建築，存到 result   op 執行數學運算，舉例 add n N 1 =\u0026gt; n = N + 1   jump 根據規則跳躍到某條指令，這裡的 1 是指跳到第一調指令（從 0 開始數，也就是跳到 radar），因為我們調建設成 always，因此後面兩個就不必要，你在編輯畫面應該也看不到       variable description     n 迭代的變數   @links 總共有幾個連結的建築    參考資料 https://www.youtube.com/watch?v=UFK5m6qKT6U\nhttps://www.youtube.com/watch?v=YMxU0jcS11I\n","permalink":"https://blog.simba-fs.dev/posts/game/mindustry/turretautoaim/","summary":"用處理器可以控制砲台們打的方向和什麼時候打，這樣只要有一群受控的砲台，就可以在射程範圍內指哪打哪\n單一砲台 如圖所示，砲台跟著玩家瞄準的方向打\n以下是程式碼\nradar player any any distance duo1 1 player sensor x player @shootX sensor y player @shootY sensor shoot player @shooting control shoot duo1 x y shoot 0    command description     radar 取得玩家物件   sensor 抽出玩家物件的 shootX、shootY（瞄準的點）和 shooting（是否正在開火）   control 控制 duo1 砲台       variable description     player 玩家物件   x 瞄準的 X 座標   y 瞄準的 Y 座標   shooting 是否開火    多個砲台 上面的指令只能控制一個砲台，那麼要怎麼控制多個砲台呢？答案是 loop，但是 Mindustry 沒有提供 loop，我們只能用 jump，那麼就來看看程式吧！","title":"砲台自動瞄準"},{"content":"在遊戲中，如何有效的讓資源集中在前線是一門學問，最好的情況當然是所有可能路徑都佈置強大的火力，但真實情況往往不是如此。\n當遇到有多個洞口的地圖時，你可能堵好一個洞，敵方就從令一個洞跑進來，然後核心就被攻破了，但是你又沒有足夠的資源和時間在第一時間把所有的洞都佈置火力。這時候你就必須了解的方式如何行動的。\n 本文提到的敵方都是遊戲電腦 AI，所以比較笨、很好騙，如果是和你的朋友對打，可能就不適用了。\n 自動找路 尋找路徑可說是電腦科學一個很常見又基本的問題，Mindustry 尋路演算法會考慮預估時間。這個預估時間包括距離、要打破的牆等等，計算出來了之後選擇一條最段時間的路。注意，這裡他不會考慮沿途可能遭受的火力，我們就是要利用他這點來設計。\n我的習慣作法 首先，最靠近空降區的洞不一定適合佈置砲台（例如第三關廢墟海岸左上角那個超級小的洞）這些地方可能是腹地狹小或是資源不足，總之你不會想要在這裡放砲台。那就用三層銅牆（不一定要 2x2 的，1x1 也可以）把他堵起來，一層防守兩層緩衝。挑選到適合的地方佈置砲台後，不要堵死，要留一條寬至少 3 格、夠長的通道。這個通道你要確保通暢，可以毫無阻礙的通到你的核心，這樣電腦就會判定這條路毫無阻礙，優先選擇，敵人就不會亂走到你沒有佈防的地方。這樣做還有一個好處，當你可以生產機甲時，友方機甲就可以直接走出去，不會受到阻礙，你也不用幫他們開門。\n然後在左右佈滿砲台，記得一定要放修理方塊，這樣你才不用常常來修方塊。至於通道長度和牆壁厚度，取決於這關敵方火力強度和你選用的砲台射程，如果你能夠在對方開火之前就幹掉他們，當然牆壁可以一層意思意思就好。\n","permalink":"https://blog.simba-fs.dev/posts/game/mindustry/pathofenemy/","summary":"在遊戲中，如何有效的讓資源集中在前線是一門學問，最好的情況當然是所有可能路徑都佈置強大的火力，但真實情況往往不是如此。\n當遇到有多個洞口的地圖時，你可能堵好一個洞，敵方就從令一個洞跑進來，然後核心就被攻破了，但是你又沒有足夠的資源和時間在第一時間把所有的洞都佈置火力。這時候你就必須了解的方式如何行動的。\n 本文提到的敵方都是遊戲電腦 AI，所以比較笨、很好騙，如果是和你的朋友對打，可能就不適用了。\n 自動找路 尋找路徑可說是電腦科學一個很常見又基本的問題，Mindustry 尋路演算法會考慮預估時間。這個預估時間包括距離、要打破的牆等等，計算出來了之後選擇一條最段時間的路。注意，這裡他不會考慮沿途可能遭受的火力，我們就是要利用他這點來設計。\n我的習慣作法 首先，最靠近空降區的洞不一定適合佈置砲台（例如第三關廢墟海岸左上角那個超級小的洞）這些地方可能是腹地狹小或是資源不足，總之你不會想要在這裡放砲台。那就用三層銅牆（不一定要 2x2 的，1x1 也可以）把他堵起來，一層防守兩層緩衝。挑選到適合的地方佈置砲台後，不要堵死，要留一條寬至少 3 格、夠長的通道。這個通道你要確保通暢，可以毫無阻礙的通到你的核心，這樣電腦就會判定這條路毫無阻礙，優先選擇，敵人就不會亂走到你沒有佈防的地方。這樣做還有一個好處，當你可以生產機甲時，友方機甲就可以直接走出去，不會受到阻礙，你也不用幫他們開門。\n然後在左右佈滿砲台，記得一定要放修理方塊，這樣你才不用常常來修方塊。至於通道長度和牆壁厚度，取決於這關敵方火力強度和你選用的砲台射程，如果你能夠在對方開火之前就幹掉他們，當然牆壁可以一層意思意思就好。","title":"控制敵方路徑"},{"content":"Mindustry 中，某條輸送帶（A）合併到另一條未滿的輸送帶（B）上時，如果 B 有一個足夠小的空隙，A 是有機會無法補滿的\n這種情況通常出現在兩列礦機的合併\n要解決這個狀況，最簡單的方法是加上一個分配器\n當然這裡的輸出是不能被堵住的，不然就沒有意義了(X\n","permalink":"https://blog.simba-fs.dev/posts/game/mindustry/merge/","summary":"Mindustry 中，某條輸送帶（A）合併到另一條未滿的輸送帶（B）上時，如果 B 有一個足夠小的空隙，A 是有機會無法補滿的\n這種情況通常出現在兩列礦機的合併\n要解決這個狀況，最簡單的方法是加上一個分配器\n當然這裡的輸出是不能被堵住的，不然就沒有意義了(X","title":"Merge"},{"content":"感謝廖煥杰 liaojason2 賣我一個 1200，撿到寶啦！我買的是 Yubikey 5C NFC，看起來幾乎所有功能都有\nlogin 如果開啟這個，登入、解除鎖定等等動作都需要 Yubikey，聽起還很安全，但是因為我的筆電只有一個 type C，所以必須把 USB hub 拔掉，挺麻煩，我就把他關掉了。\n在密碼輸入框的地方，先插入 yubikey，輸入密碼、按 enter，然後轉圈圈的時候按 yubikey 上金色按鈕（這個似乎是指紋辨識），就可以登入了。\n Yubico Yubikey 5C NFC setup on Ubuntu 21.04\n ssh gpg 研究中\u0026hellip;\n 如何在 Mac 上，把 YubiKey 與 GPG、SSH 搭配在一起 OpenPGP SSH access with Yubikey and GnuPG\n 2FA 按照各個網站的說明設定，下面是我找到可以設定 Yubikey 的網站/APP\n Google（我買這個 yubikey 最主要目的） Github twitter facebook heroku  twitter 在手機登入好像怪怪的，試了 5 分鐘才成功登入了\n","permalink":"https://blog.simba-fs.dev/posts/linux/yubikey/","summary":"感謝廖煥杰 liaojason2 賣我一個 1200，撿到寶啦！我買的是 Yubikey 5C NFC，看起來幾乎所有功能都有\nlogin 如果開啟這個，登入、解除鎖定等等動作都需要 Yubikey，聽起還很安全，但是因為我的筆電只有一個 type C，所以必須把 USB hub 拔掉，挺麻煩，我就把他關掉了。\n在密碼輸入框的地方，先插入 yubikey，輸入密碼、按 enter，然後轉圈圈的時候按 yubikey 上金色按鈕（這個似乎是指紋辨識），就可以登入了。\n Yubico Yubikey 5C NFC setup on Ubuntu 21.04\n ssh gpg 研究中\u0026hellip;\n 如何在 Mac 上，把 YubiKey 與 GPG、SSH 搭配在一起 OpenPGP SSH access with Yubikey and GnuPG\n 2FA 按照各個網站的說明設定，下面是我找到可以設定 Yubikey 的網站/APP\n Google（我買這個 yubikey 最主要目的） Github twitter facebook heroku  twitter 在手機登入好像怪怪的，試了 5 分鐘才成功登入了","title":"Yubikey"},{"content":"anbox 是 Android in a box，是一種基於容器化技術的 Android 模擬器，所以執行速度會比較快、比較省資源，而且因為每個 App 都在各自的容器裡面，所以比較安全 （應該沒理解錯吧？）。\n安裝 anbox 需要先安裝兩個 kernal modules，然後安裝 anbox 後，為了之後方便，所以要裝 Google Play，不裝也是可以，但之後安裝其他 App 比較麻煩\n系統 我用的系統是 Ubuntu 21.04，如果你的系統不一樣，可能會有某些步驟不太一樣。\n這次安裝因為涉及 Linux Kernel 所以隨時重開機有很大機會幫助改善遇到的問題\n安裝 Linux Kernal Modules 如果你的 Linux kernale \u0026gt; 5.0，那理論上已經包在 Kernel 裡面了，所以不用安裝\n Starting with Ubuntu 19.04 binder and ashmem are now build with the standard Ubuntu kernel (\u0026gt;= 5.0) and you don’t have to install the modules from the PPA anymore.\n 但是我還是把命令跑了一次，反正有病治病沒病強身\nsudo add-apt-repository ppa:morphis/anbox-support sudo apt update # 這個步驟應該會包括在上面那個命令，但執行一次也不會壞 sudo apt install linux-headers-generic anbox-modules-dkms # 這個後面那個套件應該會找不到，跳過他 sudo apt install software-properties-common sudo modprobe ashmem_linux sudo modprobe binder_linux 然後如果你還是很擔心不放心有沒有裝好，可以執行下面的指令\ngit clone https://github.com/anbox/anbox-modules /tmp/anbox-modules cd /tmp/anbox-modules sudo ./INSTALL.sh 這時候如果你還是很擔心，不確定有沒有裝好，可以用下面的命令檢查有沒有安裝好（這個時候可能需要重開機）\nls -1 /dev/{ashmem,binder} # 這個是官方用的，但是我怎麼試都失敗，但是 anbox 還是安裝成功了 lsmod | grep -e ashmem -e binder # 我不確定這個找到是不是代表有成功啟動，但是他兩個都找的到  https://docs.anbox.io/userguide/install_kernel_modules.html\n 安裝 anbox 如果你的電腦上有 snap，就用 snap 裝；如果沒有，就先去裝 snap。\nsudo snap install --devmode --beta anbox 嘿對，裝好了，可以用這個指令看看有沒有裝好\nsnap info anbox  https://docs.anbox.io/userguide/install.html\n apt 如果你是 Ubuntu/Debian 長期使用者，你可能會想用 apt 裝 anbox，也不是不行，但是等等裝 Google Play 的時候會出一點點問題（OverlayFS 路徑有問題），最佳解決辦法就是用 snap，不要用 apt\nsudo apt remove anbox 安裝 Google Play 因為 anbox 沒有內建 apk 安裝器，所以沒辦法很方便的安裝 APP，最方便的方法是安裝 Google Play。\nsudo apt install wget curl lzip tar unzip squashfs-tools wget https://raw.githubusercontent.com/geeks-r-us/anbox-playstore-installer/master/install-playstore.sh chmod +x install-playstore.sh sudo ./install-playstore.sh 如果遇到 Overlay not enable 的問題，請不要用 apt，至於位什麼自己研究 install-playstores.sh 跑完如果沒錯誤就可以打開 anbox.appmgr，打開 play 安裝 APP 了。\n https://www.clusterednetworks.com/blog/post/install-google-play-store-anbox\n 問遺 目前裝好 APP 但是我打不開\n","permalink":"https://blog.simba-fs.dev/posts/linux/anbox/","summary":"anbox 是 Android in a box，是一種基於容器化技術的 Android 模擬器，所以執行速度會比較快、比較省資源，而且因為每個 App 都在各自的容器裡面，所以比較安全 （應該沒理解錯吧？）。\n安裝 anbox 需要先安裝兩個 kernal modules，然後安裝 anbox 後，為了之後方便，所以要裝 Google Play，不裝也是可以，但之後安裝其他 App 比較麻煩\n系統 我用的系統是 Ubuntu 21.04，如果你的系統不一樣，可能會有某些步驟不太一樣。\n這次安裝因為涉及 Linux Kernel 所以隨時重開機有很大機會幫助改善遇到的問題\n安裝 Linux Kernal Modules 如果你的 Linux kernale \u0026gt; 5.0，那理論上已經包在 Kernel 裡面了，所以不用安裝\n Starting with Ubuntu 19.04 binder and ashmem are now build with the standard Ubuntu kernel (\u0026gt;= 5.0) and you don’t have to install the modules from the PPA anymore.","title":"Anbox"},{"content":"最近在打字時總覺得中文選字的時候 ibus 字體好小，於是就開始查怎麼弄\n經過搜尋後，找到 https://askubuntu.com/questions/1030442/how-to-increase-font-size-of-preview-options-when-using-an-input-method 這個網頁，總而言之就是先去裝 ibus font setting 這個外掛，然後就可以用 ibus-setup 調整了\n照做之後的確可以調大小字體，但我不知道是不是因為裝了這個外掛的關係，反正我是成功改好了\n","permalink":"https://blog.simba-fs.dev/posts/linux/ibus-font/","summary":"最近在打字時總覺得中文選字的時候 ibus 字體好小，於是就開始查怎麼弄\n經過搜尋後，找到 https://askubuntu.com/questions/1030442/how-to-increase-font-size-of-preview-options-when-using-an-input-method 這個網頁，總而言之就是先去裝 ibus font setting 這個外掛，然後就可以用 ibus-setup 調整了\n照做之後的確可以調大小字體，但我不知道是不是因為裝了這個外掛的關係，反正我是成功改好了","title":"Ibus Font"},{"content":"kdeconnect 顧名思義是 kde 出的一款 connect 軟體，功能非常多而且方便。電腦和手機都安裝好軟體後，只要在同一個網域就可以配對連接\n功能介紹  基本訊息 - 在電腦和手機上可以互相看到電池、網路等基本訊息 通知 - 可以設定電腦顯示手機通知或手機顯示電腦通知，或是兩者都開啟，我通常只開前者 媒體控制 - 無論是 VLC、YouTube、Nefflix 或任何網頁，都可以控制進度、音量、暫停，而且雙方都可以控制。這個是我最愛的功能之一 命令控制 - kdeconnect 可以讓你在手機上執行電腦上預先設定好的指令，像是關機、鎖定等等，下面會推薦幾個我設定的命令 傳檔案和資料夾共用 - kdeconnect 可以讓你連接電腦和手機上特定的資料夾，或是傳送單一檔案 共用剪貼簿 - 如其名，這是一個非常實用的功能，但是有時候觸發條件怪怪的 輸入 - 不論是滑鼠、鍵盤，兩邊都可以互相當對方的輸入裝置，這個功能非常好用 還有像是讓手機大叫（找手機用）、簡報控制、傳簡訊、手機有電話的時候自動暫停音樂等等奇奇怪怪的功能  推薦命令    Description Command     鎖定螢幕並暫停 VLC 播放 loginctl lock-session; dbus-send --type=method_call --dest=org.mpris.MediaPlayer2.vlc /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.PlayPause   解除鎖定螢幕（免密碼） loginctl unlock-session    ","permalink":"https://blog.simba-fs.dev/posts/linux/kdeconnect/","summary":"kdeconnect 顧名思義是 kde 出的一款 connect 軟體，功能非常多而且方便。電腦和手機都安裝好軟體後，只要在同一個網域就可以配對連接\n功能介紹  基本訊息 - 在電腦和手機上可以互相看到電池、網路等基本訊息 通知 - 可以設定電腦顯示手機通知或手機顯示電腦通知，或是兩者都開啟，我通常只開前者 媒體控制 - 無論是 VLC、YouTube、Nefflix 或任何網頁，都可以控制進度、音量、暫停，而且雙方都可以控制。這個是我最愛的功能之一 命令控制 - kdeconnect 可以讓你在手機上執行電腦上預先設定好的指令，像是關機、鎖定等等，下面會推薦幾個我設定的命令 傳檔案和資料夾共用 - kdeconnect 可以讓你連接電腦和手機上特定的資料夾，或是傳送單一檔案 共用剪貼簿 - 如其名，這是一個非常實用的功能，但是有時候觸發條件怪怪的 輸入 - 不論是滑鼠、鍵盤，兩邊都可以互相當對方的輸入裝置，這個功能非常好用 還有像是讓手機大叫（找手機用）、簡報控制、傳簡訊、手機有電話的時候自動暫停音樂等等奇奇怪怪的功能  推薦命令    Description Command     鎖定螢幕並暫停 VLC 播放 loginctl lock-session; dbus-send --type=method_call --dest=org.mpris.MediaPlayer2.vlc /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.PlayPause   解除鎖定螢幕（免密碼） loginctl unlock-session    ","title":"kdeconnect"},{"content":"modeline 是一個可以將 vim 設定嵌入檔案的方式，這樣就可以讓某些檔案有自己的設定，像是折疊、不要行數、tab 等於多少空白等等。\n簡單的條件 簡單的 modeline 需要滿足幾個條件：\n 開頭（不必是行首）至少有一個空白/tab 用 vim、vi 等字開頭，這裡還可以設定哪個版本才要載入  基本的範例  vim: wrap 參考資料 https://stackoverflow.com/questions/3958416/embed-vim-settings-in-file\nhelp page in :help modeline\n","permalink":"https://blog.simba-fs.dev/posts/linux/vim/modeline/","summary":"modeline 是一個可以將 vim 設定嵌入檔案的方式，這樣就可以讓某些檔案有自己的設定，像是折疊、不要行數、tab 等於多少空白等等。\n簡單的條件 簡單的 modeline 需要滿足幾個條件：\n 開頭（不必是行首）至少有一個空白/tab 用 vim、vi 等字開頭，這裡還可以設定哪個版本才要載入  基本的範例  vim: wrap 參考資料 https://stackoverflow.com/questions/3958416/embed-vim-settings-in-file\nhelp page in :help modeline","title":"Modeline"},{"content":"如果自己寫的小工具的 GitHub 頁面右邊 Release 那欄有個什麼東西，一定很酷對吧！如果裡面已經提供了不同作業系統編譯好的程式，一定更酷！\n想要建立 Release，你可以在新版本發布時自己手動 crose compile 再手動設定 Release，這個方法可行，但是聽起來全手動就很 low，我們要用一個全自動的方式發 Release！\nGithub Actioin 既然我們程式碼都託管在 GitHub 了，直接用 Gtithub Action 是很合理的吧！\n觸發條件 因為我們要做的是發布版本，不是每個 commit 都要觸發，因此觸發條件就設成\non:  push:  tags:  - \u0026#34;v[0-9]+.[0-9]+.[0-9]+\u0026#34; 意思是只有像是 v0.1.13 這樣的標籤會觸發，也就是你建立新版本時。\n編譯 在嘗試各種套件之後，我覺得 goreleaser-action 是我用起來最舒服的，不用太多設定，就直接都編譯好了（詳細設定可以去 goreleaser 的網站看 )\n在 GitHub Action 中設定就下面幾行，第一個步驟是安裝 go，再來就是編譯了。\n- name: Set up Go  uses: actions/setup-go@v3.0.0  with:  go-version: 1.17.x - name: Run GoReleaser  uses: goreleaser/goreleaser-action@v2.9.1  with:  version: latest  args: release --rm-dist  env:  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 注意，裡面有個 secret.GITHUB_TOKEN，這個東西你就照寫，不要抄錯，GitHub Action 會自動在 runtime 填入，所以你也不用特別去設定。\n上傳編譯好的執行檔 goreleaser 的文件裡面有推薦一個上傳的套件，但是可能是我笨，那個都不成功。我用的是另一套 upload-to-github-release，這個可以一次上傳多個檔案，設定一樣很簡單。\n- uses: little-core-labs/get-git-tag@v3.0.1  id: tagName - name: Upload To Github Release  uses: xresloader/upload-to-github-release@v1.3.2  env:  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  with:  file: \u0026#34;dist/telegrary_*\u0026#34;  draft: true  tag_name: ${{ steps.tagName.outputs.tag }} 你會看到在上傳之前還有一個步驟，這個是用來取得 tag name 用的，他用來指定檔案要上傳到哪裡\n在 with.file 這欄，你可以指定要上傳的檔案，這個要設成什麼就要看你 goreleaser 編譯出來的檔案放在哪，叫什麼（這個都是可以設定的）\ndraft 設成 true 有個好處，就是 Action 跑玩後不會立刻建立新 Release，而是你在去手動確認，而且包括 Release name、Change log 都設定好了，你只需要看有沒有什麼說明要加，就可以直接按發布了，非常方便。當然你如果沒有什麼想說的，就可以直接設定 draft: true，如此一來就真的是「全自動了」\n完整 action 設定檔 以上是細部解說，下面就是完整設定檔，如果有更新的話請到 https://github.com/simba-fs/telegrary/blob/main/.github/workflows/release.yml 看最新版。\nname: Release  on:  push:  tags:  - \u0026#34;v[0-9]+.[0-9]+.[0-9]+\u0026#34;  jobs:  goreleaser:  runs-on: ubuntu-latest  steps:  - name: Checkout  uses: actions/checkout@v2  - name: Unshallow  run: git fetch --prune --unshallow  - name: Set up Go  uses: actions/setup-go@v3.0.0  with:  go-version: 1.17.x  - name: Run GoReleaser  uses: goreleaser/goreleaser-action@v2.9.1  with:  version: latest  args: release --rm-dist  env:  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  - name: ls  run: | ls dist  - uses: little-core-labs/get-git-tag@v3.0.1  id: tagName  - name: Upload To Github Release  uses: xresloader/upload-to-github-release@v1.3.2  env:  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  with:  file: \u0026#34;dist/telegrary_*\u0026#34;  draft: true  tag_name: ${{ steps.tagName.outputs.tag }} ","permalink":"https://blog.simba-fs.dev/posts/golang/github-action-release/","summary":"如果自己寫的小工具的 GitHub 頁面右邊 Release 那欄有個什麼東西，一定很酷對吧！如果裡面已經提供了不同作業系統編譯好的程式，一定更酷！\n想要建立 Release，你可以在新版本發布時自己手動 crose compile 再手動設定 Release，這個方法可行，但是聽起來全手動就很 low，我們要用一個全自動的方式發 Release！\nGithub Actioin 既然我們程式碼都託管在 GitHub 了，直接用 Gtithub Action 是很合理的吧！\n觸發條件 因為我們要做的是發布版本，不是每個 commit 都要觸發，因此觸發條件就設成\non:  push:  tags:  - \u0026#34;v[0-9]+.[0-9]+.[0-9]+\u0026#34; 意思是只有像是 v0.1.13 這樣的標籤會觸發，也就是你建立新版本時。\n編譯 在嘗試各種套件之後，我覺得 goreleaser-action 是我用起來最舒服的，不用太多設定，就直接都編譯好了（詳細設定可以去 goreleaser 的網站看 )\n在 GitHub Action 中設定就下面幾行，第一個步驟是安裝 go，再來就是編譯了。\n- name: Set up Go  uses: actions/setup-go@v3.0.0  with:  go-version: 1.17.x - name: Run GoReleaser  uses: goreleaser/goreleaser-action@v2.9.1  with:  version: latest  args: release --rm-dist  env:  GITHUB_TOKEN: ${{ secrets.","title":"用 Github Action 編譯並發 Release"},{"content":"震動 vs 振動 都是往復運動，但有不同，簡單來說，振動比震動有規律。 像是單擺是振動，地震是震動，因為單擺的運動是規律的，而地震波比較不規律\nhttps://pedia.cloud.edu.tw/Entry/Detail/?title=%E6%8C%AF%E5%8B%95 https://pedia.cloud.edu.tw/Entry/Detail?title=%E9%9C%87%E5%8B%95\n至於為什麼我會去查這個呢？因為我發現物理實驗預報寫「簡諧震動」，但是我覺得「震」筆畫太多了，我想寫「振」於是就跑去查教育部字典\n得證：懶惰使人進步\n","permalink":"https://blog.simba-fs.dev/posts/daily/vibrate/","summary":"震動 vs 振動 都是往復運動，但有不同，簡單來說，振動比震動有規律。 像是單擺是振動，地震是震動，因為單擺的運動是規律的，而地震波比較不規律\nhttps://pedia.cloud.edu.tw/Entry/Detail/?title=%E6%8C%AF%E5%8B%95 https://pedia.cloud.edu.tw/Entry/Detail?title=%E9%9C%87%E5%8B%95\n至於為什麼我會去查這個呢？因為我發現物理實驗預報寫「簡諧震動」，但是我覺得「震」筆畫太多了，我想寫「振」於是就跑去查教育部字典\n得證：懶惰使人進步","title":"震動 vs 振動"},{"content":"裝了 Ubuntu 20.04 之後不知道為什麼藍芽用一用就會卡住，所有設備都連不上，也關不掉。一開始的解決方式是重開機（這時候關機會跳一個奇怪的錯誤訊息），但是覺得太沒效率了，上網查了一下。\n原因 根據 這個網頁，這個似乎是 linux 核心的藍芽驅動有問題（我沒有認真看，但好像是升級到最新的 linux kernel 就可以解決了）。\n雖然升級 linux kernel 應該可以一勞永逸解決這個問題，但是這個 bug 其實不常出現，為了他編譯核心有點大題小做，所以我們需要一個簡單的方法解決。\n輕便解法 根據 這篇問答，經過我的測試，第一個答案就可以解決了，當藍芽又掛掉時，執行\nsudo rmmod btusb sudo modprobe btusb 這樣藍芽就回來了。這兩個指令簡單來說就是重新載入藍芽模組，這就是為什麼重開機可以解決（重開機就是重新載入所有模組）\n","permalink":"https://blog.simba-fs.dev/posts/linux/bluwtooth-error/","summary":"裝了 Ubuntu 20.04 之後不知道為什麼藍芽用一用就會卡住，所有設備都連不上，也關不掉。一開始的解決方式是重開機（這時候關機會跳一個奇怪的錯誤訊息），但是覺得太沒效率了，上網查了一下。\n原因 根據 這個網頁，這個似乎是 linux 核心的藍芽驅動有問題（我沒有認真看，但好像是升級到最新的 linux kernel 就可以解決了）。\n雖然升級 linux kernel 應該可以一勞永逸解決這個問題，但是這個 bug 其實不常出現，為了他編譯核心有點大題小做，所以我們需要一個簡單的方法解決。\n輕便解法 根據 這篇問答，經過我的測試，第一個答案就可以解決了，當藍芽又掛掉時，執行\nsudo rmmod btusb sudo modprobe btusb 這樣藍芽就回來了。這兩個指令簡單來說就是重新載入藍芽模組，這就是為什麼重開機可以解決（重開機就是重新載入所有模組）","title":"Bluetooth 突然卡住都不動"},{"content":"Go 動態載入程式 Go 是一個編譯式的語言，也就是說他不像 JS 那樣可以動態執行程式碼。像是 Hexo 和 Hugo，前者因為是 JS 寫的，因此支援非常豐富的外掛，但後者因為是 Go 寫的，因此在不使用其他直譯式程式語言的情況下，很難製作外掛。\n另一個 Go 寫的軟體 ponzu 則是在加入一段程式碼後，重新編譯自己。這麼做解決了外掛的問題，而且又不會失去 Go 的快速，但是就必須保留整個主程式的原始碼，而且也不那麼的「動態」\n ponzu 這個軟體兩年沒人維護了，很多東西都怪怪的，超級難編譯\n Plugin in Go 在 1.8 版的時候，Go 推出了 Plguin 套件，可以將外掛和主程式分開編譯，如果外掛有更動，不需要重新編譯主程式；主程式也可以動態載入外掛。\n外掛 如果要將一個 package 編譯成外掛，首先他的 package 必須是 main，但是裡面的函式 main、init 都不會被執行，只有大寫開頭的變數、型態、函式會被暴露給主程式。\n編譯外掛時，需要加上 -buildmode=plguin，這樣 go build 就會將原始碼編譯成 .so（share object）檔，這樣就可以被主程式呼叫。\n主程式 主程式要載入外掛前，需要引用 plugin 套件\nimport \u0026#34;plugin\u0026#34; 用 func Open(path string) (*Plugin, error) 可以載入一個編譯過的外掛，如果重複呼叫這個函式，除了第二次外都會回傳第一次載入的結果，也就是說假如你在很多個 gorutine 中載入同一個外掛，go 會保證他是「安全」的。注意看，path 是個字串，因此你可以動態產生外掛的路徑，不需要寫死。\n載入完了之後，用 func (p *Plugin) Lookup(symName string) (Symbol, error) 可以取得外掛暴露出來的變數、函式，因為 symName 是字串，因此這裡也可以動態選擇要的變數。現在你有一個型態是 Symbol 的變數了，其實這個 Symbol 就是 interface{} 所以不管要做什麼事，你都要先用 symbol.(type) 取得他真實的值和型態。接下來就可以隨意的使用他了。\n範例  以下摘自 https://github.com/simba-fs/go-plugin-test\n main.go package main  import ( \t\u0026#34;bufio\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;plugin\u0026#34; \t\u0026#34;strings\u0026#34; \t\u0026#34;os\u0026#34; )  func main() { \tstdin := bufio.NewReader(os.Stdin) \tfor { \tfmt.Printf(\u0026#34;\u0026gt; \u0026#34;) \trawCmd, err := stdin.ReadString(\u0026#39;\\n\u0026#39;) \tif err != nil { \tfmt.Println(err) \tcontinue \t}  \tcmd := strings.Split(rawCmd, \u0026#34; \u0026#34;) \tfor k, v := range cmd { \tcmd[k] = strings.TrimSpace(v) \t}  \tif cmd[0] == \u0026#34;exit\u0026#34; { \tbreak \t} \tp, err := plugin.Open(fmt.Sprintf(\u0026#34;./dist/%s.so\u0026#34;, cmd[0])) \tif err != nil { \tfmt.Println(err) \tcontinue \t}  \tf, err := p.Lookup(\u0026#34;Exec\u0026#34;) \tif err != nil { \tfmt.Println(err) \tcontinue \t}  \tf.(func([]string) error)(cmd) \t}  } plugins/ls.go package main  import \u0026#34;os/exec\u0026#34; import \u0026#34;os\u0026#34; import \u0026#34;fmt\u0026#34;  func Exec(args []string) error { \tls := exec.Command(\u0026#34;ls\u0026#34;, args[1:]...) \tls.Stdout = os.Stdout \tls.Stderr = os.Stderr \treturn ls.Run() } ","permalink":"https://blog.simba-fs.dev/posts/golang/plguin/","summary":"Go 動態載入程式 Go 是一個編譯式的語言，也就是說他不像 JS 那樣可以動態執行程式碼。像是 Hexo 和 Hugo，前者因為是 JS 寫的，因此支援非常豐富的外掛，但後者因為是 Go 寫的，因此在不使用其他直譯式程式語言的情況下，很難製作外掛。\n另一個 Go 寫的軟體 ponzu 則是在加入一段程式碼後，重新編譯自己。這麼做解決了外掛的問題，而且又不會失去 Go 的快速，但是就必須保留整個主程式的原始碼，而且也不那麼的「動態」\n ponzu 這個軟體兩年沒人維護了，很多東西都怪怪的，超級難編譯\n Plugin in Go 在 1.8 版的時候，Go 推出了 Plguin 套件，可以將外掛和主程式分開編譯，如果外掛有更動，不需要重新編譯主程式；主程式也可以動態載入外掛。\n外掛 如果要將一個 package 編譯成外掛，首先他的 package 必須是 main，但是裡面的函式 main、init 都不會被執行，只有大寫開頭的變數、型態、函式會被暴露給主程式。\n編譯外掛時，需要加上 -buildmode=plguin，這樣 go build 就會將原始碼編譯成 .so（share object）檔，這樣就可以被主程式呼叫。\n主程式 主程式要載入外掛前，需要引用 plugin 套件\nimport \u0026#34;plugin\u0026#34; 用 func Open(path string) (*Plugin, error) 可以載入一個編譯過的外掛，如果重複呼叫這個函式，除了第二次外都會回傳第一次載入的結果，也就是說假如你在很多個 gorutine 中載入同一個外掛，go 會保證他是「安全」的。注意看，path 是個字串，因此你可以動態產生外掛的路徑，不需要寫死。\n載入完了之後，用 func (p *Plugin) Lookup(symName string) (Symbol, error) 可以取得外掛暴露出來的變數、函式，因為 symName 是字串，因此這裡也可以動態選擇要的變數。現在你有一個型態是 Symbol 的變數了，其實這個 Symbol 就是 interface{} 所以不管要做什麼事，你都要先用 symbol.","title":"Golang Plguin"},{"content":"今天在開發晶晶體產生器的時候，發現中文輸入總是有問題，這時候我想起以前看過 Hackmd 官方的一篇 blog，提到中文輸入法如果有問題，可能和組字事件有關。於是就開始研究。首先我將以下設定加入 textarea 裡觀察組字事件的行為\nonCompositionStart={(e) =\u0026gt; console.log(\u0026#39;compositionStart\u0026#39;, e.data)} onCompositionEnd={(e) =\u0026gt; console.log(\u0026#39;compositionEnd\u0026#39;, e.data)} onCompositionUpdate={(e) =\u0026gt; console.log(\u0026#39;compositionUpdate\u0026#39;, e.data)} 當我打「今天我想要吃蛋餅」的時候，console 長這樣\ncompositionStart \u0026lt;empty string\u0026gt; compositionUpdate ㄐ compositionUpdate ㄐㄧ compositionUpdate ㄐㄧㄣ compositionUpdate 今 compositionUpdate 今ㄊ compositionUpdate 今ㄊㄧ compositionUpdate 今ㄊㄧㄢ compositionUpdate 今天 compositionUpdate 今天ㄨ compositionUpdate 今天ㄨㄛ compositionUpdate 今天ㄒㄨㄛ compositionUpdate 今天ㄒㄨ compositionUpdate 今天ㄒ compositionUpdate 今天 compositionUpdate 今天ㄨ compositionUpdate 今天ㄨㄛ compositionUpdate 今天我 compositionUpdate 今天我ㄒ compositionUpdate 今天我ㄒㄧ compositionUpdate 今天我ㄒㄧㄤ compositionUpdate 今天我想 compositionUpdate 今天我想ㄧ compositionUpdate 今天我想ㄧㄠ compositionUpdate 今天我想要 compositionUpdate 今天我想要ㄔ compositionUpdate 今天我想要吃 compositionUpdate 今天我想要吃ㄉ compositionUpdate 今天我想要吃ㄉㄢ compositionUpdate 今天我想要吃但 compositionUpdate 今天我想要吃但ㄅ compositionUpdate 今天我想要吃但ㄅㄧ compositionUpdate 今天我想要吃但ㄅㄧㄥ compositionUpdate 今天我想要吃蛋餅 compositionUpdate \u0026lt;empty string\u0026gt; compositionEnd \u0026lt;empty string\u0026gt; 根據實驗結果，我猜我們可以用 onCompositionUpdate 事件來修正，於是現在 textarea 變成這樣\n\u0026lt;textarea \tclassName={style.input} \tvalue={t} \tonChange={(e) =\u0026gt; setInput(() =\u0026gt; e.target.value)} \tonCompositionUpdate={(e) =\u0026gt; setInput(() =\u0026gt; e.data)} \tonContextMenu={handleContext} /\u0026gt; 如此一來就解決中文輸入的問題了！但是目前這個版本只能解決「一次」的中文輸入，也就是說如果中斷的話，之前的將會被清空。這個問題可以修改 onCompositionUpdate 的處理函式解決（有待研究）\n  Update: 2022/02/08\n 目前部份解決接續輸入的問題，但是只能從最後面繼續，不能從中間插入。目前的 textarea 長這樣\nconst [previousInput, setPreviousInput] = useState(\u0026#39;\u0026#39;);  \u0026lt;textarea \tclassName={style.input} \tvalue={t} \tonChange={e =\u0026gt; setInput(() =\u0026gt; e.target.value)} \tonCompositionUpdate={e =\u0026gt; setInput(() =\u0026gt; previousInput + e.data)} \tonCompositionStart={() =\u0026gt; setPreviousInput(() =\u0026gt; input)} \tonContextMenu={handleContext} /\u0026gt; ","permalink":"https://blog.simba-fs.dev/posts/frontend/react-composition/","summary":"今天在開發晶晶體產生器的時候，發現中文輸入總是有問題，這時候我想起以前看過 Hackmd 官方的一篇 blog，提到中文輸入法如果有問題，可能和組字事件有關。於是就開始研究。首先我將以下設定加入 textarea 裡觀察組字事件的行為\nonCompositionStart={(e) =\u0026gt; console.log(\u0026#39;compositionStart\u0026#39;, e.data)} onCompositionEnd={(e) =\u0026gt; console.log(\u0026#39;compositionEnd\u0026#39;, e.data)} onCompositionUpdate={(e) =\u0026gt; console.log(\u0026#39;compositionUpdate\u0026#39;, e.data)} 當我打「今天我想要吃蛋餅」的時候，console 長這樣\ncompositionStart \u0026lt;empty string\u0026gt; compositionUpdate ㄐ compositionUpdate ㄐㄧ compositionUpdate ㄐㄧㄣ compositionUpdate 今 compositionUpdate 今ㄊ compositionUpdate 今ㄊㄧ compositionUpdate 今ㄊㄧㄢ compositionUpdate 今天 compositionUpdate 今天ㄨ compositionUpdate 今天ㄨㄛ compositionUpdate 今天ㄒㄨㄛ compositionUpdate 今天ㄒㄨ compositionUpdate 今天ㄒ compositionUpdate 今天 compositionUpdate 今天ㄨ compositionUpdate 今天ㄨㄛ compositionUpdate 今天我 compositionUpdate 今天我ㄒ compositionUpdate 今天我ㄒㄧ compositionUpdate 今天我ㄒㄧㄤ compositionUpdate 今天我想 compositionUpdate 今天我想ㄧ compositionUpdate 今天我想ㄧㄠ compositionUpdate 今天我想要 compositionUpdate 今天我想要ㄔ compositionUpdate 今天我想要吃 compositionUpdate 今天我想要吃ㄉ compositionUpdate 今天我想要吃ㄉㄢ compositionUpdate 今天我想要吃但 compositionUpdate 今天我想要吃但ㄅ compositionUpdate 今天我想要吃但ㄅㄧ compositionUpdate 今天我想要吃但ㄅㄧㄥ compositionUpdate 今天我想要吃蛋餅 compositionUpdate \u0026lt;empty string\u0026gt; compositionEnd \u0026lt;empty string\u0026gt; 根據實驗結果，我猜我們可以用 onCompositionUpdate 事件來修正，於是現在 textarea 變成這樣","title":"React 解決中文輸入法"},{"content":"LaTeX 是一老牌的排版系統，基本的概念是內容與呈現分離，在撰寫內容時不用管排版（所以你就不會擔心移動圖片一咪咪整份文件就跑版了）。除了排版，LaTeX 還很擅長輸出各種莫名其妙的東西，像是超複雜的數學式、象棋棋譜、化學結構\u0026hellip;\u0026hellip;\n        credit:https://zh.wikipedia.org/wiki/LaTeX    在使用 LaTeX 一段時間之後，對它的印象就是加強版的 Markdown（或是說 Markdown 是簡化版的 LaTeX），而且他還有巨集，可以擴展原版沒有提供的功能（就是上面那些奇奇怪怪的東西）。\n幾個重點 中文 使用 LaTeX 對大部分人最重要的就是「怎麼打中文」，總不可能打全英文報告吧！要用中文，渲染引擎要用 XLaTeX，然後加上以下設定\n（.ttf 可以指向你自己喜歡的中文字型檔）\n\\usepackage[CJKmath=true,AutoFakeBold=3,AutoFakeSlant=.2]{xeCJK} \\newCJKfontfamily\\Kai{[jf-openhuninn-1.1.ttf]} \\newCJKfontfamily\\Hei{[jf-openhuninn-1.1.ttf]} \\newCJKfontfamily\\NewMing{[jf-openhuninn-1.1.ttf]}  \\usepackage{fontspec} \\setmainfont{[jf-openhuninn-1.1.ttf]} \\setmonofont{[jf-openhuninn-1.1.ttf]} \\XeTeXlinebreaklocale \u0026#34;zh\u0026#34; 換行 LaTeX 在換行這個設計和 Markdown 一樣，因為內容與呈現分離，所以你的換行不是真的換行。Markdown 用  （兩個空白），在 LaTeX 是 \\\\（兩個反斜線）\n巨集與 Package LaTeX 一個核心概念是巨集，就是函數啦，巨集的開頭是 \\（反斜線），巨集可以自己定義，也可以用 \\usepackage{} 載入別人寫好的\noverleaf overleaf 是一個線上編輯 LaTeX 的網站，預裝了幾乎所有寫報告用得到的 packages，而且可以上傳自己的字型、圖片，而且右邊可以顯示產生的 PDF（非即時，按 CTRL-Enter 編譯）。這個網站整體使用體驗還算不錯，該有的功能都有了。\n表格 切版 畫 LaTeX 表格最簡單的方式是用 Google Sheet + latexkit，這個外掛可以幫你把跨行、跨欄表格通通弄好，你只需要再調整格線和格式就行了（latexkit 只負責切版）\n格線 直線 如果直線你需要兩條，在 \\begin{tabular}{|L|L|} 這裡多加幾條 | 就可以了。直線如果遇到跨列的格子會自動跳過，所以你不需要處理\n橫線 只需要用 \\hline 就可以畫一條橫線。\n但是因為橫線遇到跨行的格子不會自動跳過，所以需要特殊處理。可以用 hhline 這個 package，用法很簡單，\\hhline{|~|-|=|}。\n~ 是不劃線，- 是畫一條線，=是畫兩條線，而這裡的 | 是在畫兩條線時要畫線中間的直線（你畫兩條線時試試看就知道了）\n數學表格 做報告的時候一定會遇到表格裡有數學符號，如果你懶得前後都加 $ 的話，可以用以下的方式\n\\newcolumntype{L}{\u0026gt;{$}l\u0026lt;{$}} % math-mode version of \u0026#34;l\u0026#34; column type  \\begin{tabular}{|L|L|} \\pi \u0026amp; \\tau \\end{tabular} 其他 其他零碎的使用方法建議參考 Saintan的LaTeX小教室，裡面寫的非常詳細\n符號表 在 LaTeX 打數學式的時候，一定會遇到一些莫名其妙的符號，可以參考下面兩個網站，可以依序找，第二個因為東西太多了所以會比較難找一點\nhttps://www.overleaf.com/learn/latex/List_of_Greek_letters_and_math_symbols\nhttps://www.caam.rice.edu/~heinken/latex/symbols.pdf\n我的 LaTeX 範本 這是我寫物理實驗結報的範本\n\\documentclass[12pt,a4paper]{article}  \\title{物理實驗結報範本} \\author{學號：X12345678 \\\\ 姓名：XXX \\\\ 第 17 組} \\date{2021-10-08}  \\usepackage{amsmath} \\usepackage{mathtools} \\usepackage{graphicx} \\usepackage{array} % for \\newcolumntype macro \\newcolumntype{L}{\u0026gt;{$}l\u0026lt;{$}} % math-mode version of \u0026#34;l\u0026#34; column type \\usepackage[utf8]{inputenc} \\usepackage[T1]{fontenc} \\usepackage{textcomp} \\usepackage{gensymb} \\usepackage{multirow} \\usepackage{hhline} \\usepackage{indentfirst}  \\usepackage[CJKmath=true,AutoFakeBold=3,AutoFakeSlant=.2]{xeCJK} \\newCJKfontfamily\\Kai{[jf-openhuninn-1.1.ttf]} \\newCJKfontfamily\\Hei{[jf-openhuninn-1.1.ttf]} \\newCJKfontfamily\\NewMing{[jf-openhuninn-1.1.ttf]}  \\usepackage{fontspec} \\setmainfont{[jf-openhuninn-1.1.ttf]} \\setmonofont{[jf-openhuninn-1.1.ttf]} \\XeTeXlinebreaklocale \u0026#34;zh\u0026#34;  \\begin{document} \\maketitle  \\section{簡介}  \\section{原始數據}  \\section{數據分析}  \\section{誤差分析} \\subsection{百分誤差}  \\subsection{誤差原因}  \\section{結果與討論} \\end{document} ","permalink":"https://blog.simba-fs.dev/posts/other/latex-starter/","summary":"LaTeX 是一老牌的排版系統，基本的概念是內容與呈現分離，在撰寫內容時不用管排版（所以你就不會擔心移動圖片一咪咪整份文件就跑版了）。除了排版，LaTeX 還很擅長輸出各種莫名其妙的東西，像是超複雜的數學式、象棋棋譜、化學結構\u0026hellip;\u0026hellip;\n        credit:https://zh.wikipedia.org/wiki/LaTeX    在使用 LaTeX 一段時間之後，對它的印象就是加強版的 Markdown（或是說 Markdown 是簡化版的 LaTeX），而且他還有巨集，可以擴展原版沒有提供的功能（就是上面那些奇奇怪怪的東西）。\n幾個重點 中文 使用 LaTeX 對大部分人最重要的就是「怎麼打中文」，總不可能打全英文報告吧！要用中文，渲染引擎要用 XLaTeX，然後加上以下設定\n（.ttf 可以指向你自己喜歡的中文字型檔）\n\\usepackage[CJKmath=true,AutoFakeBold=3,AutoFakeSlant=.2]{xeCJK} \\newCJKfontfamily\\Kai{[jf-openhuninn-1.1.ttf]} \\newCJKfontfamily\\Hei{[jf-openhuninn-1.1.ttf]} \\newCJKfontfamily\\NewMing{[jf-openhuninn-1.1.ttf]}  \\usepackage{fontspec} \\setmainfont{[jf-openhuninn-1.1.ttf]} \\setmonofont{[jf-openhuninn-1.1.ttf]} \\XeTeXlinebreaklocale \u0026#34;zh\u0026#34; 換行 LaTeX 在換行這個設計和 Markdown 一樣，因為內容與呈現分離，所以你的換行不是真的換行。Markdown 用  （兩個空白），在 LaTeX 是 \\\\（兩個反斜線）\n巨集與 Package LaTeX 一個核心概念是巨集，就是函數啦，巨集的開頭是 \\（反斜線），巨集可以自己定義，也可以用 \\usepackage{} 載入別人寫好的\noverleaf overleaf 是一個線上編輯 LaTeX 的網站，預裝了幾乎所有寫報告用得到的 packages，而且可以上傳自己的字型、圖片，而且右邊可以顯示產生的 PDF（非即時，按 CTRL-Enter 編譯）。這個網站整體使用體驗還算不錯，該有的功能都有了。\n表格 切版 畫 LaTeX 表格最簡單的方式是用 Google Sheet + latexkit，這個外掛可以幫你把跨行、跨欄表格通通弄好，你只需要再調整格線和格式就行了（latexkit 只負責切版）","title":"LaTeX Starter"},{"content":"Golang 執行外部命令 package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;os/exec\u0026#34; )  func checkErr(err error) { \tif err != nil { \tpanic(err) \t} }  func main() { \tpw := exec.Command(\u0026#34;wc\u0026#34;)  \tstdin, err := pw.StdinPipe() \tcheckErr(err)  \tfmt.Fprintln(stdin, \u0026#34;fjasdfkjsad\\njdfaksdfjksdfjkasdfj\\ndjfkajsdk\u0026#34;)  \toutput, err := pw.Output() \tcheckErr(err)  \tfmt.Println(string(output)) } ","permalink":"https://blog.simba-fs.dev/posts/golang/exec-cmd/","summary":"Golang 執行外部命令 package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;os/exec\u0026#34; )  func checkErr(err error) { \tif err != nil { \tpanic(err) \t} }  func main() { \tpw := exec.Command(\u0026#34;wc\u0026#34;)  \tstdin, err := pw.StdinPipe() \tcheckErr(err)  \tfmt.Fprintln(stdin, \u0026#34;fjasdfkjsad\\njdfaksdfjksdfjkasdfj\\ndjfkajsdk\u0026#34;)  \toutput, err := pw.Output() \tcheckErr(err)  \tfmt.Println(string(output)) } ","title":"ExecCmd"},{"content":"aconf 是個可以直接幫你解決所有「設定」問題的套件，設定可以有預設、從命令列參數、環境變數和設定檔，設定檔還有官方支援四種格式，dotEnv、HCL、toml、yaml 和 json。\n而且設定檔還可以有不只一個，他可以把多個設定檔合成，相當方便\n基本使用 定義 struct 首先我們需要一個 struct 來定義我們的設定\ntype Config struct { \tAddr string `default:\u0026#34;:3000\u0026#34;` \tTitle string `default:\u0026#34;Aconf Testing\u0026#34;` \tSysAdmin []string `default:\u0026#34;simba-fs,peter\u0026#34;` } 載入設定 再來，我們可以設定要從哪些來源載入設定值\nloader := aconfig.LoaderFor(\u0026amp;config, aconfig.Config{ \t// 這四個預設都是關閉的，如果你想關閉任何一個隨時都可以關閉他 \t// SkipDefaults: false, \t// SkipFiles: false, \t// SkipEnv: false, \t// SkipFlags: false, \tEnvPrefix: \u0026#34;APP\u0026#34;, \tFlagPrefix: \u0026#34;app\u0026#34;, \tFiles: []string{\u0026#34;~/.config/app.toml\u0026#34;, \u0026#34;app.toml\u0026#34;}, \tFileDecoders: map[string]aconfig.FileDecoder{ \t\u0026#34;.toml\u0026#34;: aconfigtoml.New(), \t}, })  if err := loader.Load(); err != nil { \tpanic(err) } 這樣你就可以用檔案、環境變數和命令列參數設定了。\n設定名稱 我們在 struct 中定義的設定名稱，在各個來源會有一些變化，下面是例子\n   struct 設定檔 環境變數 命令列參數     Addr addr {EnvPrefix}_ADDR {FlagPrefix}{FlagDelimiter}attr   SysAdmin sys_admin {EnvPrefix}_SYS_ADMIN {FlagPrefix}{FlagDelimiter}sys_admin    這邊有另外幾個設定，以下是他們的預設值\n   config default     EnvPrefix \u0026ldquo;\u0026quot;（最好自己設，不然可能重複）   FlagPrefix \u0026quot;\u0026rdquo; （如果沒有設，FlagDelimiter 也不會有作用）   FlagDelimiter .    從命令列載入設定檔 預設你是不行從命令列設定你自己的設定檔路徑，但是你可以開啟這個選項\n用 FileFlag 可以設定「設定檔路徑」的選項\n參考連結 https://github.com/cristalhq/aconfig\nhttps://pkg.go.dev/github.com/cristalhq/aconfig\n","permalink":"https://blog.simba-fs.dev/posts/golang/aconf/","summary":"aconf 是個可以直接幫你解決所有「設定」問題的套件，設定可以有預設、從命令列參數、環境變數和設定檔，設定檔還有官方支援四種格式，dotEnv、HCL、toml、yaml 和 json。\n而且設定檔還可以有不只一個，他可以把多個設定檔合成，相當方便\n基本使用 定義 struct 首先我們需要一個 struct 來定義我們的設定\ntype Config struct { \tAddr string `default:\u0026#34;:3000\u0026#34;` \tTitle string `default:\u0026#34;Aconf Testing\u0026#34;` \tSysAdmin []string `default:\u0026#34;simba-fs,peter\u0026#34;` } 載入設定 再來，我們可以設定要從哪些來源載入設定值\nloader := aconfig.LoaderFor(\u0026amp;config, aconfig.Config{ \t// 這四個預設都是關閉的，如果你想關閉任何一個隨時都可以關閉他 \t// SkipDefaults: false, \t// SkipFiles: false, \t// SkipEnv: false, \t// SkipFlags: false, \tEnvPrefix: \u0026#34;APP\u0026#34;, \tFlagPrefix: \u0026#34;app\u0026#34;, \tFiles: []string{\u0026#34;~/.config/app.toml\u0026#34;, \u0026#34;app.toml\u0026#34;}, \tFileDecoders: map[string]aconfig.FileDecoder{ \t\u0026#34;.toml\u0026#34;: aconfigtoml.New(), \t}, })  if err := loader.","title":"Aconf"},{"content":"        from: https://stackoverflow.blog/2021/04/19/how-often-do-people-actually-copy-and-paste-from-stack-overflow-now-we-know/    這個是一個 梗圖，大意是你寫程式一定會用到 CTRL-C 和 CTRL-V。我們今天就來看看 vim 的剪貼簿吧！\n在用剪貼簿時，複製的來源可能會有很多種，以我們的環境為例，可能會用系統剪貼簿、tmux 和 vim 本身的剪貼簿\n系統剪貼簿 基本上對 vim 來說系統剪貼簿和 tmux 在複製貼上是差不多的，在輸入模式貼上就可以了\n但是要注意多行的程式碼貼上時 vim 會把縮排搞亂，所以你要嘛用 \u0026lt;leader\u0026gt;f 重新整理程式碼，或是用命令 :r!cat，貼上後再按 C-d 貼到程式裡面。\n:r!cat 這個命令在 Day 13 時有把他寫成快捷鍵 \u0026lt;F3\u0026gt; 了，所以你也可以直接按 \u0026lt;F3\u0026gt;  會有一樣的效果\n另外，下面會講到用 vim 命令存取系統剪貼簿\n   ❓ :r!cat 是什麼意思？     r 這個命令是「載入某個檔案並貼到游標行下面」，用法是 :r {file}。但是我們這裡不用檔名，!cat 在這裡的意思是「shell 命令 cat 的 stdout 這個檔案」，而執行 cat 時需要 stdin，也就是你剛剛貼上程式碼的地方（在 status bar 下面）。這個方法可以繞過自動縮排，就不會出現程式碼貼上被 vim 弄亂的情形了。    從 vim 複製 複製到系統剪貼簿很簡單，在選取時記的按住 \u0026lt;SHIFT\u0026gt; 就行了，但是因為我們有開啟 vim 滑鼠模式，所以 tmux 剪貼簿就不能複製了（滑鼠被 vim 搶走）（關於 tmux 剪貼簿請看 Day 09#複製。\nvim 基礎剪貼簿 在 vim 裡面，你可用基礎的 yy、dd、x 等指令將文字放進剪貼簿，或是更進階的 d4w、y5l 等等。\n貼上的話比較單純，就只有 p 一個（還有 P ）\n   ❓ p 和 P 的差別     小寫 p 會把內容貼到游標後，大寫 P 會把內容貼到游標前    vim 進階剪貼簿 在 vim 裡面有個東西叫做 register，中文大概是「儲存器」之類的，我們這邊就這樣叫他。\n這個東西就是「有命名的」剪貼簿（包含剛剛用的「未命名的」剪貼簿）\n這個東西可以分成兩類，一是可寫的，另一類是有特殊意義的儲存器\n列出儲存器 在開始介紹儲存器之前，我們先來看看如何查看儲存器，這樣你在學使用他時就可以一邊操作一邊對照。\n列出儲存器內容的命令是 :registers 或是縮寫 :reg，他會列出所有目前儲存器中有的內容\n寫入可寫的的儲存器 vim 中可寫的儲存器並不是隨便你命名，只有 0 ~ 9 和 a - z，另外這是不分大小寫，所以 a ~ z 和 A ~ Z 是一樣的。\n要存入儲存器方法很簡單，只要在指令（yy、d4w 之類的）之前加上 \u0026quot;x，這個 x 代指儲存器代號（[0-9a-z]）\n例如「把整行存入 g 儲存器」的指令就是 \u0026quot;gyy（注意沒有冒號，直接在命令模式打）。\n貼上可寫的的儲存器 命令模式 在命令模式中，和寫入時的用法一樣，在 p 之前加上 \u0026quot;x\n例如「把儲存器 g 中的內容貼上」的指令就是 \u0026quot;gp\n編輯模式 如果你不想為了貼上一段字切換到命令模式（尤其是打中文時切輸入法很痛苦），你可以用 \u0026lt;C-r\u0026gt; 加上編號貼上\n例如「把儲存器 g 中的內容貼上」的指令就是 \u0026lt;C-r\u0026gt;g\n有特殊意義儲存器 以下我用表格列出有特殊意義的儲存器，他們也都是一個字元代表    儲存器 描述     \u0026quot; s命名儲存器（預設的，如果不指定就是存到這裡面）   - 「剪下」（ d2w、x 之類的）的少於一行的（不包括換行）   : 上次執行的冒號命令   . 上次輸入模式輸入的文字（唯讀）   % 目前的檔案名稱（唯讀）   # 在這個視窗中上一個編輯的文件的檔案名稱（唯讀）   = 這個叫做「表達式儲存器」，但是他其實不是一個可寫入的儲存器，下面會專門介紹他   * 你的「滑鼠」反白的文字（其他視窗或是 vim 裡面都可以）   + 你的系統剪貼簿   _ 黑洞儲存器，只進不出，如果你嘗試讀取這個儲存器你什麼都不會得到，這可以用在剪下一段文字但是不影響任何儲存器   / 上次用 / 搜的字串    表達式儲存器 這個儲存器很特別，因為他可以執行命令，或是你可以把他當作計算機！\n計算機 當你輸入 \u0026quot;=10+77\u0026lt;enter\u0026gt;p 時，vim 會在你的游標後面貼上 87，這個就是等於符號 = 後面的計算式計算出來的結果\n你也可以在輸入模式用 \u0026lt;C-r\u0026gt;=10+77\u0026lt;enter\u0026gt; （這裡不用打 p）\n我測試過這裡的計算式可以用的和 C/C++ 中差不多，一樣遵守四則運算和括號優先，而且如果整數沒有加上 .0 去做除法會得到的是 int / int 的結果，除數被除數只要有一方是 float 就可以了，另外他的精度到小數點後六位。\n執行命令 在等號後面除了接上運算式，你也可以接一個 vim 的「函數」，然後函數的回傳值就會被印到 vim 裡面。\n這些函數有些是 vim 內建，有些是外掛加進來的。其中有個內建函數 system()，接受一個字串當作參數，回傳這個字串拿去 shell 執行後的輸出。\n例如我想貼上目前目錄所有的檔案名稱，可以這樣做：在命令模式執行 \u0026quot;=sysyem('ls -a') 或是在輸入模式 \u0026lt;C-r\u0026gt;=sysyem('ls -a')\n這樣就會把 ls -a 的結果貼上來了！\n        分別在命令模式和輸入模式示範    另外這些函數也可以用 :call funcion() 來執行\n結尾 vim 的 register 真的非常好用，尤其是基礎的那 36 個儲存器，相較於系統剪貼簿又更豐富了！\n關於儲存器還有很多細節是我的文章無法詳細列出來的，你可以用命令 :help :reg 看看更多儲存器的說明\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day21/","summary":"from: https://stackoverflow.blog/2021/04/19/how-often-do-people-actually-copy-and-paste-from-stack-overflow-now-we-know/    這個是一個 梗圖，大意是你寫程式一定會用到 CTRL-C 和 CTRL-V。我們今天就來看看 vim 的剪貼簿吧！\n在用剪貼簿時，複製的來源可能會有很多種，以我們的環境為例，可能會用系統剪貼簿、tmux 和 vim 本身的剪貼簿\n系統剪貼簿 基本上對 vim 來說系統剪貼簿和 tmux 在複製貼上是差不多的，在輸入模式貼上就可以了\n但是要注意多行的程式碼貼上時 vim 會把縮排搞亂，所以你要嘛用 \u0026lt;leader\u0026gt;f 重新整理程式碼，或是用命令 :r!cat，貼上後再按 C-d 貼到程式裡面。\n:r!cat 這個命令在 Day 13 時有把他寫成快捷鍵 \u0026lt;F3\u0026gt; 了，所以你也可以直接按 \u0026lt;F3\u0026gt;  會有一樣的效果\n另外，下面會講到用 vim 命令存取系統剪貼簿\n   ❓ :r!cat 是什麼意思？     r 這個命令是「載入某個檔案並貼到游標行下面」，用法是 :r {file}。但是我們這裡不用檔名，!cat 在這裡的意思是「shell 命令 cat 的 stdout 這個檔案」，而執行 cat 時需要 stdin，也就是你剛剛貼上程式碼的地方（在 status bar 下面）。這個方法可以繞過自動縮排，就不會出現程式碼貼上被 vim 弄亂的情形了。    從 vim 複製 複製到系統剪貼簿很簡單，在選取時記的按住 \u0026lt;SHIFT\u0026gt; 就行了，但是因為我們有開啟 vim 滑鼠模式，所以 tmux 剪貼簿就不能複製了（滑鼠被 vim 搶走）（關於 tmux 剪貼簿請看 Day 09#複製。","title":"Day 21：儲存器與剪貼簿"},{"content":"分割螢幕 記的 tmux 可以切螢幕嗎？vim 也可以喔！\n命令 我們快速用表格帶過命令\n   快捷鍵 命令 效果     s :sp[lit] {file} 水平分割   v :vs[plit] {file} 垂直分割   +  把目前視窗放大一點   -  把目前視窗縮小一點   =  等大   c :q 關掉目前視窗   o  關掉其他視窗   方向鍵/h/j/k/l/tag  在視窗間移動    如果你在 day 13 有開啟滑鼠模式，那你可以直接用滑鼠拉動邊框調整大小\nvim 分割視窗的優點 與 tmux 比起來，我更常用 tmux 分割視窗，因為快捷鍵比較直覺好用，但是 vim 有個 tmux 做不到的優點\n如果你用 tmux 分割視窗並開啟同一個檔案，對於系統來說你其實是開了兩次，兩個的更改互相不相關。\n但是 vim 不一樣，他是「同一份檔案」，也就是說左邊的改動會立刻同步到右邊\n        如果開啟一個檔案，左邊的更改會立刻同步到右邊    這個特性有個好處，如果檔案太長，你要主要要編輯了兩個區域沒辦法在同一個螢幕顯示，就可以用 vim 的分割畫面，左邊編輯上面，右邊編輯下面。\n分頁 比起切割螢幕，我更常用分頁功能。vim 每個分頁都和 tmux 一樣，可以隨便你亂切，不會互相影響。\n快捷鍵 一樣快速看過命令\n   快捷鍵 命令 效果      :tabe {file} 開啟新分頁並開啟檔案，如果不指定檔名會開啟一個空白檔案   gt  下一個分頁   gT  上一個分頁    一樣，如果你開啟了滑鼠模式，你可以用滑鼠點擊切換分頁（最上面）\nNerdtree nerdtree 是我面在 day 15 #現代化-ide-必裝模組 中列出了第三個模組。為什麼提到他呢？因為當你用 nerdtree 瀏覽檔案時，你可以用命令（快捷鍵）t 在新分頁中開啟檔案\n        用 nerdtree 在新分頁開心檔案，注意看最上面，深灰色底的是現在的 tab    ","permalink":"https://blog.simba-fs.dev/posts/ithelp/day20/","summary":"分割螢幕 記的 tmux 可以切螢幕嗎？vim 也可以喔！\n命令 我們快速用表格帶過命令\n   快捷鍵 命令 效果     s :sp[lit] {file} 水平分割   v :vs[plit] {file} 垂直分割   +  把目前視窗放大一點   -  把目前視窗縮小一點   =  等大   c :q 關掉目前視窗   o  關掉其他視窗   方向鍵/h/j/k/l/tag  在視窗間移動    如果你在 day 13 有開啟滑鼠模式，那你可以直接用滑鼠拉動邊框調整大小\nvim 分割視窗的優點 與 tmux 比起來，我更常用 tmux 分割視窗，因為快捷鍵比較直覺好用，但是 vim 有個 tmux 做不到的優點","title":"Day 20：切水果囉！vim 切螢幕與分頁"},{"content":"重複 如果想讓某個標籤/群組重複，只要用乘號 * 加上數字就可以讓他重複了\nh1.title*5  -\u0026gt;  \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  (p.artical+br)*3  -\u0026gt;  \u0026lt;p class=\u0026#34;artical\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p class=\u0026#34;artical\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p class=\u0026#34;artical\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; 迭代 在重複的時候，你可能會有某些地方是要要變化的，例如從 id 從 1 開始遞增，你可以使用錢號 $ 代表要遞增的位數\n如果你不是要從 1 開始迭代，可以使用小老鼠 @ 指定開始的數字\n如果要反著數，用 @- 可以倒數到 0，當然也可以指定倒數到多少\nh1#title$$*12  -\u0026gt;  \u0026lt;h1 id=\u0026#34;title01\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title02\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title03\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title04\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title05\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title06\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title07\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title08\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title09\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title10\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title11\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title12\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  h1#$@10*3  -\u0026gt;  \u0026lt;h1 id=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;11\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;12\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  h1#$@-*3  -\u0026gt;  \u0026lt;h1 id=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  h1#$@-6*3  -\u0026gt;  \u0026lt;h1 id=\u0026#34;8\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;7\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;6\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  h$*6  -\u0026gt;  \u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;\u0026lt;/h6\u0026gt; 範本包圍  我不確定這個叫什麼，反正就這樣啦\n 剛剛講的功能都只有產生空白標籤，不能批次產生內容，現在這個東西可以快速把內容和你的 HTML 標籤結合，產生程式碼！\n先假設我們有四行內容\nApple Book Cat Dog 我們要先用選取模式把他們匡起來（要完整的匡喔，沒匡到的地方不會被處理到）\n然後按下快捷鍵 \u0026lt;C-y\u0026gt;,，vim 底下會出現一行 Tag: ，這時候你可以輸入 emmet 程式碼了\ndiv\u0026gt;h1.alphaBet*\u0026gt;a 被你匡起來的文字就會以行為單位放進 HTML 標籤裡了，就像這樣\n\u0026lt;div\u0026gt; \u0026lt;h1 class=\u0026#34;alphabet\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Apple\u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;alphabet\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Book\u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;alphabet\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Cat\u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;alphabet\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Dog\u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; 這裡要注意一點，在 emmet 中諦一個出現星號 * 的地方代表這下面（包括這層）的標籤要重複\n在剛剛的例子裡，星號打在 h1 這個標籤上，所以 h1 之後的標籤（h1、a）都會重複 N 次（ N 取決於你匡了幾行），並且要填充的內容會放在最後一層標籤（a）中\n結論 這兩天我自己打的內容大概只有 1/10 吧，剩餘的都是 emmet 產生的，emmet 真的太好用了！\n有沒有感覺 emmet 比你想像的複雜多了，還有很多語法沒講到，像是 css 的拓展等等，更多用法可以去 emmet 的 官網 https://docs.emmet.io/cheat-sheet/ 看看喔（很容易看到頭暈，別說我沒警告你）\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day19/","summary":"重複 如果想讓某個標籤/群組重複，只要用乘號 * 加上數字就可以讓他重複了\nh1.title*5  -\u0026gt;  \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  (p.artical+br)*3  -\u0026gt;  \u0026lt;p class=\u0026#34;artical\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p class=\u0026#34;artical\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p class=\u0026#34;artical\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; 迭代 在重複的時候，你可能會有某些地方是要要變化的，例如從 id 從 1 開始遞增，你可以使用錢號 $ 代表要遞增的位數\n如果你不是要從 1 開始迭代，可以使用小老鼠 @ 指定開始的數字\n如果要反著數，用 @- 可以倒數到 0，當然也可以指定倒數到多少\nh1#title$$*12  -\u0026gt;  \u0026lt;h1 id=\u0026#34;title01\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title02\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title03\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title04\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title05\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title06\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title07\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title08\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title09\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title10\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title11\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;title12\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  h1#$@10*3  -\u0026gt;  \u0026lt;h1 id=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;11\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;12\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  h1#$@-*3  -\u0026gt;  \u0026lt;h1 id=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  h1#$@-6*3  -\u0026gt;  \u0026lt;h1 id=\u0026#34;8\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;7\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;6\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  ------------  h$*6  -\u0026gt;  \u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;\u0026lt;/h6\u0026gt; 範本包圍  我不確定這個叫什麼，反正就這樣啦","title":"Day 19：該是時候升級你的噴射引擎囉！vim-emmet 重複與迭代"},{"content":"emmet-vim 是 emmet 的 vim 版本（這句好像是廢話\n 注意：emmet-vim 用的是自己寫的而不是用 emmet.io 官方的解析引擎\n emmet-vim 是一套外掛程式，他可以解析一段字串，然後根據規則變成 html，例如下面的例子\n.tab\u0026gt;(tr#col$\u0026gt;td*3)*4  會被解析成  \u0026lt;div class=\u0026#34;tab\u0026#34;\u0026gt; \t\u0026lt;tr id=\u0026#34;col1\u0026#34;\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;/tr\u0026gt; \t\u0026lt;tr id=\u0026#34;col2\u0026#34;\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;/tr\u0026gt; \t\u0026lt;tr id=\u0026#34;col3\u0026#34;\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;/tr\u0026gt; \t\u0026lt;tr id=\u0026#34;col4\u0026#34;\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;/tr\u0026gt; \u0026lt;/div\u0026gt; 是不是很方便，用一行的指令可以變成 22 行的 HTML，而且還會幫你排版好喔，有沒有香！\n安裝 在 ~/.config/nvim/plugin.vim 加入一行\n+ Plug \u0026#39;mattn/emmet-vim\u0026#39; 然後記得修改後需要打指令 :so % | PlugInstall 安裝\ncoc-emmet coc-emmet 是個可選可不選的 coc 擴充，可以讓你不用按 emmet-vim 的快捷鍵。雖然這個擴充幾乎可以代替 emmet-vim，但是因為他依靠 coc.nvim，所以有時候他會跳不出建議，例如右括號結尾：(p\u0026gt;div.title$)，你還是只能按 emmet-vim 的快捷鍵\n這個擴充還有個問題，像是這樣的 emmet 程式碼 (p\u0026gt;div.title$)*6 用 coc.nvim 展開後用 u 退回，*6 就神奇的消失了！（也許是我設定的問題，但不是什麼大問題）\n總而言之這個擴充相當不錯，可以裝一下\n產生標籤 emmet 最基本功能是幫你寫角括號，像是這樣\n-\u0026gt; 左邊是 emmet 程式碼，右邊是根據左邊產生出來的 HTML\ndiv  -\u0026gt;  \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 內容 在標籤後面加上大括號 {}，大括號內的文字就會被放進標籤裡面\np{hello world}  -\u0026gt;  \u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt; 屬性 你可以幫標籤加上屬性，在標籤後面加上 [key=value] 就可以指定屬性。\n其中 id 和 class 因為太常用了，所以有自己專屬的縮寫，在井字號 # 後面的是 id，在點 . 後面的是 class\n而 div 這個標籤因為很常用，所以如果直接用井字號或是點可以不用寫 div（第三個範例）\nh1[hidden=\u0026#34;hidden\u0026#34;] -\u0026gt; \u0026lt;h1 hidden=\u0026#34;hidden\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt;  h1.title -\u0026gt; \u0026lt;hi class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/hi\u0026gt;  #username -\u0026gt; \u0026lt;div id=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;  button.bg-blue.round#login -\u0026gt; \u0026lt;button id=\u0026#34;login\u0026#34; class=\u0026#34;bg-blue round\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; 並排 你可以用加號 + 讓兩個標籤並排\nh1+h2  -\u0026gt;  \u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; 巢狀標籤 大於符號 \u0026gt; 代表右側的標籤在左側標籤的裡面，而且你可以一層套一層\ndiv\u0026gt;span  -\u0026gt;  \u0026lt;div\u0026gt; \t\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;  ------------  div\u0026gt;spam\u0026gt;h1\u0026gt;a  -\u0026gt;  \u0026lt;div\u0026gt; \t\u0026lt;spam\u0026gt; \t\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \t\u0026lt;/spam\u0026gt; \u0026lt;/div\u0026gt;  ------------  div.main\u0026gt;h1.bg-green.bold\u0026gt;a  -\u0026gt;  \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \t\u0026lt;h1 class=\u0026#34;bg-green bold\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; 群組 在建立巢狀標籤時，你也可以用小括號 () 來建立群組，打破原本運算子的優先度\ndiv\u0026gt;(h1+h2)  -\u0026gt;  \u0026lt;div\u0026gt; \t\u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt; \t\u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; 假內容產生 有一個運算子名稱特別奇怪，他可以幫你產生假內容，還可以加數字指定假內容要有幾個單字\nlorem  -\u0026gt;  Sit elit consectetur ullam eius aliquam repellat! Illo quaerat quisquam minima laboriosam fugit sunt Ex voluptas modi laboriosam commodi optio, sapiente. Quasi perferendis aliquam reprehenderit in praesentium Deserunt inventore natus.  ------------  p\u0026gt;lorem4  -\u0026gt;  \u0026lt;p\u0026gt; \tLorem sunt esse odio? \u0026lt;/p\u0026gt; 結尾 今天的內容差不多就到這裡，但是 emmet 精華的部份還沒出來呢！明天今天的程式碼一行可以產生五六行，加上明天的重複、迭代後四五百行都是小 case（呃，這麼長有點誇張）\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day18/","summary":"emmet-vim 是 emmet 的 vim 版本（這句好像是廢話\n 注意：emmet-vim 用的是自己寫的而不是用 emmet.io 官方的解析引擎\n emmet-vim 是一套外掛程式，他可以解析一段字串，然後根據規則變成 html，例如下面的例子\n.tab\u0026gt;(tr#col$\u0026gt;td*3)*4  會被解析成  \u0026lt;div class=\u0026#34;tab\u0026#34;\u0026gt; \t\u0026lt;tr id=\u0026#34;col1\u0026#34;\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;/tr\u0026gt; \t\u0026lt;tr id=\u0026#34;col2\u0026#34;\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;/tr\u0026gt; \t\u0026lt;tr id=\u0026#34;col3\u0026#34;\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;/tr\u0026gt; \t\u0026lt;tr id=\u0026#34;col4\u0026#34;\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \t\u0026lt;/tr\u0026gt; \u0026lt;/div\u0026gt; 是不是很方便，用一行的指令可以變成 22 行的 HTML，而且還會幫你排版好喔，有沒有香！","title":"Day 18：幫你的 HTML 開發裝上噴射引擎！vim-emmet"},{"content":"今天的東西相當多，在 GitHub README Example 中除了昨天介紹過得今天都收錄了，直接進主題吧！\n喔！另外有些東西我真的不知道是什麼我會用原文寫並用中文括號括起來，歡迎知道的朋友留言告訴我\n\u0026#34; 設定文字編碼（我想這個你的 init.vim/.vimrc 都應該有了）set encoding=utf-8\u0026#34; 如果 hidden 沒有設定，「TextEdit」可能會失敗\u0026#34; TextEdit 也許是彈出式輸入框吧？阿災set hidden\u0026#34; 有些伺服器對於備份檔會出錯，請看 issue #649\u0026#34; https://github.com/neoclide/coc.nvim/issues/649set nobackupset nowritebackup\u0026#34; 把下面的命令欄變高，多一點空間set cmdheight=2\u0026#34; 不傳訊息給「|ins-completion-menu|」（這我看不太出來有什麼差set shortmess+=c\u0026#34; 使用 \u0026lt;c-space\u0026gt; 觸發自動完成if has(\u0026#39;nvim\u0026#39;) inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;c-space\u0026gt; coc#refresh()else inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;c-@\u0026gt; coc#refreshendif\u0026#34; 用 `[g` 和 `]g` 跳到診斷的位置（就是程式碼有問題地方\u0026#34; 用命令 `:CocDiagnostics` 在分割視窗列出目前檔案中所有有問題的點nmap \u0026lt;silent\u0026gt; [g \u0026lt;Plug\u0026gt;(coc-diagnostic-prev)nmap \u0026lt;silent\u0026gt; ]g \u0026lt;Plug\u0026gt;(coc-diagnostic-next)\u0026#34; 程式碼轉跳（這個我覺得有點難記，而且這四個實驗出來效果非常像，我的建議是試過後選你覺得順眼的，不要全上nmap \u0026lt;silent\u0026gt; gd \u0026lt;Plug\u0026gt;(coc-definition)nmap \u0026lt;silent\u0026gt; gy \u0026lt;Plug\u0026gt;(coc-type-definition)nmap \u0026lt;silent\u0026gt; gi \u0026lt;Plug\u0026gt;(coc-implementation)nmap \u0026lt;silent\u0026gt; gr \u0026lt;Plug\u0026gt;(coc-references)\u0026#34; 用 K（注意大寫）顯示文件在分割視窗nnoremap \u0026lt;silent\u0026gt; K :call \u0026lt;SID\u0026gt;show_documentation()\u0026lt;CR\u0026gt;function! s:show_documentation() if (index([\u0026#39;vim\u0026#39;,\u0026#39;help\u0026#39;], \u0026amp;filetype) \u0026gt;= 0) execute \u0026#39;h \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) elseif (coc#rpc#ready()) call CocActionAsync(\u0026#39;doHover\u0026#39;) else execute \u0026#39;!\u0026#39; . \u0026amp;keywordprg . \u0026#34; \u0026#34; . expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) endifendfunction\u0026#34; 突顯游標下的符號（這是淡淡的灰色autocmd CursorHold * silent call CocActionAsync(\u0026#39;highlight\u0026#39;)\u0026#34; 整理程式碼，但是我們在 Day 15 裝過 Chiel92/vim-autoformat 了，coc 的 autoformat 在遇到不會的情況會直白的噴錯比較醜，\u0026#34; 相較之下 vim-autoformat 比較好看，所以我建議兩個選一個，不要都裝xmap \u0026lt;leader\u0026gt;f \u0026lt;Plug\u0026gt;(coc-format-selected)nmap \u0026lt;leader\u0026gt;f \u0026lt;Plug\u0026gt;(coc-format-selected)augroup mygroup autocmd!\u0026#34; 設定指定檔案的 formatter autocmd FileType typescript,json setl formatexpr=CocAction(\u0026#39;formatSelected\u0026#39;)\u0026#34; Update signature help on jump placeholder.（這個真的不會翻譯 autocmd User CocJumpPlaceholder call CocActionAsync(\u0026#39;showSignatureHelp\u0026#39;)augroup end\u0026#34; 將 codeAction 應用到選取的區域\u0026#34; 範例：`\u0026lt;leader\u0026gt;aap` 對應一個段落 (ap = a paragraph，同理 aw = a word)xmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected)nmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected)\u0026#34; 將 codeaction 應用到這個檔案nmap \u0026lt;leader\u0026gt;ac \u0026lt;Plug\u0026gt;(coc-codeaction)\u0026#34; 自動修補目前這行（這要 language server 有提供nmap \u0026lt;leader\u0026gt;qf \u0026lt;Plug\u0026gt;(coc-fix-current)\u0026#34; 映射函數和類別（嗎？測試起來怪怪的\u0026#34; 注意：需要 language server 支援 \u0026#39;textDocument.documentSymbol\u0026#39;xmap if \u0026lt;Plug\u0026gt;(coc-funcobj-i)omap if \u0026lt;Plug\u0026gt;(coc-funcobj-i)xmap af \u0026lt;Plug\u0026gt;(coc-funcobj-a)omap af \u0026lt;Plug\u0026gt;(coc-funcobj-a)xmap ic \u0026lt;Plug\u0026gt;(coc-classobj-i)omap ic \u0026lt;Plug\u0026gt;(coc-classobj-i)xmap ac \u0026lt;Plug\u0026gt;(coc-classobj-a)omap ac \u0026lt;Plug\u0026gt;(coc-classobj-a)\u0026#34; 用 CTRL-S 選取整個函數或是類別\u0026#34; 需要 language server 支援 \u0026#39;textDocument/selectionRange\u0026#39;nmap \u0026lt;silent\u0026gt; \u0026lt;C-s\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select)xmap \u0026lt;silent\u0026gt; \u0026lt;C-s\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select)\u0026#34; 新增 `:Format` 命令，和 Chiel92/vim-autoformat 選一個就行了command! -nargs=0 Format :call CocAction(\u0026#39;format\u0026#39;)\u0026#34; 新增 `:Fold` 命令，可以折疊目前的檔案（我怎麼測試就是折不起來，不確定到底在幹麻，vim 內建也有折疊阿？command! -nargs=? Fold :call CocAction(\u0026#39;fold\u0026#39;, \u0026lt;f-args\u0026gt;)\u0026#34; 新增 `:OR` 命令，可以整理目前檔案引入的函式庫（測試 Golang 會刪掉沒用到的但是 nodejs 要用 \u0026#39;import\u0026#39; 才會理人，用 \u0026#39;require\u0026#39; 他會當作沒看到什麼都不做command! -nargs=0 OR :call CocAction(\u0026#39;runCommand\u0026#39;, \u0026#39;editor.action.organizeImport\u0026#39;)\u0026#34; 添加 (neo)vim 原生的狀態列支援（他會在最下面提供一些訊息\u0026#34; 注意：用 `:h coc-status` 指令看如何和其他狀態列外掛結合\u0026#34; 提供範例：lightline.vim, vim-airline.（如果你要用這個的話請務必看範例，不然你的外掛等於白裝set statusline^=%{coc#status()}%{get(b:,\u0026#39;coc_current_function\u0026#39;,\u0026#39;\u0026#39;)}\u0026#34; CocList 的鍵盤映射（CocList 的功能是顯示所有 XXX，我等等就只寫 XXX 的部份\u0026#34; 診斷nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;a :\u0026lt;C-u\u0026gt;CocList diagnostics\u0026lt;cr\u0026gt;\u0026#34; 擴充nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;e :\u0026lt;C-u\u0026gt;CocList extensions\u0026lt;cr\u0026gt;\u0026#34; 命令nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;c :\u0026lt;C-u\u0026gt;CocList commands\u0026lt;cr\u0026gt;\u0026#34; 大綱（和 tag bar 的功能差不多，就是你定義的變數物件函數等等nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;o :\u0026lt;C-u\u0026gt;CocList outline\u0026lt;cr\u0026gt;\u0026#34; 在 workspace 中找某個變數、函數、物件（「符號」）nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;s :\u0026lt;C-u\u0026gt;CocList -I symbols\u0026lt;cr\u0026gt;\u0026#34; 執行預設的 `:CocNext`nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;j :\u0026lt;C-u\u0026gt;CocNext\u0026lt;CR\u0026gt;\u0026#34; 執行預設的 `:CocPrevnnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;k :\u0026lt;C-u\u0026gt;CocPrev\u0026lt;CR\u0026gt;\u0026#34; 打開上一次的 `:CocList`（這個指令可以列出很多東西nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;p :\u0026lt;C-u\u0026gt;CocListResume\u0026lt;CR\u0026gt;結尾 呼～！總算翻譯完了，有幾個我真的看不出來在幹嘛的設定翻譯不太好請各位見諒。\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day17/","summary":"今天的東西相當多，在 GitHub README Example 中除了昨天介紹過得今天都收錄了，直接進主題吧！\n喔！另外有些東西我真的不知道是什麼我會用原文寫並用中文括號括起來，歡迎知道的朋友留言告訴我\n\u0026#34; 設定文字編碼（我想這個你的 init.vim/.vimrc 都應該有了）set encoding=utf-8\u0026#34; 如果 hidden 沒有設定，「TextEdit」可能會失敗\u0026#34; TextEdit 也許是彈出式輸入框吧？阿災set hidden\u0026#34; 有些伺服器對於備份檔會出錯，請看 issue #649\u0026#34; https://github.com/neoclide/coc.nvim/issues/649set nobackupset nowritebackup\u0026#34; 把下面的命令欄變高，多一點空間set cmdheight=2\u0026#34; 不傳訊息給「|ins-completion-menu|」（這我看不太出來有什麼差set shortmess+=c\u0026#34; 使用 \u0026lt;c-space\u0026gt; 觸發自動完成if has(\u0026#39;nvim\u0026#39;) inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;c-space\u0026gt; coc#refresh()else inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;c-@\u0026gt; coc#refreshendif\u0026#34; 用 `[g` 和 `]g` 跳到診斷的位置（就是程式碼有問題地方\u0026#34; 用命令 `:CocDiagnostics` 在分割視窗列出目前檔案中所有有問題的點nmap \u0026lt;silent\u0026gt; [g \u0026lt;Plug\u0026gt;(coc-diagnostic-prev)nmap \u0026lt;silent\u0026gt; ]g \u0026lt;Plug\u0026gt;(coc-diagnostic-next)\u0026#34; 程式碼轉跳（這個我覺得有點難記，而且這四個實驗出來效果非常像，我的建議是試過後選你覺得順眼的，不要全上nmap \u0026lt;silent\u0026gt; gd \u0026lt;Plug\u0026gt;(coc-definition)nmap \u0026lt;silent\u0026gt; gy \u0026lt;Plug\u0026gt;(coc-type-definition)nmap \u0026lt;silent\u0026gt; gi \u0026lt;Plug\u0026gt;(coc-implementation)nmap \u0026lt;silent\u0026gt; gr \u0026lt;Plug\u0026gt;(coc-references)\u0026#34; 用 K（注意大寫）顯示文件在分割視窗nnoremap \u0026lt;silent\u0026gt; K :call \u0026lt;SID\u0026gt;show_documentation()\u0026lt;CR\u0026gt;function!","title":"Day 17：coc.nvim 設定下集"},{"content":"一個好的自動補全工具可以讓你工作效率翻倍，你不用再去查文件了，自動補全不僅可以告訴你這裡有什麼函數可以用，還會告訴你參數的型態、函數功能的說明，可以說是把文件都寫在 vim 裡面了。\n以前我用的自動補全是 You Complete Me(YCM)，現在我選擇使用 coc.nvim 原因是他提供更多的補全來源、外掛和設定，而且可以用 nodejs 自製外掛，據說所有純 JS 寫的 VS code 外掛都可以裝（這個我沒實驗過，只是傳聞）。關於這兩個自動補全外掛的比較礙於篇幅請自行 Google。\n安裝 coc.nvim 和一般的 vim 外掛一樣，都是用 vim-plug 安裝就可以了，在 ~/.config/nvim/plugin.vim 中新增以下設定\nPlug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;branch\u0026#39;: \u0026#39;release\u0026#39;}so ~/.config/nvim/coc-config.vim因為 coc 有很多設定，為了避免檔案太雜亂我把 coc 相關的設定移到另一個檔案，就像我們在 前天 做得一樣\n接下來建立 ~/.config/nvim/coc-config.vim，不然等等載入設定檔 vim 會報錯\n:!touch ~/.config/nvim/coc-config.vim :! {cmd} 可以執行外部命令\n 接下來存檔安裝\n:w | PlugInstall跑完後，重開 vim，coc 就裝好了\nlsp 語言伺服器協定 在講 coc 之前必須先講 Language Server Protocol，簡稱 lsp，中文是「語言伺服器協定」。lsp 做的事是提供自動補全和 go to def，能做到這兩個功能的原因是因為 lsp 懂程式碼，他知道你寫的每個字代表什麼。為什麼 lsp 這麼強呢？因為 lsp 什麼都不懂，他把所有事情丟給 language server 處理，所以只要你有裝 language server，那麼 lsp 什麼語言都懂。\n這麼神奇的 lsp 就是大名鼎鼎的 vs code 提出的（難怪是最多人用的編輯器），我們深耕 45 年的 vim 當然要跟上，所以 coc.nvim 出現了，他是一個 vim 的 language client，而重點是非常好用！\n安裝 coc 擴充 剛剛說了 coc 的主要功能是把所有事情丟給別人做，那麼這個「人」設定聽起來就很麻煩，所以 coc 有個好主意，用擴充（ extension ）解決！你只要裝好擴充差不多就設定好 lsp 了\ncoc.nvim 的自動補全選字來源除了目前所有的 buffer（開啟的檔案）之外，還有 coc 擴充。\ncoc 擴充安裝很簡單，在 vim 裡面下指令 :CocInstall {extension}，那麼這個擴充的名字該去哪裡找呢？一個是 coc.nvim 的 GitHub Wiki，另一個是去 npm 搜尋 coc，稍微過濾一下大部分都是 coc.nvim 的擴充。\n剛剛講的安裝方法有一個缺點，就是當你今天要搬電腦時你要全部手動再安裝一次，這時候就有點麻煩了。所以你可以在 ~/.config/nvim/coc-config.vim 中寫下我們第一個 coc 設定\nlet g:coc_global_extensions = [\\ \u0026#39;coc-extension-1\u0026#39;,\\ \u0026#39;coc-extension-2\u0026#39;\\ ]這個變數儲存的是 coc 擴充的名字（就是你安裝時用的那個），coc 啟動如果沒安裝他就會自己去裝了，所以手動安裝好擴充後記得在這裡寫一下，為以後搬電腦做打算\n你也可以用 :CocList extensions 列出現在安裝的擴充\n至於要裝什麼擴充，這個就要看你要寫什麼程式語言了，自己去上面介紹的兩個地方找你需要的，我這裡就不多介紹\n基本設定 因為 coc 可能是你在寫程式時最常用的外掛，所以為了避免有快捷鍵衝突，coc 預設不會有任何的按鍵綁定，所以你必須自己寫全部的 keymap，在 coc.nvim 的 GitHub README.md 有範例，接下來的設定都是從這裡面挑出來的。\n以下是我覺得必須的設定，我會把註解翻成中文，有些在範例上標明「可能」、「某些情況」的設定我不會納進來，當你遇到奇怪問題時再去看看範例和 issue\n\u0026#34; 太長的更新間隔會導致明顯的延遲並降低使用者體驗（預設是 4000 ms = 4s ）set updatetime=300\u0026#34; 永遠顯示 signcolumn（行號左邊那個，這我不知道怎麼翻），否則每當有診斷出來時整個程式碼就會被往右移if has(\u0026#34;nvim-0.5.0\u0026#34;) || has(\u0026#34;patch-8.1.1564\u0026#34;)\u0026#34; 新的版本可以把 signcolumn 和行號合併（這個我版本不夠沒看過，有人知道會長怎樣可以下面留言嗎？） set signcolumn=numberelse set signcolumn=yesendif\u0026#34; 用 tab 鍵觸發自動補全\u0026#34; 注意：載入設定後記得用命令 `verbose imap \u0026lt;tab\u0026gt;` 確定這沒有被其他外掛覆蓋掉inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt;\t\\ pumvisible() ? \u0026#34;\\\u0026lt;C-n\u0026gt;\u0026#34; :\t\\ \u0026lt;SID\u0026gt;check_back_space() ? \u0026#34;\\\u0026lt;TAB\u0026gt;\u0026#34; :\t\\ coc#refresh()inoremap \u0026lt;expr\u0026gt;\u0026lt;S-TAB\u0026gt; pumvisible() ? \u0026#34;\\\u0026lt;C-p\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;C-h\u0026gt;\u0026#34;function! s:check_back_space() abort\tlet col = col(\u0026#39;.\u0026#39;) - 1\treturn !col || getline(\u0026#39;.\u0026#39;)[col - 1] =~# \u0026#39;\\s\u0026#39;endfunction\u0026#34; 讓 enter 鍵自動完成第一個建議並讓 coc 進行格式化（不確定個格式化指的是什麼，我看不太出來）\u0026#34; enter 可以被重複 keymap（看不懂就算了，意思是你亂搞不會出錯）inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;cr\u0026gt; pumvisible() ? coc#_select_confirm()\t\\: \u0026#34;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\\\u0026lt;c-r\u0026gt;=coc#on_enter()\\\u0026lt;CR\u0026gt;\u0026#34;\u0026#34; 用 \\rn 重新命名變數、函數（原文寫「符號」）nmap \u0026lt;leader\u0026gt;rn \u0026lt;Plug\u0026gt;(coc-rename)\u0026#34; 這個讓你可以捲動浮動視窗和跳出式框框（有時候自動補全給你的文件會太長超出螢幕，如果你想要看下面的內容必須設定這個）if has(\u0026#39;nvim-0.4.0\u0026#39;) || has(\u0026#39;patch-8.2.0750\u0026#39;) nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;C-f\u0026gt; coc#float#has_scroll() ? coc#float#scroll(1) : \u0026#34;\\\u0026lt;C-f\u0026gt;\u0026#34; nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;C-b\u0026gt; coc#float#has_scroll() ? coc#float#scroll(0) : \u0026#34;\\\u0026lt;C-b\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;C-f\u0026gt; coc#float#has_scroll() ? \u0026#34;\\\u0026lt;c-r\u0026gt;=coc#float#scroll(1)\\\u0026lt;cr\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;Right\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;C-b\u0026gt; coc#float#has_scroll() ? \u0026#34;\\\u0026lt;c-r\u0026gt;=coc#float#scroll(0)\\\u0026lt;cr\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;Left\u0026gt;\u0026#34; vnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;C-f\u0026gt; coc#float#has_scroll() ? coc#float#scroll(1) : \u0026#34;\\\u0026lt;C-f\u0026gt;\u0026#34; vnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;C-b\u0026gt; coc#float#has_scroll() ? coc#float#scroll(0) : \u0026#34;\\\u0026lt;C-b\u0026gt;\u0026#34;endif結尾 coc.nvim 的設定真的很多，一眼看上去會覺得很煩，但是認真看完設定好後的 vim 真的會讓你過得非常舒服。\n明天是我今天沒有介紹到的部份，大部份是超難記的快捷鍵。一樣都會有全中文翻譯（但是有些我真的沒用過，只能硬著頭皮翻譯了）\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day16/","summary":"一個好的自動補全工具可以讓你工作效率翻倍，你不用再去查文件了，自動補全不僅可以告訴你這裡有什麼函數可以用，還會告訴你參數的型態、函數功能的說明，可以說是把文件都寫在 vim 裡面了。\n以前我用的自動補全是 You Complete Me(YCM)，現在我選擇使用 coc.nvim 原因是他提供更多的補全來源、外掛和設定，而且可以用 nodejs 自製外掛，據說所有純 JS 寫的 VS code 外掛都可以裝（這個我沒實驗過，只是傳聞）。關於這兩個自動補全外掛的比較礙於篇幅請自行 Google。\n安裝 coc.nvim 和一般的 vim 外掛一樣，都是用 vim-plug 安裝就可以了，在 ~/.config/nvim/plugin.vim 中新增以下設定\nPlug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;branch\u0026#39;: \u0026#39;release\u0026#39;}so ~/.config/nvim/coc-config.vim因為 coc 有很多設定，為了避免檔案太雜亂我把 coc 相關的設定移到另一個檔案，就像我們在 前天 做得一樣\n接下來建立 ~/.config/nvim/coc-config.vim，不然等等載入設定檔 vim 會報錯\n:!touch ~/.config/nvim/coc-config.vim :! {cmd} 可以執行外部命令\n 接下來存檔安裝\n:w | PlugInstall跑完後，重開 vim，coc 就裝好了\nlsp 語言伺服器協定 在講 coc 之前必須先講 Language Server Protocol，簡稱 lsp，中文是「語言伺服器協定」。lsp 做的事是提供自動補全和 go to def，能做到這兩個功能的原因是因為 lsp 懂程式碼，他知道你寫的每個字代表什麼。為什麼 lsp 這麼強呢？因為 lsp 什麼都不懂，他把所有事情丟給 language server 處理，所以只要你有裝 language server，那麼 lsp 什麼語言都懂。","title":"Day 16：自動補全！coc.nvim"},{"content":"看到這裡，你可能還是很疑惑，到底 vim 好用在哪？嘿嘿，那是因為強大的外掛還沒裝啦！網路上會有一些配好一堆外掛的，像是 spaceVim，他們的策略和 vs code 很像，先幫你裝好一對外掛，讓你隨開及用。這樣做好處是初學者比較愛，但是常常會裝了一堆用不到的功能，反而讓載入速度、記憶體用量大增。\n所以我們自己挑我們需要的外掛裝起來，效果完全不會輸 vs code 這些笨重的編輯器！\n今天要介紹很多模組，都是我選出來製作一個現代化 IDE 必備的模組，相當的精華，一起來看看吧！ 記得修改後需要打指令 :so % | PlugInstall\n現代化 IDE 必裝模組 以下的內容直接貼到 ~/.config/nvim/plugin.vim 裡面裝模組的地方就可以了，說明附在裡面了\n注意：我這裡沒有列出 Coc.nvim，因為我把他拉出來到另外一章了\n\u0026#34; 彩色的 status barPlug \u0026#39;itchyny/lightline.vim\u0026#39;\u0026#34; 有這個設定 lightline 在單個 vim 視窗中才會正常，沒錯！vim 也可以分割視窗，後天會講set laststatus=2\u0026#34; 在行號左側會顯示這行的 git 狀態，新增、刪除、修改，詳細請看 GitHub READMEPlug \u0026#39;airblade/vim-gitgutter\u0026#39;\u0026#34; 按下 \u0026lt;F5\u0026gt; 可以開啟檔案樹，按 h 有說明，再一下關掉說明Plug \u0026#39;scrooloose/nerdtree\u0026#39;nmap \u0026lt;F5\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt;\u0026#34; Exit Vim if NERDTree is the only window left.autocmd BufEnter * if tabpagenr(\u0026#39;$\u0026#39;) == 1 \u0026amp;\u0026amp; winnr(\u0026#39;$\u0026#39;) == 1 \u0026amp;\u0026amp; exists(\u0026#39;b:NERDTree\u0026#39;) \u0026amp;\u0026amp; b:NERDTree.isTabTree() |\t\\ quit | endif\u0026#34; 自動括號Plug \u0026#39;jiangmiao/auto-pairs\u0026#39;\u0026#34; 這是自訂括號的寫法au FileType ejs let b:AutoPairs = AutoPairsDefine({\u0026#39;\u0026lt;%\u0026#39;: \u0026#39;%\u0026gt;\u0026#39;, \u0026#39;\u0026lt;!--\u0026#39;: \u0026#39;--\u0026gt;\u0026#39;})au FileType html let b:AutoPairs = AutoPairsDefine({\u0026#39;\u0026lt;!--\u0026#39;: \u0026#39;--\u0026gt;\u0026#39;})\u0026#34; 之前講過了，這邊附上一些設定Plug \u0026#39;preservim/nerdcommenter\u0026#39;filetype plugin on\u0026#34; Add spaces after comment delimiters by defaultlet g:NERDSpaceDelims = 1\u0026#34; Use compact syntax for prettified multi-line commentslet g:NERDCompactSexyComs = 1\u0026#34; Align line-wise comment delimiters flush left instead of following code indentationlet g:NERDDefaultAlign = \u0026#39;left\u0026#39;\u0026#34; Set a language to use its alternate delimiters by defaultlet g:NERDAltDelims_java = 1\u0026#34; Add your own custom formats or override the defaultslet g:NERDCustomDelimiters = { \u0026#39;c\u0026#39;: { \u0026#39;left\u0026#39;: \u0026#39;/**\u0026#39;,\u0026#39;right\u0026#39;: \u0026#39;*/\u0026#39; } }let g:NERDCustomDelimiters = { \u0026#39;ejs\u0026#39;: { \u0026#39;left\u0026#39;: \u0026#39;\u0026lt;!--\u0026#39;,\u0026#39;right\u0026#39;: \u0026#39;--\u0026gt;\u0026#39; } }\u0026#34; Allow commenting and inverting empty lines (useful when commenting a region)let g:NERDCommentEmptyLines = 1\u0026#34; Enable trimming of trailing whitespace when uncommentinglet g:NERDTrimTrailingWhitespace = 1\u0026#34; Enable NERDCommenterToggle to check all selected lines is commented or notlet g:NERDToggleCheckAllLines = 1\u0026#34; 按 \u0026lt;F6\u0026gt; 可以回朔到開啟檔案以來的任何歷史，還會標出修改的地方，很酷Plug \u0026#39;mbbill/undotree\u0026#39;nnoremap \u0026lt;F6\u0026gt; :UndotreeToggle\u0026lt;CR\u0026gt;\u0026#34; \u0026lt;F8\u0026gt; 看看你設定了哪些變數、函數，也可以快速跳轉Plug \u0026#39;majutsushi/tagbar\u0026#39;nmap \u0026lt;F8\u0026gt; :TagbarToggle\u0026lt;CR\u0026gt;\u0026#34; 用 \u0026lt;反斜線 f\u0026gt; 可以整理程式碼（要裝 python3 和 pynvim，詳細請看 GitHub ）\u0026#34; $ python3 -m pip install pynvimPlug \u0026#39;Chiel92/vim-autoformat\u0026#39;\u0026#34; 這裡指定成你的 python3 路徑let g:python3_host_prog=\u0026#34;/usr/bin/python3\u0026#34;nmap \u0026lt;leader\u0026gt;f :Autoformat\u0026lt;CR\u0026gt;\u0026#34; 在你開啟 markdown 文件時會開啟網頁預覽你的 markdown，有雙螢幕或是把畫面讓一半給瀏覽器比較好用（需要裝 nodejs）\u0026#34; $ npm -g install instant-markdown-dPlug \u0026#39;suan/vim-instant-markdown\u0026#39;, {\u0026#39;for\u0026#39;: \u0026#39;markdown\u0026#39;}\u0026#34; 快速整理程式碼，這個外掛的功能超多，但是因為有 autoformat 所以我只用排 md 表格的功能，他可以幫你把垂直線對齊，舒舒服服，要深入使用請看 GitHub README\u0026#34; 先用選取模式把表格選起來，按兩下反斜線就可以得到一個漂亮的表格Plug \u0026#39;junegunn/vim-easy-align\u0026#39;\u0026#34; Align GitHub-flavored Markdown tablesau FileType markdown vmap \u0026lt;Leader\u0026gt;\u0026lt;Bslash\u0026gt; :EasyAlign*\u0026lt;Bar\u0026gt;\u0026lt;Enter\u0026gt;\u0026#34; 快速建立 html tag，用法非常靈活，明天會專門講他的用法Plug \u0026#39;mattn/emmet-vim\u0026#39;如果對某個模組好奇，最快的方式就是去 GitHub 頁面看看，通常作者都會有很詳細的說明。\n語法外掛 有些時候 vim 對於某些程式語言的支援不是那麼好，常會有語法突顯有問題或是 vim 根本沒有支援這個語言的語法突顯。這時候裝一個語法外掛就可以讓 vim 立刻學會這門新語言（真好，我學了十年英文還是學不好）\n語法外掛做得事其實就是修正在 第 12 天 提過的 highlight group，讓 vim 可以正確的分析你的程式碼\nnvim 0.5 版有個新功能叫做 treesitter，他的功能好像和這個有關，但我沒還用過，我也不清楚\n以下是我用過得語法外掛，除非你也剛好需要不然其實不用安裝，如果你想要的某個語法外掛不在這裡面，你可以 Google 搜尋 vim + 程式語言名稱 + syntax 通常都會查到\n\u0026#34; docker filePlug \u0026#39;ekalinin/Dockerfile.vim\u0026#39;\u0026#34; js / jsx / tsPlug \u0026#39;pangloss/vim-javascript\u0026#39;Plug \u0026#39;isruslan/vim-es6\u0026#39;Plug \u0026#39;maxmellon/vim-jsx-pretty\u0026#39;\u0026#34; fix jsx tag color for vim-jsx-prettyhi link jsxPunct Directoryhi link jsxCloseString DirectoryPlug \u0026#39;HerringtonDarkholme/yats.vim\u0026#39;\u0026#34; css\u0026#34; 這個外掛很酷，他會把表示顏色的字串，像是 `black`、`#991122` 標上他們的顏色，雖然因為終端機顏色數量的問題可能不會很準，但是可以讓你一眼就看出 `#fbcd48` 是橘黃色Plug \u0026#39;ap/vim-css-color\u0026#39;\u0026#34; c / cppPlug \u0026#39;bfrg/vim-cpp-modern\u0026#39;\u0026#34; tomlPlug \u0026#39;cespare/vim-toml\u0026#39;","permalink":"https://blog.simba-fs.dev/posts/ithelp/day15/","summary":"看到這裡，你可能還是很疑惑，到底 vim 好用在哪？嘿嘿，那是因為強大的外掛還沒裝啦！網路上會有一些配好一堆外掛的，像是 spaceVim，他們的策略和 vs code 很像，先幫你裝好一對外掛，讓你隨開及用。這樣做好處是初學者比較愛，但是常常會裝了一堆用不到的功能，反而讓載入速度、記憶體用量大增。\n所以我們自己挑我們需要的外掛裝起來，效果完全不會輸 vs code 這些笨重的編輯器！\n今天要介紹很多模組，都是我選出來製作一個現代化 IDE 必備的模組，相當的精華，一起來看看吧！ 記得修改後需要打指令 :so % | PlugInstall\n現代化 IDE 必裝模組 以下的內容直接貼到 ~/.config/nvim/plugin.vim 裡面裝模組的地方就可以了，說明附在裡面了\n注意：我這裡沒有列出 Coc.nvim，因為我把他拉出來到另外一章了\n\u0026#34; 彩色的 status barPlug \u0026#39;itchyny/lightline.vim\u0026#39;\u0026#34; 有這個設定 lightline 在單個 vim 視窗中才會正常，沒錯！vim 也可以分割視窗，後天會講set laststatus=2\u0026#34; 在行號左側會顯示這行的 git 狀態，新增、刪除、修改，詳細請看 GitHub READMEPlug \u0026#39;airblade/vim-gitgutter\u0026#39;\u0026#34; 按下 \u0026lt;F5\u0026gt; 可以開啟檔案樹，按 h 有說明，再一下關掉說明Plug \u0026#39;scrooloose/nerdtree\u0026#39;nmap \u0026lt;F5\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt;\u0026#34; Exit Vim if NERDTree is the only window left.autocmd BufEnter * if tabpagenr(\u0026#39;$\u0026#39;) == 1 \u0026amp;\u0026amp; winnr(\u0026#39;$\u0026#39;) == 1 \u0026amp;\u0026amp; exists(\u0026#39;b:NERDTree\u0026#39;) \u0026amp;\u0026amp; b:NERDTree.","title":"Day 15：vim 外掛大雜燴！"},{"content":"前面講過了 zsh、tmux 的 plugin manager，vim 一樣有 plguin manager。跟前面幾個 plguin manager 很像，要安裝新的外掛只需要在某個地方加一行設定就好，這樣作的好處是哪天要再建立新的環境時只需要把設定檔帶走，而且集中式的管理可以一目了然。\n安裝 vim-plug 記得昨天的 vimrc 最上面有一個備註解起來的區塊嗎？這就是載入 vim-plug 的地方，裡面就有安裝 vim-plug 的指令了。要注意你用的是 neovim 還是 vim，這兩個路徑不一樣\n# neovim sh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39; # vim sh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39; 挑選你的 vim 版本，執行完就安裝好了！\n安裝第一個 plugin 我們透過一個範例來說明如何安裝外掛，我們要來裝的第一個外掛是 preservim/nerdcommenter，這個外掛可以快速註解一行/一整段程式碼，這是我覺得比自動補全、語法突顯都還要好用的功能。現在我們來安裝吧！\n1. 編輯 vimrc 打開你的 vimrc，把以下內容加在最下面\ncall plug#begin(\u0026#39;~/.vim/plugged\u0026#39;) call plug#end() 以後所有 plugin 的安裝設定就要放在這兩行裡面\n加上 preservim/nerdcommenter 現在在兩個 call 中間插入以下這行\nPlug \u0026#39;preservim/nerdcommenter\u0026#39; 然後存檔，這樣就算設定好了\n安裝套件 現在在 vim 裡面下以下命令\n:so % :PlugInstall 第一個是讓 vim 載入新增的外掛列表，或是你重開 vim 也可以。其中 so 是 source 的縮寫\n這個命令會讓 vim-plug 檢查有沒有新增的外掛，然後安裝。等左邊的視窗都跑完了就可以按 q 關掉，這時候重開 vim 就安裝好外掛了！\n使用 preservim/nerdcommenter 這裡簡單教一下怎麼使用這個方便的外掛 用 \\cspace可以註解/取消註解游標所在這這行。 如果用 v選取的話，只要有選到的行（不論是否完整框起），\\cspace就可以一次註解/取消註解多行\n再按的時候要注意，如果手滑沒按到反斜線會讓 vim 以為你要執行 c 指令，cspace會把一個字刪掉並進入編輯模式，這時候你可以選擇手動把字加回去或是用 u undo 指令來回復，回復好了之後再重新按一次 \\cspace就可以了。\n在 preservim/nerdcommenter 的 github 頁面 有更多的快捷鍵說明，這邊就介紹我最常用也是唯一有在用的，其他如果你覺得不錯再自己記就好了，vim 的快捷鍵/命令貴在精不在多，多了反而容易忘\n關於外掛的設定 在 preservim/nerdcommenter 的 README.md 中提到，要加一條設定 filetype plugin on 才能確保在不同程式語言中正常運作，那這行要加在哪裡比較好呢？以 vim 的觀點來看，vimrc 中任何地方都可以，但是外掛一多你就會發現亂放的話會不好管理。我推薦一個地方——安裝外掛的下面一行開始，這樣不同的外掛的設定就會都分開，萬一哪一天要修改或是移除都很清楚。\n切分 vimrc 外掛裝多了 vimrc 就會變得很長，一堆不重要不常用的外掛設定會全部塞在同一個檔案裡面。我們可以根據功用的不同分開放在不同的檔案，如此一來就會比較好找相關的設定在哪裡\n我們先把\ncall plug#begin(\u0026#39;~/.vim/plugged\u0026#39;) Plug \u0026#39;preservim/nerdcommenter\u0026#39; filetype plugin on call plug#end() 這段剪下，放到另一個檔案裡面，然後在 vimrc 最下面加上一行 so ~/.config/nvim/plugin.vim 或是 so ~/.vim/plugin.vim（根據你的 vim 不同路徑不同，前面 nvim 後面 vim） ，以下是 vim 的按鍵操作，角括號中的是特殊按鍵\n先用 S-v 把要剪下的段落選起來\ndoso ~/.config/nvim/plguin.vim\u0026lt;esc\u0026gt;:w\u0026lt;enter\u0026gt; // 這裡 vimrc 的操作就結束了，`d` 是剪下，`o` 是「在新增一行並進入編輯模式」，之後到 \u0026lt;esc\u0026gt; 之前的就是新增的內容，最後再儲存 :e ~/.config/nvim/plugin.vim\u0026lt;enter\u0026gt;p:w\u0026lt;enter\u0026gt; 在這裡用 `:e` 開啟檔案，`p` 貼上剛剛剪下的內容，`:w` 存檔 之後你要外掛相關的設定就不是在 vimrc 了，而是在 plugin.nvim 裡面，記得如果要備份的話要把這個檔案也備份到喔\n結尾 今天的內容穿插了一些 vim 的指令，如果很難理解的話建議你要一個字母一個字母拆開看，為什麼呢？例如 ddo 這個指令，你以為可能是要「做（do）」什麼事，其實這是 dd 和 o 一起寫，意思是「剪下一行」再「新增一行並進入編輯模式」。\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day14/","summary":"前面講過了 zsh、tmux 的 plugin manager，vim 一樣有 plguin manager。跟前面幾個 plguin manager 很像，要安裝新的外掛只需要在某個地方加一行設定就好，這樣作的好處是哪天要再建立新的環境時只需要把設定檔帶走，而且集中式的管理可以一目了然。\n安裝 vim-plug 記得昨天的 vimrc 最上面有一個備註解起來的區塊嗎？這就是載入 vim-plug 的地方，裡面就有安裝 vim-plug 的指令了。要注意你用的是 neovim 還是 vim，這兩個路徑不一樣\n# neovim sh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39; # vim sh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39; 挑選你的 vim 版本，執行完就安裝好了！\n安裝第一個 plugin 我們透過一個範例來說明如何安裝外掛，我們要來裝的第一個外掛是 preservim/nerdcommenter，這個外掛可以快速註解一行/一整段程式碼，這是我覺得比自動補全、語法突顯都還要好用的功能。現在我們來安裝吧！\n1. 編輯 vimrc 打開你的 vimrc，把以下內容加在最下面\ncall plug#begin(\u0026#39;~/.vim/plugged\u0026#39;) call plug#end() 以後所有 plugin 的安裝設定就要放在這兩行裡面\n加上 preservim/nerdcommenter 現在在兩個 call 中間插入以下這行\nPlug \u0026#39;preservim/nerdcommenter\u0026#39; 然後存檔，這樣就算設定好了","title":"Day 14：vim-plug"},{"content":"vim 在啟動時，都會去執行你的設定檔，這個檔案根據你的 vim 軟體不同而改變，如果是一般的 vim，那他會去讀 ~/.vimrc，如果是 neovim(nvim)，他會去找 ~/.config/nvim/init.vim。在接下來的文章中都以 vimrc 代指。\nvimrc 內容是 vimscript，也就是所有的冒號命令去掉冒號之後的內容，例如有個命令是 :set nu，這個命令可以開啟行號顯示，如果要寫在 vimrc 裡面，就要寫成 set nu。\nvimrc 通常我們會在 vimrc 中設定關於 vim 的外觀、行為、載入外掛等等，接下來是我用多年的 vimrc 的內容，我會一個一個用註解解說他們的用處(雙引號 \u0026quot; 開頭是 vimscript 的註解)\n\u0026#34; 打開語法突顯syntax on\u0026#34; load plguin\u0026#34; install vim-plug:\u0026#34; sh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs \\\u0026#34; https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39;\u0026#34; 這個是明天的東西，先註解掉，才不會出錯\u0026#34; so ~/.config/nvim/plugin.vim\u0026#34; 256 色set t_Co=256\u0026#34; 解決和 tmux 衝突，https://vi.stackexchange.com/questions/238/tmux-is-changing-part-of-the-background-in-vimset t_ut=\u0026#34; 選一個你喜歡的 colorschema\u0026#34; available color schema\u0026#34; blue darkblue default delek desert elflord evening industry koehler\u0026#34; morning murphy pablo peachpuff ron shine slate torte zellnercolorscheme koehler\u0026#34; 雜項設定，詳細解說請用 `:help \u0026lt;opeion\u0026gt;`，例如 `:help showcmd`set showcmdset nuset tabstop=4set shiftwidth=4set autoindentset nowrapset incsearchset autoindentset cindentset smartindentset cursorline\u0026#34; make lightline work in single screen\u0026#34; https://github.com/itchyny/lightline.vim/issues/71#issuecomment-47859569set laststatus=2\u0026#34; 開啟滑鼠功能，對初學者來說非常好用set mouse=a\u0026#34; markdown\u0026#34; 如果是檔案類型是 markdown 或 text，打開文字折疊（超出螢幕寬度會折到下一行）\u0026#34; au 的語法等等會講au FileType markdown set wrapau FileType text set wrap\u0026#34; ejs\u0026#34; 不加這個的話 ejs 的語法突顯會很奇怪，順便附帶一個 ft, filetype 的坑\u0026#34; https://vi.stackexchange.com/questions/16341/what-is-the-difference-between-set-ft-and-setfiletypeau BufNew,BufNewFile,BufRead *.ejs :set filetype=ejsau FileType ejs set syntax=html\u0026#34; ts \u0026#34; 這只是因為我比較喜歡 vim 對 javascript 的配色，typesript 的我覺得很醜，所以強制 vim 用 javascript 的配色\u0026#34; au 就是 autocmd 的縮寫啦！（vim 幾乎每個超過三個字的命令、選項都有縮寫，寫程式的人都很懶XD）autocmd BufNewFile,BufRead *.ts set syntax=javascript\u0026#34; yaml\u0026#34; yaml 機車的空格限制，這樣在寫 yaml 檔時比較方便autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab\u0026#34; hotkey\u0026#34; 這邊是自訂快捷鍵，語法等等會講，這邊只說明用法\u0026#34; 在命令模式按 \u0026lt;tab\u0026gt; 會把整行字向右移一個 tab。\u0026lt;S-tab\u0026gt; 會移回來map \u0026lt;tab\u0026gt; :s/^/\\t\u0026lt;CR\u0026gt;map \u0026lt;S-tab\u0026gt; :s/^\\t/\u0026lt;CR\u0026gt;\u0026#34; 如果要從系統剪貼簿貼上多行程式碼，建議這樣用，才不會被 vim 的自動縮排雷到（你試試就知道是什麼問題，很討厭）nmap \u0026lt;F3\u0026gt; :r! cat\u0026lt;CR\u0026gt;\u0026#34; 切換行號，在複製到系統鍵貼簿時很好用，這樣就不會複製到行號nmap \u0026lt;F7\u0026gt; :set invnumber\u0026lt;CR\u0026gt;\u0026#34; 清除搜尋結果的語法突顯nmap cs :noh\u0026lt;CR\u0026gt;\u0026#34; alias\u0026#34; 冒號命令的別名，語法等等會講\u0026#34; 常用就知道為什麼要設這個（按冒號時要按 \u0026lt;shift\u0026gt;，然後下一個字就很常變大寫，簡稱手殘）command W wcommand Q qcommand Wq wqcommand WQ wq\u0026#34; fix bg color error in Pmenu\u0026#34; 這個只是顯示問題，有時候背景色和前景色一樣你就看不到字了，所以要自己把他換掉，語法等等會講\u0026#34; https://vi.stackexchange.com/questions/23328/change-color-of-coc-suggestion-boxhi Pmenu ctermbg=black ctermfg=whitehi Ignore ctermbg=black ctermfg=lightbluecommand 我們從最簡單的命令別名講起，這個命令可以縮寫成 com\n這個命令可以定義 「使用者自訂命令」\n使用者自訂命令一定要是大寫開頭\n列出命令 :verbose com [cmd] 這個可以列出符合 [cmd] 的使用者自訂命令，還有最後定義的位置\n定義新的使用者自訂命令 :commmand {cmd} {rep} 這個會設定 {cmd} 的別名 {rep}\nautocmd autocmd 是在某種類型的檔案載入時自動執行命令用的，可以縮寫成 au\nau 的使用場景通常是某個類型的語法突顯會出問題、想要根據檔案類型套用不同設定，簡單的語法如下\nau [條件] [...命令]\n條件通常長這樣， FileType javascript\n命令就是冒號命令除了冒號的部份\nmap map 的功能是定義不是冒號開頭的命令（像是 dd 這種，在前幾篇文章中稱為快捷鍵），map 又根據作用的模式分為 nmap、vmap、imap 等等非常多種（:help map 會列出所有 map ）。其中最常用的是 map、nmap、imap，這三個分別代表在「除了編輯模式中作用」、「命令模式（ n ）作用」、「在編輯模式作用（ i ）」。\n各種 map 用法都一樣，差別只在作用模式不同\n列出 map :map:nmap:imap定義 map map {快捷鍵} {命令}\n{快捷鍵} 是 vim 的按鍵組合，其中 imap 用的大多都要加 或是 ，否則會沒用 {命令} 是 vim 的命令，注意這裡講的是「廣義的命令」，也就是包括冒號和非冒號命令，所以如果是冒號命令你必須加上冒號和 enter 鍵才會執行\nps: map 給我的感覺有點像「當你按下 {快捷鍵} 時，vim 會自動幫你打 {命令}\n快捷鍵 快捷鍵可以是不只一個按鍵，可以像是以下幾個範例\n\u0026lt;leader\u0026gt;f \u0026lt;C-y\u0026gt;k ggk 如果一個按鍵可以打出來，像是a、b、c、0、1、2、+、=，就不用角括號 \u0026lt;\u0026gt;\n如果是控制按鍵或是和控制按鍵一起按，就要加上括號，例如 \u0026lt;C-y\u0026gt;、\u0026lt;leader\u0026gt;，其中是指 是反斜線 更多這種按鍵的說明可以參考 :help key-notation\n命令 這邊的命令因為是廣義的命令，所以如果你想要幫某個快捷鍵加上別名也是可以的\nnmap copy yynmap paste p嗯\u0026hellip;\u0026hellip;這可能只在快捷鍵很常出現但是複雜時比較好用\n扯遠了，回到正題。如果你的命令是冒號命令的話，你必須要加上冒號和 enter，不然你在打完快捷鍵之後還要自己按 enter，所以記的在命令最後面加上 \u0026lt;CR\u0026gt; ，這個代表的是 enter 鍵，也可以\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day13/","summary":"vim 在啟動時，都會去執行你的設定檔，這個檔案根據你的 vim 軟體不同而改變，如果是一般的 vim，那他會去讀 ~/.vimrc，如果是 neovim(nvim)，他會去找 ~/.config/nvim/init.vim。在接下來的文章中都以 vimrc 代指。\nvimrc 內容是 vimscript，也就是所有的冒號命令去掉冒號之後的內容，例如有個命令是 :set nu，這個命令可以開啟行號顯示，如果要寫在 vimrc 裡面，就要寫成 set nu。\nvimrc 通常我們會在 vimrc 中設定關於 vim 的外觀、行為、載入外掛等等，接下來是我用多年的 vimrc 的內容，我會一個一個用註解解說他們的用處(雙引號 \u0026quot; 開頭是 vimscript 的註解)\n\u0026#34; 打開語法突顯syntax on\u0026#34; load plguin\u0026#34; install vim-plug:\u0026#34; sh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs \\\u0026#34; https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39;\u0026#34; 這個是明天的東西，先註解掉，才不會出錯\u0026#34; so ~/.config/nvim/plugin.vim\u0026#34; 256 色set t_Co=256\u0026#34; 解決和 tmux 衝突，https://vi.stackexchange.com/questions/238/tmux-is-changing-part-of-the-background-in-vimset t_ut=\u0026#34; 選一個你喜歡的 colorschema\u0026#34; available color schema\u0026#34; blue darkblue default delek desert elflord evening industry koehler\u0026#34; morning murphy pablo peachpuff ron shine slate torte zellnercolorscheme koehler\u0026#34; 雜項設定，詳細解說請用 `:help \u0026lt;opeion\u0026gt;`，例如 `:help showcmd`set showcmdset nuset tabstop=4set shiftwidth=4set autoindentset nowrapset incsearchset autoindentset cindentset smartindentset cursorline\u0026#34; make lightline work in single screen\u0026#34; https://github.","title":"Day 13：vim 設定檔"},{"content":"俗話說人要衣裝，佛要金裝，我們的 vim 也得要有漂亮的外觀。今天就讓我們來看看如何調教調整 vim 的外觀吧！\nHighlight group highlight group（以下簡稱 hg ）是 vim 中的一個概念，他會對應到 vim 畫面中的一段區塊，可能是一段文字，也可能是底下的 status bar 或是左側的行號。每一個 hg 都可以設定樣式，包括前景色、背景色、反白、加底線等等，你可以用 :so $VIMRUNTIME/syntax/hitest.vim 命令查看所有的 hg 名字，他們的樣式也會直接顯示出來。\n如果想看某個 hg 的說明的話（必須是內建的才有），可以用 :help hl-hgName 來查詢說明，例如 CursorLine 就可以用 :help hl-CursorLine 來看說明\nHighlight 用 :highlight 或是縮寫 :hi 可以設定特定 hg 的樣式\nhi hgName arg=value arg=value......hgName 就是你用 :so $VIMRUNTIME/syntax/hitest.vim 查出來的名字，而 arg 常見的有前景色 ctermfg、背景色 ctermbg 和 樣式 cterm\nColor ctermbg 和 ctermfg 後面接的值會根據你的終端機支援的顏色不同而有變化，其中 8 色和 16 色的終端機都可以用 0 ~ 8 / 0 ~ 16 這樣的方式來表示顏色（數字代表的顏色要看終端機設定），vim help 提供了一個對照表可以參考各個數字代表的顏色\nNR-16 NR-8 COLOR NAME ~ 0\t0\tBlack 1\t4\tDarkBlue 2\t2\tDarkGreen 3\t6\tDarkCyan 4\t1\tDarkRed 5\t5\tDarkMagenta 6\t3\tBrown, DarkYellow 7\t7\tLightGray, LightGrey, Gray, Grey 8\t0*\tDarkGray, DarkGrey 9\t4*\tBlue, LightBlue 10\t2*\tGreen, LightGreen 11\t6*\tCyan, LightCyan 12\t1*\tRed, LightRed 13\t5*\tMagenta, LightMagenta 14\t3*\tYellow, LightYellow 15\t7*\tWhite 第一欄是 16 色，第二欄是 8 色，第三欄是顏色名字，你也可以不用數字用顏色名字（不分大小寫）\n如果你的終端機支援 256 色（通常現在的終端機都會有），那就更好玩了，因為你可以用這麼多種顏色！\n        256 色表（填的是前面的數字（0-255）不是 hex 色碼    cterm 通常文字不會只有顏色，還可以有加粗、底線等等樣式，vim 總共提供了這些樣式\n   樣式名稱 說明     bold 粗體   underline 底線   undercurl 捲捲的底線，如果你的終端機不支援的話會改用底線代替   reverse 反白   inverse 反白   italic 斜體（要字型有支援）   standout 翻譯是「突出」，但是我用起來和 reverse、inverse 效果一樣，有人知道差在哪嗎？   strikethrough 翻譯是「刪除線」但是我試不出來，也許是字體的關係   NONE 清除樣式設定    如果你需要多種樣式混合，例如底線 + 反白，你可以用逗號 , 來串起多的樣式，cterm=underline,reverse，注意不能有空白，不然會跳錯誤。\n有了這些，你就可以自訂 vim 中任何一個部份的樣式了，例如 hg CursorLine 代表的是游標所在行，我可以用以下命令改變他的樣式\n:hi CursorLine ctermbg=240 ctermfg=195        自訂的游標行    colorschema 所謂的 colorschema 其實就是一堆的 hi 指令寫在一個檔案裡面，然後給他一個名字，vim 內建了很多 colorschema，放在 $VIMRUNTIME/colors 目錄下。你可以用命令 :echo $VIMRUNTIME 來取得 $VIMRUNTIME 的值，因為系統環境變數可能不會有他（我的就沒有）。 除了去網路上下載別人設計好的 colorschema， 你也可以參考 $VIMRUNTIME/colors 下的檔案形式來製作自己的 colorschema，或是 Google 搜尋 vim colorschemes generator 就可以在網路上找到很多方便你製作 colorschemes 的工具\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day12/","summary":"俗話說人要衣裝，佛要金裝，我們的 vim 也得要有漂亮的外觀。今天就讓我們來看看如何調教調整 vim 的外觀吧！\nHighlight group highlight group（以下簡稱 hg ）是 vim 中的一個概念，他會對應到 vim 畫面中的一段區塊，可能是一段文字，也可能是底下的 status bar 或是左側的行號。每一個 hg 都可以設定樣式，包括前景色、背景色、反白、加底線等等，你可以用 :so $VIMRUNTIME/syntax/hitest.vim 命令查看所有的 hg 名字，他們的樣式也會直接顯示出來。\n如果想看某個 hg 的說明的話（必須是內建的才有），可以用 :help hl-hgName 來查詢說明，例如 CursorLine 就可以用 :help hl-CursorLine 來看說明\nHighlight 用 :highlight 或是縮寫 :hi 可以設定特定 hg 的樣式\nhi hgName arg=value arg=value......hgName 就是你用 :so $VIMRUNTIME/syntax/hitest.vim 查出來的名字，而 arg 常見的有前景色 ctermfg、背景色 ctermbg 和 樣式 cterm\nColor ctermbg 和 ctermfg 後面接的值會根據你的終端機支援的顏色不同而有變化，其中 8 色和 16 色的終端機都可以用 0 ~ 8 / 0 ~ 16 這樣的方式來表示顏色（數字代表的顏色要看終端機設定），vim help 提供了一個對照表可以參考各個數字代表的顏色","title":"Day 12：vim 配色方案"},{"content":"昨天體驗了一些快捷鍵和命令，今天要講的是在 vim 中也很常用的搜尋與取代\n搜尋與取代 vim 的搜尋與取代是由命令 s 達成的，命令格式長這樣\n:[範圍修飾字]s/abcd/efgh/[旗標] 其中 abcd 是 正規表達式（regular expression，縮寫 regex，在中國常寫成「正則」），regex 除了在 vim 可以用之外，幾乎所有程式語言都可以用，還有 grep、sed 等 linux 指令也都是使用 regex，關於 regex 的用法在這裡就不多提了，MDN 上有很完整的解釋\n你應該有注意到上面的命令格式裡面除了正規表達式之外還有「範圍修飾字」和「旗標」，這就是接下來這段的重點啦！\n範圍修飾字 這個東西也不只是搜尋與取代可以用，只要你覺得需要限制某個指令的作用範圍都可以用樣的邏輯接下去\n範圍修飾可寫可不寫，如果不寫的話搜尋與取代就只會在游標在的那一行起作用，加上百分比符號 % 代表作用範圍是整份文件，也可以加上行號代表只作用在某一行，如果是兩個行號中間以逗號隔開，代表是作用在這兩個行號之間\n        範圍修飾字範例    範圍選取 剛剛的範例中有出現用行號作範圍選取，其實範圍選取還有一個更簡單的方式 ——「選取模式」。選取模式和編輯模式、命令模式是同等地位的東西，進入選取模式的快捷鍵有下列幾個（一樣要進到命令模式才能進選取模式）    快捷鍵 說明     v 一般選取，以「字」為單位   S-v(大寫 v ) 一般選取，以「行」為單位   C-v 垂直選取，這個比較不常用，但是需要的時候蠻好用的    選取後一樣可以打指令和快捷鍵，但是這些就只會作用在選取的範圍內，常常搭配的有 d（剪下）、y（複製）、:s（搜尋與取代）\n再把一個範圍選取起來後，如果是快捷鍵就直接按，如果是命令的話按下冒號 :，平常只有冒號的命令行會先出現 :'\u0026lt;,'\u0026gt;，這串東東代表的就是這一個範圍的範圍修飾字，不用刪掉，直打指令就可以了\n        選取結合指令與快捷鍵    旗標 旗標這個東西主要是在控制搜尋的行為，例如全部取代、取代前先問一下之類的，多個旗標可以組合，不管順序，下面是幾個可能會用到的旗標    旗標 說明     g 整行搜尋，如果不加的話只會取代第一個   c 在取代前先確認   i 忽略大小寫            旗標範例    結尾 這兩天講的大部份是操作性質的東西，不需要一次全部記起來，用的多了自然會記得，現在只需要先有個印象就可以了。其實 vim 很多操作、快捷鍵都很直覺，不妨自己多試試看加了 Shift、CTRL之後原本的快捷鍵會有什麼變化\nvim 的操作還有很多技巧，如果有興趣不妨去看看 vim 的文件（用命令 :help ）中相關章節（大概是 usr_03~04 左右）的介紹，你會對 vim 有非常全面的認識。雖然文件是英文寫的，但是並沒有太難的單字，大概國中程度就可以看了\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day11/","summary":"昨天體驗了一些快捷鍵和命令，今天要講的是在 vim 中也很常用的搜尋與取代\n搜尋與取代 vim 的搜尋與取代是由命令 s 達成的，命令格式長這樣\n:[範圍修飾字]s/abcd/efgh/[旗標] 其中 abcd 是 正規表達式（regular expression，縮寫 regex，在中國常寫成「正則」），regex 除了在 vim 可以用之外，幾乎所有程式語言都可以用，還有 grep、sed 等 linux 指令也都是使用 regex，關於 regex 的用法在這裡就不多提了，MDN 上有很完整的解釋\n你應該有注意到上面的命令格式裡面除了正規表達式之外還有「範圍修飾字」和「旗標」，這就是接下來這段的重點啦！\n範圍修飾字 這個東西也不只是搜尋與取代可以用，只要你覺得需要限制某個指令的作用範圍都可以用樣的邏輯接下去\n範圍修飾可寫可不寫，如果不寫的話搜尋與取代就只會在游標在的那一行起作用，加上百分比符號 % 代表作用範圍是整份文件，也可以加上行號代表只作用在某一行，如果是兩個行號中間以逗號隔開，代表是作用在這兩個行號之間\n        範圍修飾字範例    範圍選取 剛剛的範例中有出現用行號作範圍選取，其實範圍選取還有一個更簡單的方式 ——「選取模式」。選取模式和編輯模式、命令模式是同等地位的東西，進入選取模式的快捷鍵有下列幾個（一樣要進到命令模式才能進選取模式）    快捷鍵 說明     v 一般選取，以「字」為單位   S-v(大寫 v ) 一般選取，以「行」為單位   C-v 垂直選取，這個比較不常用，但是需要的時候蠻好用的    選取後一樣可以打指令和快捷鍵，但是這些就只會作用在選取的範圍內，常常搭配的有 d（剪下）、y（複製）、:s（搜尋與取代）","title":"Day 11：批次修改！！"},{"content":"前面 9 天都在介紹操作環境，今天終於要進到編輯器啦！我選用的編輯器是 nvim，但是如果你要用 vim 8 也是可以，因為這兩者之間幾乎沒什麼差別，只是你要注意這兩者的設定檔位置不同，目錄需要你自己轉換。唯一不同的點大概是 nvim 內建支援用 lua（一種程式語言）寫外掛，vim 8 只能用 vimscript。關於兩者之間的愛恨情仇請參考這裡，他講的非常詳細\n 接下來的文章可能會出現 vim、nvim 混用，但是他們都是指 neovim，也就是我們用的這個編輯器，不用特別跑去裝兩套軟體\n 安裝 nvim 基本上你的電腦的套件管理器裡面應該都有 nvim 了，但是他的名字可能不是 nvim，例如 apt 就是 neovim，如果你的套件管理器沒有收錄 nvim 或是你不知道該怎麼辦的話，可以看看這個文章 幾乎所有作業系統他都有介紹怎麼安裝了，當然他也有教你如何自己 build。\n操作 vim 的前身—— vi 誕生於幾乎沒有圖形化界面的時候，那時候也沒有滑鼠，所以所有的操作都必須在鍵盤上達成，今天就來認識一些簡單的命令吧！\n離開 vim 為什麼要在還沒進入 vim 之前就教如何離開呢？ 因為幾乎所有初學者都會有這個疑問，要怎麼離開 vim 啦！！ 這邊我提供一個必勝的方法，不論你在 vim 做了什麼操作，ESC狂按個 100 次三到四次，然後輸入 :q!ENTER就會離開了。\n命令模式？編輯模式？ vim 的「模式」也是讓初學者很困擾的東西之一，下面用一張圖來解釋他們的關係\n        vim 模式切換 (From: 高見龍——超簡明 Vim 操作介紹)    通常 Normal Mode 中文是 「命令模式」 ，顧名思義這個模式下你可以打命令，Insert Mode 的中文是 「編輯模式」 ，在這個模式你可以編輯你的檔案。\n 從命令模式切回編輯模式的命令不只 iao這三個，還有很多，但這是最常見的三個，其他的會在之後介紹\n 命令  注意：我的用詞可能和你看到其他文章不太一樣，這裡我的「命令」指的是 vim 中冒號開頭的命令，其他的則被我歸類到「快捷鍵」但是其實對 vim 來說他們都是命令（文件中都是 command ）\n 如果你想打某個 vim 命令，例如說「儲存並離開」，你需要先到 「命令模式」 ，然後按下 :，螢幕下面就會有一行空行，你可以在這裡打命令，也可按上、下瀏覽以前打過的命令。常用的命令有儲存、離開、搜尋與取代、開啟檔案等等，這裡我列出幾個和檔案操作有關的命令\n   命令 說明     :w [filename] 儲存   :q 離開   :q! 強制離開不儲存（如果有更動檔案但只用 :q 的話會跳出錯誤訊息）   :wq 儲存並離開   :e [filename] 開啟某個檔案   :{number} 跳掉第幾行   :! {cmd} 執行 shell 命令    注意第三個和最後一個，雖然都有驚嘆號，但是第三個的驚嘆號在最後面，執行 shell 命令的驚嘆號在最前面。第三個的驚嘆號表示 「強制」 、 「忽略警告」 ，搭配其他命令可以達到以下效果\n   命令 說明     :w [filename] 強制存檔，有時候會遇到檔案在開啟 vim 途中被其他程式修改或是權限問題，用 :w! 可以強制覆蓋   :e [filename] 不管現在這個檔案有沒有修改，直接從硬碟載入另一個檔案    快捷鍵 和 tmux 一樣，vim 也可以把某個按鍵對應到命令，這樣就不用常常打一堆指令了。\n要注意，vim 可以指定快捷鍵生效的模式，所以如果在編輯模式不能用，那可能要切換到指令模式。\n以下的快捷鍵都是在命令模式下用的喔，常用的快捷鍵有\n   快捷鍵 說明     yy 複製一行   dd 剪下一行   x 剪下一個字   p 貼上剪貼簿的內容   v 選取（之後可以複製、剪下）   . 重複執行剛剛執行過的指令   u 回復（ undo ）   \u0026lt;C-r\u0026gt; 重做（ redo，重做 undo 取消的操作，也就是說要先 u 之後才能 r ）   分隔線 接下來的快捷鍵看看就好，你可以用方向鍵解決   h 左移   j 下移   k 上移   l 右移   gg 移至檔案開頭   G 移至檔案結尾   ^ 移至行頭   $ 移至行尾     \u0026lt;C-r\u0026gt; 的意思是 CTRL+r，這是 vim 常見的表示法，以後還會看到\n 結尾 vim 的命令（快捷鍵）其實是個非常高深的學問，我的文章可能沒辦法講的非常詳細，你可以去找其他教學，或是在 vim 中用指令 :help 看官方的教學\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day10/","summary":"前面 9 天都在介紹操作環境，今天終於要進到編輯器啦！我選用的編輯器是 nvim，但是如果你要用 vim 8 也是可以，因為這兩者之間幾乎沒什麼差別，只是你要注意這兩者的設定檔位置不同，目錄需要你自己轉換。唯一不同的點大概是 nvim 內建支援用 lua（一種程式語言）寫外掛，vim 8 只能用 vimscript。關於兩者之間的愛恨情仇請參考這裡，他講的非常詳細\n 接下來的文章可能會出現 vim、nvim 混用，但是他們都是指 neovim，也就是我們用的這個編輯器，不用特別跑去裝兩套軟體\n 安裝 nvim 基本上你的電腦的套件管理器裡面應該都有 nvim 了，但是他的名字可能不是 nvim，例如 apt 就是 neovim，如果你的套件管理器沒有收錄 nvim 或是你不知道該怎麼辦的話，可以看看這個文章 幾乎所有作業系統他都有介紹怎麼安裝了，當然他也有教你如何自己 build。\n操作 vim 的前身—— vi 誕生於幾乎沒有圖形化界面的時候，那時候也沒有滑鼠，所以所有的操作都必須在鍵盤上達成，今天就來認識一些簡單的命令吧！\n離開 vim 為什麼要在還沒進入 vim 之前就教如何離開呢？ 因為幾乎所有初學者都會有這個疑問，要怎麼離開 vim 啦！！ 這邊我提供一個必勝的方法，不論你在 vim 做了什麼操作，ESC狂按個 100 次三到四次，然後輸入 :q!ENTER就會離開了。\n命令模式？編輯模式？ vim 的「模式」也是讓初學者很困擾的東西之一，下面用一張圖來解釋他們的關係\n        vim 模式切換 (From: 高見龍——超簡明 Vim 操作介紹)    通常 Normal Mode 中文是 「命令模式」 ，顧名思義這個模式下你可以打命令，Insert Mode 的中文是 「編輯模式」 ，在這個模式你可以編輯你的檔案。","title":"Day 10：新手殺，誰來教我離開 vim 阿～～"},{"content":"tmux 本身已經是個非常完善的軟體了，因此我只選了一個外掛，tmux-resurrect 這個外掛讓你可以儲存目前的 tmux 版面配置（分頁、螢幕切割、名稱等等），在下次啟動時復原，這個功能在開發專案要切分編輯、編譯、測試版面時很好用，不需要每次開機都重新切版面\n安裝 我們之前已經安裝過 tmp 了，現在我們只需要在 ~/.tmux.conf 中新增一行\n+ set -g @plugin \u0026#39;tmux-plugins/tmux-resurrect\u0026#39; 接下來執行 tmux source ~/.tmux.conf 載入最新的設定檔，再來用快捷鍵 CTRLa+ i安裝\n使用 切好版面後，按 CTRLa+ s（save）儲存目前狀態，除了版面配置，每個 session 的工作路徑也會儲存，vim 開啟的檔案下次開啟有機會會幫你開，但是可能會遇到暫存檔的問題，所以我建議是儲存狀態時把 vim 關掉\n下次要使用時，用 CTRLa+ r（restore）恢復\n更多外掛 在 https://github.com/tmux-plugins/list 有更多外掛，主要內容包括系統資訊顯示、複製貼上、搜尋，我個人覺得沒有重要到須要特別提出來介紹，就不一一介紹\n 更多 tmux 寫完今天的內容後我發現，內容好像有點少，於是就補充了一些 tmux 的東西\n列出所有快捷鍵 tmux 的快捷非常方便，但是有時候真的想不起來某個功能怎麼按，這時候你可以用 tmux list-kyes 或是比較短的 tmux lsk 看看什麼按鍵對應到什麼功能。\n有時候進來看看有什麼方便的快捷鍵自己還不知道也挺好玩的\n滑鼠控制 不知道昨天的各種 tmux 移動、調整大小的快捷鍵有沒有嚇到你。tmux 其實還有提供一個更簡單的操作方式，如果你的終端機有支援滑鼠的話（像是我用的 gnome-terminal 就有提供）你可以在 ~/.tmux.conf 中加上一行\n+ set -g mouse on 然後重新開啟 tmux，這時候你就可以用滑鼠換頁、切換分割畫面、調整大小等等操作，在不同的地方按右鍵還會有不同的功能呦！\n但是要注意，如果打開這個功能，在 vim 裡面就不能用滾輪捲動文件，因為滾輪捲動這個事件被 tmux「劫持」了（除非你在 vim 也開啟滑鼠功能）\n複製 如果你有開啟滑鼠功能的話，你可以快速的操作一個平常不太用的功能——剪貼簿\ntmux 有自己內部的剪貼簿，不和 vim、作業系統共用\n如果你要從終端機複製文字，只需要按住左鍵、拖移、放開，就會自動複製了\n而貼上的快捷鍵是 CTRLa+ ]        複製貼上    這個剪貼簿和 vim 的剪貼簿（到 vim 的章節會介紹）你可以交替使用，在命令模式（NORMAL）時用 vim 就不用切回編輯模式，在編輯模式（INSERT、REPLACE）時用 tmux 可以用用切到命令模式（這裡看不懂沒關係，我們會在講到 vim 剪貼簿時再講一次）\n系統剪貼簿 如果你開啟了滑鼠功能，可是你又想要用系統剪貼簿，你只需要在選取文字時壓著 SHIFT就可以暫時抑制 tmux 的滑鼠功能，把文字複製到系統剪貼簿\n結尾 tmux 是一個功能簡單但是強大的軟體，因此他的外掛明顯比 zsh 少很多（和 vim 相比可以說一個外掛都沒裝 XD），但是有一些延伸自 tmux 的軟體，例如 tmate，堪稱 terminal 中的 teamviewer，而且是免費的！\n明天開始會進入純‧ CLI 整合式開發環境的核心—— nvim，敬請期待\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day09/","summary":"tmux 本身已經是個非常完善的軟體了，因此我只選了一個外掛，tmux-resurrect 這個外掛讓你可以儲存目前的 tmux 版面配置（分頁、螢幕切割、名稱等等），在下次啟動時復原，這個功能在開發專案要切分編輯、編譯、測試版面時很好用，不需要每次開機都重新切版面\n安裝 我們之前已經安裝過 tmp 了，現在我們只需要在 ~/.tmux.conf 中新增一行\n+ set -g @plugin \u0026#39;tmux-plugins/tmux-resurrect\u0026#39; 接下來執行 tmux source ~/.tmux.conf 載入最新的設定檔，再來用快捷鍵 CTRLa+ i安裝\n使用 切好版面後，按 CTRLa+ s（save）儲存目前狀態，除了版面配置，每個 session 的工作路徑也會儲存，vim 開啟的檔案下次開啟有機會會幫你開，但是可能會遇到暫存檔的問題，所以我建議是儲存狀態時把 vim 關掉\n下次要使用時，用 CTRLa+ r（restore）恢復\n更多外掛 在 https://github.com/tmux-plugins/list 有更多外掛，主要內容包括系統資訊顯示、複製貼上、搜尋，我個人覺得沒有重要到須要特別提出來介紹，就不一一介紹\n 更多 tmux 寫完今天的內容後我發現，內容好像有點少，於是就補充了一些 tmux 的東西\n列出所有快捷鍵 tmux 的快捷非常方便，但是有時候真的想不起來某個功能怎麼按，這時候你可以用 tmux list-kyes 或是比較短的 tmux lsk 看看什麼按鍵對應到什麼功能。\n有時候進來看看有什麼方便的快捷鍵自己還不知道也挺好玩的\n滑鼠控制 不知道昨天的各種 tmux 移動、調整大小的快捷鍵有沒有嚇到你。tmux 其實還有提供一個更簡單的操作方式，如果你的終端機有支援滑鼠的話（像是我用的 gnome-terminal 就有提供）你可以在 ~/.tmux.conf 中加上一行\n+ set -g mouse on 然後重新開啟 tmux，這時候你就可以用滑鼠換頁、切換分割畫面、調整大小等等操作，在不同的地方按右鍵還會有不同的功能呦！","title":"Day 09：今天又想不出標題了！tmux plugin 和 mouse mode"},{"content":"tmux 有許多的快捷鍵來控制螢幕，不論是分割、移動都可以輕鬆完成\n分割畫面 垂直分割畫面的快捷鍵是 CTRLa+ %，水平分割的快捷鍵是 CTRLa+ |(pipe，shift + enter 上面那個)。按下去畫面就會以中間分開，兩邊都是獨立的，即使一邊在編譯卡住了，另一邊的編輯器還是可以正常操作的         分割畫面，一邊編輯，一邊編譯，另一邊執行    在分割畫面中移動 現在你畫面分割好了，要怎麼移動呢？非常直覺，往上就是上，往右就是右。CTRLa+ 方向鍵你也可以用 CTRLa+ tab按照順序移動，CTRLa+ SHIFTtab反向移動\n記得，按方向鍵時 CTRL要放開，不然就會變接下來要介紹的快捷鍵\n        在分割畫面中移動    調整分割大小 有時候我們不一定是要分成一半，例如下面五行，上面滿版。這時候你可以用 CTRLa+ CTRL方向鍵調整大小         調整大小    新增分頁 你有沒有發現終端機最下面那行？那個是 tmux 的分頁，用 CTRLa+ c就可以新增一個分頁，新增順序會從 0 開始找空的補上\n範例和分頁移動一起\n分頁移動 在多個分頁中，你可以用 CTRLa+ CTRLa移動到上一次使用的分頁，或是用 CTRLa+ 數字鍵移動到特定 ID 的分頁。\n        新增分頁、在分頁間移動    結論 今天的內容比較偏操作，自己多試試就會熟悉了。掌握 tmux 之後你會發現你根本不需要開一堆終端機視窗，一個就夠用了。\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day08/","summary":"tmux 有許多的快捷鍵來控制螢幕，不論是分割、移動都可以輕鬆完成\n分割畫面 垂直分割畫面的快捷鍵是 CTRLa+ %，水平分割的快捷鍵是 CTRLa+ |(pipe，shift + enter 上面那個)。按下去畫面就會以中間分開，兩邊都是獨立的，即使一邊在編譯卡住了，另一邊的編輯器還是可以正常操作的         分割畫面，一邊編輯，一邊編譯，另一邊執行    在分割畫面中移動 現在你畫面分割好了，要怎麼移動呢？非常直覺，往上就是上，往右就是右。CTRLa+ 方向鍵你也可以用 CTRLa+ tab按照順序移動，CTRLa+ SHIFTtab反向移動\n記得，按方向鍵時 CTRL要放開，不然就會變接下來要介紹的快捷鍵\n        在分割畫面中移動    調整分割大小 有時候我們不一定是要分成一半，例如下面五行，上面滿版。這時候你可以用 CTRLa+ CTRL方向鍵調整大小         調整大小    新增分頁 你有沒有發現終端機最下面那行？那個是 tmux 的分頁，用 CTRLa+ c就可以新增一個分頁，新增順序會從 0 開始找空的補上\n範例和分頁移動一起\n分頁移動 在多個分頁中，你可以用 CTRLa+ CTRLa移動到上一次使用的分頁，或是用 CTRLa+ 數字鍵移動到特定 ID 的分頁。","title":"Day 08：八爪章魚之 tmux 快捷鍵"},{"content":"昨天的結尾提到要整合 tmux 和 zsh 不是在 ~/.zshrc 結尾執行 tmux 這麼簡單，今天就讓我們看看會遇到什麼問題吧！\n直接執行 tmux 在正式開始前，先讓我們看看直接在 ~/.zshrc 後面執行 tmux 會發生什麼錯誤\n        直接執行 tmux    嗯，錯誤訊息說要 unset $TMUX 那我們就照作吧！\n        加上 unset TMUX，嗯，爆炸了！    分析問題 可以看到，如果直接執行 tmux 的話總是會跳出一個錯誤 sessions should be nested with care, unset $TMUX to force，這段訊息告訴我們，不能建立巢狀 tmux，除非將 $TMUX 環境變數移除。欸？我們不是只執行一次 tmux 嗎？為什麼會他說我們建立巢狀 tmux？我們來看看登入之後發生了什麼事：\n 執行 zsh（因為我們的 default shell 是 zsh） zsh 執行 ~/.zshrc，初始化終端機後執行 tmux tmux 開啟了新的 session，執行 default shell ~/.zshrc 又被執行一次，tmux 被執行第二次 如果你沒有 unset TMUX，那 tmux 就會停下來並印出錯誤訊息，你總共得到兩層 tmux\n如果你 unset TMUX，就是告訴 tmux 不管巢狀限制，就會回到第三步，你等越久會得到越多 tmux  看來問題在於 tmux 和 zsh 執行的迴圈停不下來，那我們就在執行 tmux 之前作個條件判斷，$TMUX 為空再執行 tmux 好了\n   ❓ \u0026gt; $TMUX 是什麼     $TMUX 是一個環境變數，是一個由三個部份串起來、以逗號分開的字串，第一部份是 tmux 的 unix socket 路徑，第二部份是 tmux 的 pid，最後是目前 tmux window 的編號（左下角那個數字）。這個環境變數只有在 tmux 裡面的 session 會設定，所以可以當作 tmux 是否啟動的檢查    初步修改 我們在 ~/.zshrc 中執行 tmux 的那行做一些修改\n+ if [[ -z $TMUX ]];then tmux + fi  提示：-z $TMUX 和 $TMUX == \u0026quot;\u0026quot; 效果是一樣的\n 接下來我們看看這樣修改效果如何         先檢查 $TMUX 再執行 tmux    可以看到，巢狀 tmux 的算是問題解決了，但是你會發現離開 tmux 之後還是一個完整的 zsh，但是這時候你已經結束工作了，不需要再一個 shell，你希望關掉 tmux 之後應改關掉終端機視窗的，這又要怎麼辦呢？\n關掉多餘的 zsh  題外話，從這裡開始就是個人龜毛，想要把使用體驗調整到最好\n 這裡介紹一個內建指令 exec，這個指令會把當作的 shell 用後面的執行檔替換掉。例如我們現在的 shell 是 zsh，執行 exec ssh bbsu@ptt.cc 之後，我們的 shell 就會換成 ssh 了。這有什麼好處？簡單來說就是離開這個指令後就會離開終端機，不會再回到原本的 shell。這個效果剛好和我們的需求是一樣的，所以要解決多餘的 zsh，就只需要在 tmux 前面加上 exec\nif [[ -z $TMUX ]];then - tmux + exec tmux fi    ❓ \u0026gt; exec cmd 和 cmd; exit 有什麼不一樣     這兩個寫法都會有一樣的效果 —— 結束 cmd 後離開，但是他們達成的原因不同，詳細敘述在 stackover flow 有相關討論，有興趣可以看看   你有可以用 htop 之類的工具看看 process 的結構，你就會知道 exec 和 exit 差別在哪了    改進 ~/.zshrc 我們回頭看看目前的 shell 啟動流程，你會發現雖然我們不會回到最初的 zsh，但是他卻做了一堆無意義的初始化、外掛載入，我們可以將這段設定納入 if 裡面，需要時才執行，如果只是要啟動 tmux 就不必走一遍設定 plugin 之類的流程，改進後的 ~/.zshrc 大概長這樣\nif [[ -z $$TMUX ]]; then  exec tmux else  # init zsh ...... fi 如此一來載入速度和記憶體用量都會有一咪咪的減少\n選擇性執行 tmux 有時候你可能會不想啟動 tmux，例如 ssh 到遠端主機，在遠端主機上啟動 tmux 而不是在本機上啟動（在本機上啟動的話要開很多 ssh 連線，在遠端啟動只要連線一次），這時候就要有一個機制可以把主機上的 tmux 關掉，回到原本的 shell，達成方法有很多，這裡我介紹一個我覺得最優雅的方法，在 ~/.zshrc 中 tmux 啟動判斷上加上以下條件\n- if [[ -z $TMUX ]]; then + if [[ -z $TMUX ]] \u0026amp;\u0026amp; [[ ! -f $HOME/.notmux ]]; then 這時候 tmux 啟動條件就變成「tmux 還沒啟動」且「~/.notmux 不存在」，在這裡我們把 ~/.notmux 這個檔案當作一個開關，如果這個檔案存在 tmux 就不會啟動。\n如果你想啟動一個沒有 tmux 的終端機，先建立 ~/.notmux 檔案 touch ~/.notmux，然後開啟新的終端機\n結尾 今天的內容比較雜，修改的部份也比較零散，下面是目前 ~/.zshrc 的內容\nif [[ -z $TMUX ]] \u0026amp;\u0026amp; [[ ! -f $HOME/.notmux ]]; then  exec tmux else  source ~/.zplug/init.zsh   # plugins  zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, as:theme, depth:1  zplug \u0026#39;zsh-users/zsh-autosuggestions\u0026#39;  zplug \u0026#39;marlonrichert/zsh-autocomplete\u0026#39;  zplug \u0026#39;hlissner/zsh-autopair\u0026#39;   if ! zplug check --verbose; then  printf \u0026#34;Install? [y/N]: \u0026#34;  if read -q; then  echo; zplug install  fi  fi   zplug load   # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.  # Initialization code that may require console input (password prompts, [y/n]  # confirmations, etc.) must go above this block; everything else may go below.  if [[ -r \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; ]]; then  source \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34;  fi  # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.  [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh   if [[ -z $TMUX ]]; then  tmux  exit  fi fi ","permalink":"https://blog.simba-fs.dev/posts/ithelp/day07/","summary":"昨天的結尾提到要整合 tmux 和 zsh 不是在 ~/.zshrc 結尾執行 tmux 這麼簡單，今天就讓我們看看會遇到什麼問題吧！\n直接執行 tmux 在正式開始前，先讓我們看看直接在 ~/.zshrc 後面執行 tmux 會發生什麼錯誤\n        直接執行 tmux    嗯，錯誤訊息說要 unset $TMUX 那我們就照作吧！\n        加上 unset TMUX，嗯，爆炸了！    分析問題 可以看到，如果直接執行 tmux 的話總是會跳出一個錯誤 sessions should be nested with care, unset $TMUX to force，這段訊息告訴我們，不能建立巢狀 tmux，除非將 $TMUX 環境變數移除。欸？我們不是只執行一次 tmux 嗎？為什麼會他說我們建立巢狀 tmux？我們來看看登入之後發生了什麼事：\n 執行 zsh（因為我們的 default shell 是 zsh） zsh 執行 ~/.","title":"Day 07：整合 tmux 和 zsh"},{"content":"今天起要介紹的是 tmux，這是一個終端機的 session 管理器，什麼是 session 呢？你可以把 session 理解為一個終端機（畫面）和主機 （你的電腦）的連線，tmux 做的事就是把一個終端機切分成多個終端機，白話說就是多開神器啦！這樣你就可以左邊編輯程式、右邊看執行結果（如圖）。而且一切操作都在一個終端機視窗裡面，這意味著即使你在沒有圖形界面的純文字模式（像是 single user mode、ssh 連線）也可以享受如同圖形界面的便利！\n        tmux demo    安裝 debian/ubuntu $ apt install tmux macOS $ brew install tmux 其他 or 自己編譯 其他可以參考 https://github.com/tmux/tmux/wiki/Installing 的說明\nconfig tmux 啟動時會去讀取 ~/.tmux.conf 這個檔案，所以的設定檔都放在這，在這裡，我推薦一個我用很多年的設定檔，點擊這裡下載，或是執行以下命令\ncurl https://gist.githubusercontent.com/simba-fs/e06a1763c1967ce3f4b5ef643db5e0b3/raw/2f28c62d01f419a390bfc0e66a974985bacdefa5/.tmux.conf \u0026gt; ~/.tmux.conf 這個檔案是我從網路上找到的，後來有加一些自己的東西，把檔案下載下來並存到 ~/.tmux.conf 裡面，關於每一行的用途都有用註解標示，主要幾個改變有以下幾點：\n 把前置按鍵（prefix）從 Ctrlb改成 Ctrla(第 16 ~ 19 行，不喜歡的話可以拿掉)，你也可以改成其他按鍵 底部 status bar 變成彩色，不再是單調的綠色 一些快捷鍵綁定  啟動 暫時我們不加入開啟終端機自動啟動 tmux，手動啟動方式是在終端機執行命令\ntmux 這時候你會看到終端機最上面跳出一個錯誤訊息\n~/.tmux/plugins/tpm/tpm\u0026#39; returned 127 這是因為我們還沒裝 tmux 的外掛管理器 tmp (是 tmux plugins mamager，不是最近 win 11 的 tpm 2.0)\ntpm 安裝很簡單，只要一行指令就可以了\n$ git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 要安裝外掛只要在 run '~/.tmux/plugins/tpm/tpm' 之後加上 set -g @plugin \u0026lt;repo\u0026gt; 就行了，在我給的 config 檔中註解有說明 repo 格式\n這時候啟動 tmux 就不會有錯誤了\n預告 今天安裝好了 tmux 和外掛管理 tpm，明天會介紹如何在開啟終端機時自動開啟 tmux，你以為是直接在 ~/.zshrc 中執行 tmux 嗎？嘿嘿嘿，你可以試試就知道為什麼沒這麼簡單了，明天的文章會好好介紹如何完美整合 zsh 和 tmux\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day06/","summary":"今天起要介紹的是 tmux，這是一個終端機的 session 管理器，什麼是 session 呢？你可以把 session 理解為一個終端機（畫面）和主機 （你的電腦）的連線，tmux 做的事就是把一個終端機切分成多個終端機，白話說就是多開神器啦！這樣你就可以左邊編輯程式、右邊看執行結果（如圖）。而且一切操作都在一個終端機視窗裡面，這意味著即使你在沒有圖形界面的純文字模式（像是 single user mode、ssh 連線）也可以享受如同圖形界面的便利！\n        tmux demo    安裝 debian/ubuntu $ apt install tmux macOS $ brew install tmux 其他 or 自己編譯 其他可以參考 https://github.com/tmux/tmux/wiki/Installing 的說明\nconfig tmux 啟動時會去讀取 ~/.tmux.conf 這個檔案，所以的設定檔都放在這，在這裡，我推薦一個我用很多年的設定檔，點擊這裡下載，或是執行以下命令\ncurl https://gist.githubusercontent.com/simba-fs/e06a1763c1967ce3f4b5ef643db5e0b3/raw/2f28c62d01f419a390bfc0e66a974985bacdefa5/.tmux.conf \u0026gt; ~/.tmux.conf 這個檔案是我從網路上找到的，後來有加一些自己的東西，把檔案下載下來並存到 ~/.tmux.conf 裡面，關於每一行的用途都有用註解標示，主要幾個改變有以下幾點：\n 把前置按鍵（prefix）從 Ctrlb改成 Ctrla(第 16 ~ 19 行，不喜歡的話可以拿掉)，你也可以改成其他按鍵 底部 status bar 變成彩色，不再是單調的綠色 一些快捷鍵綁定  啟動 暫時我們不加入開啟終端機自動啟動 tmux，手動啟動方式是在終端機執行命令","title":"Day 06：螢幕切八段！多開神器 tmux"},{"content":"今天會介紹兩個開箱即用（ out of box ）的外掛和簡化指令的 alias\nzsh-autocomplete 在 CLI 下指令時，有時候會忘記選項叫什麼、檔名中的 k 到底是大寫還是小寫，這時候 autocomplete 就很好用，他會幫我們選出接下來可以填的字，像是選項、子命令、檔名等等。\n   ❓ \u0026gt; autocomplete 和 autosuggestion 有什麼不同？會同衝突嗎？     前者是從 completion function 中找建議，後者是從以前下過的指令中找建議，兩者不會衝突    安裝 autocomplete 托 zplug 的福，我們只需要修改 ~/.zshrc 就可以安裝外掛了。在 ~/.zshrc 中新增以下設定\n+ zplug \u0026#39;marlonrichert/zsh-autocomplete\u0026#39; 然後重新開啟終端機並安裝新增的外掛就可以了\n你會發現你現在打指令，下面都會出現一些可能可以選的選項，例如同樣開頭的指令、檔名。\n 在 https://github.com/marlonrichert/zsh-autocomplete 有快捷鍵教學\n 設定  這段是我在寫完第一版後新增了，所以在 純‧ CLI 整合開發環境 是沒有的\n 為了可以爽爽的用 autocomplete，我新增了一些設定，這些放到 ~/.zshrc 裡面隨便一個地方就可以了\n# case sensitive zstyle \u0026#39;:completion:*\u0026#39; matcher-list \u0026#39;\u0026#39; \u0026#39;m:{a-zA-Z}={A-Za-z}\u0026#39; \u0026#39;r:|[._-]=* r:|=*\u0026#39; \u0026#39;l:|=* r:|=*\u0026#39;  # zsh-autocomplete configure # Down arrow: bindkey \u0026#39;\\e[B\u0026#39; down-line-or-select bindkey \u0026#39;\\eOB\u0026#39; down-line-or-select # down-line-or-select: Open completion menu. # down-line-or-history: Cycle to next history line. 這裡新增了「區分大小寫」和「方向鍵選建議」兩個功能\nzsh-autopair 這個簡單但是貼心的功能在這個 IDE 中很常見，我們的當然也不能漏掉他\n一樣修改 ~/.zshrc 就可以安裝了\n+ zplug \u0026#39;hlissner/zsh-autopair\u0026#39; 重新開啟安裝後就可以享受自動括號了！\nalias alias 的語法很簡單，day02 有提到過，我們再複習一次\nalias a=b 關於 alias 有兩點要注意\n 等號 = 左右不能有空白 如果右邊有空白，要用引號 '、\u0026quot; 括起來  alias a=b # O alias c = d # X 接下來會有我精鍊出來必備的 alias，上面的註解是關於這個 alias 解釋\n# 加上 -r 在刪除/複製目錄時才不會跳警告 alias rm=\u0026#39;rm -r\u0026#39; alias cp=\u0026#39;cp -r\u0026#39;  # -h 可以把檔案大小加上適當的單位，比較好讀 # -l 印出除了檔名其他的資訊，ex：權限、大小 # -F、--color 純粹是好看 alias ls=\u0026#39;ls -hlF --color=auto\u0026#39;  # 大推，這個 alias 非常好用（zsh 有類似功能的外掛可以裝，但是我覺得可以用 alias 就用 alias alias ..=\u0026#39;cd ../\u0026#39;  # 把當前目錄下的檔案/目錄以樹狀結構印出來，會把不重要的（.git, node_modules）忽略，後面可以接路徑 alias tree=\u0026#34;tree -alI \u0026#39;node_modules|.git\u0026#39;\u0026#34;  # 加上顏色 alias grep=\u0026#39;grep --color=always\u0026#39;  # 超好用，在當前目錄中所有檔案中找指定字串，用法：grepFind \u0026#39;console.log\u0026#39;，會印出檔案行號，還會把目標字串上色 alias grepFind=\u0026#39;grep --exclude-dir=node_modules -nr . -e\u0026#39;  # 建立巢狀目錄時會一並建立上層目錄，下面解釋 alias mkdir=\u0026#39;mkdir -p\u0026#39; mkdir -p 假設你現在在一個空目錄裡，下以下指令（沒有 alias）\nmkdir src/user 你會得到 mkdir: 無法建立 「src/user」 目錄: 沒有此一檔案或目錄，這是因為 mkdir 找不到 user 的上層目錄 src，這時候加上 -p 就不一樣了，因為 -p 會讓 mkdir 在上層目錄不存在時自動建立，因此 mkdir src/user 就會成功，不會再跳錯誤\n預告 到今天關於 zsh 的介紹就結束了，明天開始會來講講終端機管理神器 tmux\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day05/","summary":"今天會介紹兩個開箱即用（ out of box ）的外掛和簡化指令的 alias\nzsh-autocomplete 在 CLI 下指令時，有時候會忘記選項叫什麼、檔名中的 k 到底是大寫還是小寫，這時候 autocomplete 就很好用，他會幫我們選出接下來可以填的字，像是選項、子命令、檔名等等。\n   ❓ \u0026gt; autocomplete 和 autosuggestion 有什麼不同？會同衝突嗎？     前者是從 completion function 中找建議，後者是從以前下過的指令中找建議，兩者不會衝突    安裝 autocomplete 托 zplug 的福，我們只需要修改 ~/.zshrc 就可以安裝外掛了。在 ~/.zshrc 中新增以下設定\n+ zplug \u0026#39;marlonrichert/zsh-autocomplete\u0026#39; 然後重新開啟終端機並安裝新增的外掛就可以了\n你會發現你現在打指令，下面都會出現一些可能可以選的選項，例如同樣開頭的指令、檔名。\n 在 https://github.com/marlonrichert/zsh-autocomplete 有快捷鍵教學\n 設定  這段是我在寫完第一版後新增了，所以在 純‧ CLI 整合開發環境 是沒有的\n 為了可以爽爽的用 autocomplete，我新增了一些設定，這些放到 ~/.zshrc 裡面隨便一個地方就可以了\n# case sensitive zstyle \u0026#39;:completion:*\u0026#39; matcher-list \u0026#39;\u0026#39; \u0026#39;m:{a-zA-Z}={A-Za-z}\u0026#39; \u0026#39;r:|[.","title":"Day 05：是說，這個選項可以接什麼東西？autocomplete 與 auto-pair"},{"content":"今天的內容會比平常多，但是非常紮實！\n有時候我們在 CLI 操作時遇到很多重複的指令，像是 git add、git commit -m 'ba la ba la' 等等，這些指令可能又長又複雜，一直都是自己打也不是辦法，這時候就該請出 autosuggestions 了\n安裝 autosuggestions 老樣子，安裝外掛只須要修改 ~/.zshrc 就可以了\n# plugins zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, as:theme, depth:1 + zplug \u0026#39;zsh-users/zsh-autosuggestions\u0026#39; 因為 autosuggestions 是外掛，不需要特別寫 tag 了\n[問題]好像有奇怪的字跑出來？ 寫好之後重開終端機，按下 enter你可能會發現跳出了一堆東西，這是因為你開啟了 p10k 的 Instant Prompt Mode，這個雖然會讓你的終端機跑起來比較順（官方說的，我感覺不出來），但是在 zsh 載入完成之前就不能有任何字輸出。\n可是你看看，如果我們新增了一個外掛，zplug 會跳出來問我們是否要安裝，這時後 Instant Prompt Mode 就出來抱怨了。\n這個問題的解決方法直覺上有兩個，一是關掉 Instant Prompt Mode，二是讓 zplug 先不要吵\n關掉 Instant Prompt Mode 關掉 Instant Prompt Mode 很簡單，重新設定一次 p10k 就好了，在設定程式問你是否要開啟 p10k 時選擇 (3) Off，這樣下次安裝外掛就不會有奇怪的警告訊息跳出來了。\n讓 zplug 先閉嘴 如果你覺得 Instant Prompt Mode 很重要，需要保留，那你可能會想到這個方法\n在 ~/.zshrc 中有一行 zplug load，這行會讓 zplug 在 ~/.zshrc 載入時偵測是否要安裝新外掛，把這行拿掉再重新開啟終端機，以後他就不會自動檢查了\n這時候如果你要安裝新外掛，一樣是修改 ~/.zshrc 之後重開終端機，手動下指令 zplug load，zplug 就會開始檢查更新。\n有沒有兼得的方法呢？ 以上兩種方法都是治標不治本，其實 ~/.zshrc 裡面已經有寫解決辦法了，看看 ~/.zshrc 最上面的註解，這是設定 p10k 時如果你有開啟 Instant Prompt Mode 他幫你加的\n# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc. # Initialization code that may require console input (password prompts, [y/n] # confirmations, etc.) must go above this block; everything else may go below. 他說如果載入過程中會有輸出，像是問 y/N 之類的，要放到這段前面\n所以我們只需要把 zplug 搬到最前面就可以了，現在 ~/.zshrc 長這樣\nsource ~/.zplug/init.zsh # plugins zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, as:theme, depth:1 zplug \u0026#39;zsh-users/zsh-autosuggestions\u0026#39; if ! zplug check --verbose; then printf \u0026#34;Install? [y/N]: \u0026#34; if read -q; then echo; zplug install fi fi zplug load # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc. # Initialization code that may require console input (password prompts, [y/n] # confirmations, etc.) must go above this block; everything else may go below. if [[ -r \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; ]]; then source \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; fi # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh. [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh [問題]為什麼按 方向鍵上時會出現和現在指令開頭不同的字 假設你現在打過以下指令\n$ ls /home/purecli $ cat ~/.zshrc $ ls / 這時候你先打 ls，想找到之前 ls 開頭的指令按，按 方向鍵上會出現 cat ~/.zshrc 呢？這是因為現在的 方向鍵上是 zsh 本身的「上一個指令」。\n這個問題需要裝另一個外掛來解決：zsh-users/zsh-history-substring-search\n在 ~/.zshrc 新增一行\n# plugins zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, as:theme, depth:1 zplug \u0026#39;zsh-users/zsh-autosuggestions\u0026#39; + zplug \u0026#39;zsh-users/zsh-history-substring-search\u0026#39; 然後要綁定按鍵，一樣是放在 ~/.zshrc，位置隨便\nbindkey \u0026#34;$terminfo[kcuu1]\u0026#34; history-substring-search-up bindkey \u0026#34;$terminfo[kcud1]\u0026#34; history-substring-search-down 重開終端機後就可以搜尋同樣開頭的指令紀錄了\n[問題]為什麼開新的終端機 autosuggestions 讀不到以前下過得指令？ 這是因為我們的 ~/.zshrc 中沒有設定把 history 存下來，所以 autosuggestions 只能拿到目前這個終端機的紀錄，一關掉紀錄就不見了，autosuggestions 自然找不到。\n要解決也很簡單，讓他把 history 寫進檔案就好了，在 ~/.zshrc 中任意地方新增這兩行\nSAVEHIST=1000 export HISTFILE=~/.zsh_history setopt share_history 這樣 autosuggestions 就可以讀到以前下過的指指令了\n結尾 今天介紹了好用的 autosuggestions 和 zplug 與 p10k 設定衝突的解決方法。\n不的不說 autosuggestions 真是懶人福音，打過的指令不用再打第二次\n明天再介紹兩個外掛後就 zsh 的部份就差不多完結了，緊接著會進入精彩的 tmux\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day04/","summary":"今天的內容會比平常多，但是非常紮實！\n有時候我們在 CLI 操作時遇到很多重複的指令，像是 git add、git commit -m 'ba la ba la' 等等，這些指令可能又長又複雜，一直都是自己打也不是辦法，這時候就該請出 autosuggestions 了\n安裝 autosuggestions 老樣子，安裝外掛只須要修改 ~/.zshrc 就可以了\n# plugins zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, as:theme, depth:1 + zplug \u0026#39;zsh-users/zsh-autosuggestions\u0026#39; 因為 autosuggestions 是外掛，不需要特別寫 tag 了\n[問題]好像有奇怪的字跑出來？ 寫好之後重開終端機，按下 enter你可能會發現跳出了一堆東西，這是因為你開啟了 p10k 的 Instant Prompt Mode，這個雖然會讓你的終端機跑起來比較順（官方說的，我感覺不出來），但是在 zsh 載入完成之前就不能有任何字輸出。\n可是你看看，如果我們新增了一個外掛，zplug 會跳出來問我們是否要安裝，這時後 Instant Prompt Mode 就出來抱怨了。\n這個問題的解決方法直覺上有兩個，一是關掉 Instant Prompt Mode，二是讓 zplug 先不要吵\n關掉 Instant Prompt Mode 關掉 Instant Prompt Mode 很簡單，重新設定一次 p10k 就好了，在設定程式問你是否要開啟 p10k 時選擇 (3) Off，這樣下次安裝外掛就不會有奇怪的警告訊息跳出來了。","title":"Day 04：金魚記憶力太短暫，交給外掛記吧！autosuggestions 與 sugstring-search"},{"content":"昨天裝好外掛管理器了，接下來我們要用 zplug 來裝一些好玩的外掛囉！\np10k p10k 是 powerlevel10k 的縮寫，這是一套 zsh 的 prompt 主題，是我用過設定最簡單效果也很好的，重點是不論有沒有裝特殊字型，他都可以用！\n安裝字型（可跳過） p10k 官方推薦 nerd font，這是一個給開發者的字型集，包括各種程式語言、網路服務的 icon 等等。p10k 官方也有提供修改過專門給 p10k 的字型檔連結裡有各種終端機模擬器的字型安裝教學（英文）。\n其實如果你只想要部份 icon，只要把 ttf 檔放在 ~/.fonts 下就可以了，不需要改終端機字型，他找不到時會去抓（我自己試是可以的，系統 ubuntu 20.04、terminal: gnome-terminal ）\n如果你想要在 CLI 有各種 icon 的話你才需要安裝上述字型，如果不需要可以跳到下一小節\n安裝 p10k p10k 說到底只是一個外掛，所以我們可以透過 zplug 安裝，打開 ~/.zshrc，在 # plugins 那行下面加上以下設定\n# plugins + zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, as:theme, depth:1 關於這段是什麼意思呢，zplug 提供了一張精美的圖來幫助我們理解\n首先，以 zplug 開頭，然後接 github 的 username/reponame，再來可以用 tag 做修飾，例如我們安裝 p10k 時就用了 as:theme 和 depth:1 ，兩個 tag 之間以逗號加上一個以上的空白隔開\n修改好 ~/.zshrc 之後，為了新載入設定，最間單的方式是關掉終端機再打開，這時候他應該會問你要不要安裝 p10k，按 y。接下來 p10k 的設定畫面就會跳出來，我們可以進入下一節了！\n設定 p10k p10k 的設定界面做得很好，按幾個按鍵就結束了，然後你就會得到一個漂亮的 zsh。\n整個設定流程分成三個部份。第一部份是字型確認，他會舉出幾個字給你看，分別是菱形、鎖、debian icon 和 python icon，最後是測試 icon 會不會擠在一起。你就根據他的提示確認你的字型就可以了。\n再來第二部份是設定 prompt，p10k 可以讓你設定幾乎每一個小細節，按照說明把他按完就好了，這裡都憑個人喜好。 最後是一部份是設定，像是要不要啟用 Instant Prompt Mode，要不要使用設定。\n在設定過程中的每一步你都可以按 r重來、q離開。\n   ❓ \u0026gt; 為什麼設定完 p10k 之後進到某些目錄（像是 git ）會一直跳出錯誤     這是因為 zplug 的關係，重開終端機就可以解決了       💡 重新設定     你可以用 p10k configure 指令重新設定，流程都一模一樣            設定過程（樣式設定是參考用）       ❓ \u0026gt; 在終端機下面那行彩色的是什麼     這是 tmux，大概下星期會介紹    ","permalink":"https://blog.simba-fs.dev/posts/ithelp/day03/","summary":"昨天裝好外掛管理器了，接下來我們要用 zplug 來裝一些好玩的外掛囉！\np10k p10k 是 powerlevel10k 的縮寫，這是一套 zsh 的 prompt 主題，是我用過設定最簡單效果也很好的，重點是不論有沒有裝特殊字型，他都可以用！\n安裝字型（可跳過） p10k 官方推薦 nerd font，這是一個給開發者的字型集，包括各種程式語言、網路服務的 icon 等等。p10k 官方也有提供修改過專門給 p10k 的字型檔連結裡有各種終端機模擬器的字型安裝教學（英文）。\n其實如果你只想要部份 icon，只要把 ttf 檔放在 ~/.fonts 下就可以了，不需要改終端機字型，他找不到時會去抓（我自己試是可以的，系統 ubuntu 20.04、terminal: gnome-terminal ）\n如果你想要在 CLI 有各種 icon 的話你才需要安裝上述字型，如果不需要可以跳到下一小節\n安裝 p10k p10k 說到底只是一個外掛，所以我們可以透過 zplug 安裝，打開 ~/.zshrc，在 # plugins 那行下面加上以下設定\n# plugins + zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, as:theme, depth:1 關於這段是什麼意思呢，zplug 提供了一張精美的圖來幫助我們理解\n首先，以 zplug 開頭，然後接 github 的 username/reponame，再來可以用 tag 做修飾，例如我們安裝 p10k 時就用了 as:theme 和 depth:1 ，兩個 tag 之間以逗號加上一個以上的空白隔開","title":"Day 03：轉吧轉吧七彩霓虹燈之 p10k"},{"content":" 今天內容不小心寫太長了 \u0026hellip;\u0026hellip;\n 首先，在介紹其他軟體之前，先來看看與 CLI 操作習習相關的「shell」，我選擇的 shell 是 zsh，zsh 在 bash 的基礎上擴充了很多實用的功能，像是支援更好的自動補全，各式各樣的主題等等。\nzsh 安裝 如果你的作業系統是 debian 系列的話，可以直接用 apt 安裝 apt install zsh。其他的 linux 發行版可以到 這個網頁找找你的發行版\n如果是 mac，理論上你的 shell 應該已經是 zsh 了（ mac 的 shell 從 2019 開始預設是 zsh ），如果不是的話你可以用 homebrew 安裝 brew install zsh。\n如果是 windows 的話，建議你開啟 WSL2 或是找一台有 linux/mac 的電腦\n現在我們可以透過這個指令檢查是否安裝成功\nzsh --version 如果沒有錯誤就是安裝成功了\n   ❓ \u0026gt; 現在用的是什麼 shell？     你可以使用 echo $SHELL 來看你現在使用的 shell 是那一個    更換 shell 如果你之前的 shell 不是 zsh 那就要更換預設 shell，用以下指令可以更換\nchsh -s $(which zsh) 或是 chsh -s $(where zsh) 初次使用 zsh 更換完 shell，重新開啟終端機，你應該會看到類似下面的畫面，我們選擇預設的 (0) 選項就可以了。如果沒有出現這個畫面的話就是預設的 shell 沒有切換成功或是之前你*已經用過 zsh 了。\n        zsh 安裝畫面    zplug 裝好 zsh 後，你會發現他和 bash 或是你原本的 shell 沒什麼差別，甚至更難用，那是因為我們還沒設定。zplug 是一個 zsh 的套件管理器，所有的設定都寫在 .zshrc 裡，因此如果以後要換電腦，只需要搬走 .zshrc 一個檔案，zplug 就會幫你把所有外掛裝起來。\n安裝 zplug 官方建議的安裝方式是使用 installer，執行以下指令\n$ curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh 如果出現 Enjoy zplug! 就是安裝完成了，如果沒有的話可能是版本不對，他會告訴你有什麼沒裝\nzshrc 現在我們要來設定 ~/.zshrc 了，這是 zsh 的設定檔，他其實就是一個 shell script，但是每次啟動 zsh 他會先被執行。\n首先隨便用一個編輯器打開 ~/.zshrc，刪掉裡面所有內容（應改只有一行註解），貼上以下內容\nsource ~/.zplug/init.zsh # plugins if ! zplug check --verbose; then printf \u0026#34;Install? [y/N]: \u0026#34; if read -q; then echo; zplug install fi fi zplug load 第一行是啟動 zplug 第五行開始是檢查是否要更新/安裝套件\n重新開啟終端機，這樣環境才會載入\n基本 shell sript 接下來，我們先來認識一下 shell script，這個東西不僅可以讓你操作更加順暢，也可以幫你實現各種自動化操作。\n命令 一個普通的 shell 通常是以一個命令開頭，例如 ls、cd、mv，這個命令代表的是電腦中一個可執行檔，你可以用 which \u0026lt;cmd\u0026gt; 或 where \u0026lt;cmd\u0026gt; 來看執行檔的路徑。在這個命令後面的東西都是參數，和一般程式不一樣的是，這個參數因為是整個字串交給命令處理，所以通常可以不管順序，，例如 ls -a -l 和 ls -l -a 是一樣的（當然會有例外或是處理的不好的情況，但不多），更棒的是大部分成熟的指令都可以讓這種只有一個字元的「短選項」合起來寫，變成這樣 ls -al。\nPipe 一個複雜的指令不太可能只憑幾個短短的選項運作，例如 grep（搜尋特定字串用的命令） 除了可以在選項指定檔名，也可以過「特殊的方式」傳一串字給他，這個方法就是我們熟悉的 stdin，也就是 scanf、cin 這類函數接受輸入的來源。\n接受 stdin 的方式有兩個，一個是使用者自己打，另一個是接受另一個命令的「輸出」。要接受另一個「輸出」的方式叫做 pipe，顧名思義就是「管線」，他可以把 A 指令的輸出接給 B 指令的輸入。例如以下的命令\n$ ps -ax | grep zsh 先用 ps 指令列出所有的 process，再交給 grep 找出含有字串 zsh 的行。\nRedirect 剛剛講了把輸出轉到另一個命令的輸入，那如果是要寫進檔案裡面呢？是不是個命令叫 write？其實 shell 已經有個東西可以寫檔案了，就是 redirect，直接來看範例\n寫檔 $ ls \u0026gt; ls_output.txt 就這麼簡單，用大於符號 \u0026gt; 就可以把標準輸出（ stdout ）丟到檔案裡面，但是要注意的是這樣寫的話是直接**「覆蓋」，有就是說如果原本 ls_output.txt 有內容，會直接被 ls 指令的輸入覆蓋，如果你想保留，可以用 \u0026gt;\u0026gt; 來「附加」**，這會讓他接在檔案最後面\n讀檔 如果某個指令沒有讀檔案的選項，只接受 stdin，那你也可以用 redirect 將檔案讀進這個命令\n$ wc \u0026lt; .zshrc wc 這個指令會計算輸入的行數/字數/字元數，上面的指令先把 .zshrc 讀出來，再交給 wc 計算字數\n關於其他 pipe 和 redirect 的用法可以參考 這篇文章\n 嗯\u0026hellip;我知道這有點蠢，因為你可以直接在 wc 後面接路徑，這裡只是示範一下\n 環境變數 改變命令行為的方式除了選項外，還有環境變數。環境變數就像 C++ 裡的**「全域變數」，不管是哪個命令（函數）都可以讀、寫**。通常環境變數的功能是設定某個選項，好讓每一次執行時不用加一堆選項（當然這個功能要命令有支援才行），或是儲存某個命令的資訊，像是 $SHELL 紀錄著你現在使用的 shell。\n讀取 讀取環境變數很簡單，只需要加上錢號 $ 就可以了，例如 $PATH（通常環境變數會全大寫，但其實沒有什麼規範）， shell 會在讀到這個的時候用他的值去替代這個字串。例如以下範例\nls $HOME $HOME 的值是你的家目錄路徑，shell 解釋出來的命令就會是 ls /home/username\n如果你想要看這個環境變數的值，可以根據上面的原理，用 echo 命令印輸出來\necho $HOME 寫入 寫入環境變數只有一個要點——不要加空白，用 = 指定環境變數時千萬不要在 = 左右加上空白，看範例\nA=\u0026#39;a string\u0026#39; # O B= \u0026#39;a string\u0026#39; # X C =\u0026#39;a string\u0026#39; # X D = \u0026#39;a string\u0026#39; # X 其實 shell script 中的錢號 $ 還有超多用法，可以參考 這裡\n結尾 今天介紹了 zsh 和外掛管理器 zplug 還有一點點的 shell script，明天開始會用 zplug 裝各種外掛來豐富我們的純‧ CLI 整合式開發環境\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day02/","summary":"今天內容不小心寫太長了 \u0026hellip;\u0026hellip;\n 首先，在介紹其他軟體之前，先來看看與 CLI 操作習習相關的「shell」，我選擇的 shell 是 zsh，zsh 在 bash 的基礎上擴充了很多實用的功能，像是支援更好的自動補全，各式各樣的主題等等。\nzsh 安裝 如果你的作業系統是 debian 系列的話，可以直接用 apt 安裝 apt install zsh。其他的 linux 發行版可以到 這個網頁找找你的發行版\n如果是 mac，理論上你的 shell 應該已經是 zsh 了（ mac 的 shell 從 2019 開始預設是 zsh ），如果不是的話你可以用 homebrew 安裝 brew install zsh。\n如果是 windows 的話，建議你開啟 WSL2 或是找一台有 linux/mac 的電腦\n現在我們可以透過這個指令檢查是否安裝成功\nzsh --version 如果沒有錯誤就是安裝成功了\n   ❓ \u0026gt; 現在用的是什麼 shell？     你可以使用 echo $SHELL 來看你現在使用的 shell 是那一個    更換 shell 如果你之前的 shell 不是 zsh 那就要更換預設 shell，用以下指令可以更換","title":"Day 02 ：zsh 與 shell script"},{"content":"Who Am I 我今年升大一，在此生最長的假期中寫寫文章打發時間。平常喜歡寫寫程式，研究新技術。是個 CLI 忠實擁護者，電腦通常只開瀏覽器和 terminal，terminal 就是我的開發環境。\n慣用網名是 simba-fs、simbafs 或 SimbaFs。\n略懂 nodejs 和一點網頁技術，這一個月開始研究 Golang\n關於這個系列 為什麼寫這個系列 現代化 IDE 提供的各種功能給我們很好的開發體驗，尤其是當程式碼數量逐漸增加時，IDE 可以提供像是自動補全、型態提示等等。當 lsp(language server protocol) 開始流行之後，甚至不太需要查文件就能知道一個未知函數的用法。但是在這一切的方便的背後是犧牲有限的電腦資源換來的。這個時候資源需求少、發展越來越完善的的純文字界面就是解決這個問題的最佳方法了！不僅不會減少該有的語法突顯、自動補全，甚至可以借助 ssh 的力量，在任何裝置上開發（只要支援 ssh 都可以）。但是可惜的是網路上這方面的資源都很零散，於是我想說趁這次參賽將我所學整理起來。這個系列會帶領讀者一步一步建立一個好用、方便的 CLI 開發環境，如果有時間會講一下如何在任何裝置上開發（當然螢幕太小不適合啦）。\n        五種文字編輯器開啟一個約 60 byte 的文字檔所消耗的記憶體（KB)   From https://medium.com/commitlog/why-i-still-use-vim-67afd76b4db6    這個系列在講什麼 以下是預計的寫作進度，中途可能會更改，我也會每天在這裡更新連結\n Day 01: 簡介 Day 02 ~ 05: zsh Day 06 ~ 09: tmux Day 10 ~ 21: nvim Day 22 ~ 26: other tools Day 29 ~ 30: coding everywhere  仙貝先備（軟體） 最重要的，一個支援至少 8 色的、你用的順手的終端機模擬器，最好是可以自行安裝字體的。\n寫作慣例 問題 如果你看到這個\n   ❓ \u0026gt; 這是一個問題     這邊是答案   這是你在閱讀文章時可能會遇到的問題，解答就在問題下面，如果還有其他問題可以留言或是聯絡我都可以    提示    💡 這是一個提示    程式碼區塊 程式碼區塊會長這樣\n// some code 如果你看到有文字被 這種背景 包圍，那代表他是個專業術語、特殊符號、檔名或是路徑，例如 zsh、$、~/.zshrc\n無論是多行的程式碼區塊或是行內程式碼，只要是 $ 開頭的後面整行都是命令，在下命令時不需要打 $，例如\n$ ls *.txt 另外，如果你看到這樣的程式碼區塊\n+ asdf - asdd 代表有一個檔案要修改，從 + 的那行改成 - 的那行，加減號都不用寫進去，檔名會另外說明\n同步更新 除了 IThelp，我也會將這個系列的文章更新在 我的 blog 上\n喔對了，這整個系列我都是在我的純 CLI 環境中寫作的喔！\n","permalink":"https://blog.simba-fs.dev/posts/ithelp/day01/","summary":"Who Am I 我今年升大一，在此生最長的假期中寫寫文章打發時間。平常喜歡寫寫程式，研究新技術。是個 CLI 忠實擁護者，電腦通常只開瀏覽器和 terminal，terminal 就是我的開發環境。\n慣用網名是 simba-fs、simbafs 或 SimbaFs。\n略懂 nodejs 和一點網頁技術，這一個月開始研究 Golang\n關於這個系列 為什麼寫這個系列 現代化 IDE 提供的各種功能給我們很好的開發體驗，尤其是當程式碼數量逐漸增加時，IDE 可以提供像是自動補全、型態提示等等。當 lsp(language server protocol) 開始流行之後，甚至不太需要查文件就能知道一個未知函數的用法。但是在這一切的方便的背後是犧牲有限的電腦資源換來的。這個時候資源需求少、發展越來越完善的的純文字界面就是解決這個問題的最佳方法了！不僅不會減少該有的語法突顯、自動補全，甚至可以借助 ssh 的力量，在任何裝置上開發（只要支援 ssh 都可以）。但是可惜的是網路上這方面的資源都很零散，於是我想說趁這次參賽將我所學整理起來。這個系列會帶領讀者一步一步建立一個好用、方便的 CLI 開發環境，如果有時間會講一下如何在任何裝置上開發（當然螢幕太小不適合啦）。\n        五種文字編輯器開啟一個約 60 byte 的文字檔所消耗的記憶體（KB)   From https://medium.com/commitlog/why-i-still-use-vim-67afd76b4db6    這個系列在講什麼 以下是預計的寫作進度，中途可能會更改，我也會每天在這裡更新連結\n Day 01: 簡介 Day 02 ~ 05: zsh Day 06 ~ 09: tmux Day 10 ~ 21: nvim Day 22 ~ 26: other tools Day 29 ~ 30: coding everywhere  仙貝先備（軟體） 最重要的，一個支援至少 8 色的、你用的順手的終端機模擬器，最好是可以自行安裝字體的。","title":"Day 01：前言，這批很純，快進來吧！"},{"content":"在用 gin 寫伺服器的時候，我發現模板並不會被 go build 打包進執行檔裡面，所以在執行的時候就找不到檔案，當然這個問題可以用字串的形式直接把模板放進 golang 原始碼裡面，但是這樣程式碼一複雜就會不好用，這時候就可以用 golang 的 embed 函式庫把檔案「嵌入」到原始碼裡面。但是問題又來了，嵌入了之後要怎麼把字串變成模板物件呢？\nEmbed  embed 套件是 1.16 新出的功能，所以如果想用的話記得要更新 go 到 1.16 以上\n embed 嵌入檔案的方式是透過特殊格式的註解宣告，直接看官方範例：\npackage main  import ( \t\u0026#34;embed\u0026#34; )  //go:embed hello.txt var s string  //go:embed hello.txt var b []byte  //go:embed hello.txt var f embed.FS  func main() { \tprint(s) \tprint(string(b)) \tdata, _ := f.ReadFile(\u0026#34;hello.txt\u0026#34;) \tprint(string(data)) } 可以看到，embed 可以把檔案讀成三種格式 string、[]byte、embed.FS，前兩者只能讀「一個」檔案，如果你只用這兩個的話引入時要用 _ \u0026quot;embed\u0026quot;。embed.FS 除了可以嵌入多個檔案之外，因為實做了 fs.FS 所以可以使用當作一個檔案系統操作。\nTmeplate No Recursive 最簡單的方法，你可以直接使用\n// go:embed view/* var f embed.FS templ := template.Must(template.New(\u0026#34;\u0026#34;).ParseFS(f, \u0026#34;view/*tmpl\u0026#34;, \u0026#34;view/user/*.tmpl\u0026#34;)) 這個方法有個缺點，像上面這樣有子目錄就要一個一個設定，ParseFS 不會幫你往下尋找\nRecursive 善用 embed.FS，我們可以將資料夾下所有檔案載入成模板\n// go:embed view var Assets embed.FS func loadTemplate() (*template.Template, error) { \tt := template.New(\u0026#34;\u0026#34;) \tfs.WalkDir(Assets, \u0026#34;view\u0026#34;, func(path string, d fs.DirEntry, err error) error { \tif err != nil { \treturn err \t}  \t// exclude directory \tif d.IsDir() { \treturn nil \t}  \t// read file \tfile, err := Assets.ReadFile(path) \tif err != nil { \treturn err \t}  \tname := strings.Replace(path, \u0026#34;view/\u0026#34;, \u0026#34;\u0026#34;, 1) \t_, err = t.New(name).Parse(string(file)) \tif err != nil { \treturn err \t}  \treturn nil \t}) \tfmt.Println(\u0026#34;Loaded templates:\u0026#34;) \tfor _, v := range t.Templates() { \tfmt.Println(\u0026#34; \u0026#34;, v.Name()) \t} \treturn t, nil }  func main(){  templ, err := loadTemplate() \tif err != nil { \tpanic(err) \t} } 這種寫法雖然程式寫的比較多，但是在模板多的時候優勢就顯現出來了，完全不用管有幾層資料夾，反正放在 view 裡面就可以了。\n關於 Template 奇怪的坑 如果仔細看你會發現 html/template 套件有提供一個函數 ParseFS 函數，可以直接傳 FS 物件進去（如 #No-Recursive 的用法），但是因為 ParseFS 在判定 template name 時是用檔名而不是路徑，所以不同資料夾下如果都有檔名一樣的模板，只有最後一個會生效。所以這個只適用沒有子目錄的情形，擴充性不足有點可惜。因此在 #Recursive 中我使用 Assets.ReadFile 把檔案讀進來，再以字串傳進 Parse 就是為了避免這個 bug\n關於 Golang 1.17 的坑 空格 升到 Golang 1.17 之後，原本可以用 // go:embed filename 引入，現在一定要用 //go:embed filename，斜線和 go 中間不能有空白。\n不能用「.」開頭 我不確定這是不是 1.17 的改變，我忘記以前 1.16.5 有沒有試過這個，filename 不能是「.」開頭，也就是說不能寫 ../filename，所以要引入的檔案或目錄一定要放在 go run . 或 go build 執行的目錄下\n參考資料 https://pkg.go.dev/embed\nhttps://pkg.go.dev/io/fs\nhttps://pkg.go.dev/html/template\nhttps://blog.wu-boy.com/2020/12/embedding-files-in-go-1-16/\n","permalink":"https://blog.simba-fs.dev/posts/golang/golang-parse-all-files-in-directory-into-templates/","summary":"在用 gin 寫伺服器的時候，我發現模板並不會被 go build 打包進執行檔裡面，所以在執行的時候就找不到檔案，當然這個問題可以用字串的形式直接把模板放進 golang 原始碼裡面，但是這樣程式碼一複雜就會不好用，這時候就可以用 golang 的 embed 函式庫把檔案「嵌入」到原始碼裡面。但是問題又來了，嵌入了之後要怎麼把字串變成模板物件呢？\nEmbed  embed 套件是 1.16 新出的功能，所以如果想用的話記得要更新 go 到 1.16 以上\n embed 嵌入檔案的方式是透過特殊格式的註解宣告，直接看官方範例：\npackage main  import ( \t\u0026#34;embed\u0026#34; )  //go:embed hello.txt var s string  //go:embed hello.txt var b []byte  //go:embed hello.txt var f embed.FS  func main() { \tprint(s) \tprint(string(b)) \tdata, _ := f.ReadFile(\u0026#34;hello.txt\u0026#34;) \tprint(string(data)) } 可以看到，embed 可以把檔案讀成三種格式 string、[]byte、embed.FS，前兩者只能讀「一個」檔案，如果你只用這兩個的話引入時要用 _ \u0026quot;embed\u0026quot;。embed.","title":"Golang Parse All Files In Directory Into Templates"},{"content":"Gitea 是一個開源的 git 伺服器，他的界面幾乎和 GitHub 一模一樣，但是完全開源而且非常輕，甚至一片樹梅派就可以開伺服器了。Gitea 因為是使用 Golang 編寫的，所以提供各種平台的執行檔。我選擇透過 docker 裝 Gitea 伺服器，但是這樣有一個問題，gitea 伺服器開在 container 內，沒辦法使用標準的 22 port，所以 git clone 就必須加上一個醜醜的數字，像是這樣\ngit clone git@domain:10022:user/repo.git 這個問題 Gitea 官方已經有提供完整的教學了，但是是英文版，我這篇文章是我讀完消化過後的中文版教學\n容器 ssh 穿透 因為 Gitea 的 ssh 是跑在容器裡，我沒辦法讓他和 host 共用 22 port，所以要透過 host 「轉發」連線。\n1. 建立 git 使用者 先在 host 建立一個名叫 git 的使用者，因為這個帳號會被對應到容器內的 git 使用者，所以要有一樣的 UID, GID\nsudo adduser git grep git /etc/passwd 記好 git 的 UID 和 GID\ngit:x:1002:1002:,,,:/home/git:/bin/bash ------^^^^ ^^^^ ------GID UID 2. docker-compose 以下是我的 docker-compose，可以根據不同的需求再修改（像是加入 db）\nversion: \u0026#34;3\u0026#34; services: gitea: container_name: gitea image: gitea/gitea:latest ports: - \u0026#34;10022:22\u0026#34; - \u0026#34;10080:3000\u0026#34; volumes: - \u0026#34;/home/simba/website/gitea/data:/data\u0026#34; - \u0026#34;/home/git/.ssh:/data/git/.ssh\u0026#34; # ssh 連線需要，這樣使用者新增 ssh key 時才會同步到 host 上，使用者才連的進來 restart: \u0026#39;unless-stopped\u0026#39; environment: - USER_UID=1002 - USER_GID=1002 UID 和 GID 記得換成你的，我的和你的不一定一樣\n3. 幫 git 帳號產生 ssh key 要有 ssh key 才能轉發（host 上的 git 要連線到 container 內）\nsudo -u git ssh-keygen -t rsa -b 4096 -C \u0026#34;Gitea Host Key\u0026#34; 4. ssh 轉發 這時候如果你開啟服務，為一個使用者新增 ssh key 你會發現在 host 上 ~git/.ssh/authorized_keys 會多出一行，長的像這樣\ncommand=\u0026#34;/app/gitea/gitea --config=/data/gitea/conf/app.ini serv key-1\u0026#34;,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa AAAA......(ssh key) 這行是 Gitea 新增的，功能是讓新的 ssh 連線(user -\u0026gt; host)進來時執行 /app/gitea/gitea serv 這個指令，但是我們希望他可以執行 ssh 轉發，所以我們可以在 host 的 /app/gitea/ 下新增一個 gitea 執行檔幫我們做 ssh 轉發（這裡不會有 gitea 執行檔，因為是在 host，gitea 本體在 container 內）\n首先新增目錄 sudo mkdir -p /app/gitea\n再來建立檔案 /app/gitea/gitea，內容如下\n#!/bin/sh ssh -p 2222 -o StrictHostKeyChecking=no git@127.0.0.1 \u0026#34;SSH_ORIGINAL_COMMAND=\\\u0026#34;$SSH_ORIGINAL_COMMAND\\\u0026#34; $0$@\u0026#34; 不要忘記給他執行權限 sudo chmod 755 /app/gitea/gitea\n大功告成！ 心得 一開始我沒找到官方的教學，一方面是我想自己試試看，二方面是因為官方文件中英文完全不一樣，看英文版才完整，中文只給兩條指令。\n參考連結 https://docs.gitea.io/en-us/install-with-docker/#ssh-container-passthrough https://asaba.sakuragawa.moe/2018/06/擺脫控制，用-docker-自建-gitea-gogs-線上代碼協作平臺/\n","permalink":"https://blog.simba-fs.dev/posts/linux/server/ssh-on-gitea-with-docker/","summary":"Gitea 是一個開源的 git 伺服器，他的界面幾乎和 GitHub 一模一樣，但是完全開源而且非常輕，甚至一片樹梅派就可以開伺服器了。Gitea 因為是使用 Golang 編寫的，所以提供各種平台的執行檔。我選擇透過 docker 裝 Gitea 伺服器，但是這樣有一個問題，gitea 伺服器開在 container 內，沒辦法使用標準的 22 port，所以 git clone 就必須加上一個醜醜的數字，像是這樣\ngit clone git@domain:10022:user/repo.git 這個問題 Gitea 官方已經有提供完整的教學了，但是是英文版，我這篇文章是我讀完消化過後的中文版教學\n容器 ssh 穿透 因為 Gitea 的 ssh 是跑在容器裡，我沒辦法讓他和 host 共用 22 port，所以要透過 host 「轉發」連線。\n1. 建立 git 使用者 先在 host 建立一個名叫 git 的使用者，因為這個帳號會被對應到容器內的 git 使用者，所以要有一樣的 UID, GID\nsudo adduser git grep git /etc/passwd 記好 git 的 UID 和 GID\ngit:x:1002:1002:,,,:/home/git:/bin/bash ------^^^^ ^^^^ ------GID UID 2.","title":"ssh on gitea with docker"},{"content":"這是一個給經緯度吐地址的 api，甚至路段都會出來，搭配 web geolocation api 蠻不錯的，精確度不錯。可以不知道有沒有 rate limited 的問題，目前看起來連 token 都不用。\n網址 https://api.nlsc.gov.tw/other/TownVillagePointQuery/\n用法 https://api.nlsc.gov.tw/other/TownVillagePointQuery/經度/緯度\n舉例： request GET https://api.nlsc.gov.tw/other/TownVillagePointQuery/121.46278679999999/25.0169826 response \u0026lt;townVillageItem\u0026gt; \t\u0026lt;ctyCode\u0026gt;F\u0026lt;/ctyCode\u0026gt; \t\u0026lt;ctyName\u0026gt;新北市\u0026lt;/ctyName\u0026gt; \t\u0026lt;townCode\u0026gt;F14\u0026lt;/townCode\u0026gt; \t\u0026lt;townName\u0026gt;板橋區\u0026lt;/townName\u0026gt; \t\u0026lt;officeCode\u0026gt;FA\u0026lt;/officeCode\u0026gt; \t\u0026lt;officeName\u0026gt;板橋\u0026lt;/officeName\u0026gt; \t\u0026lt;sectCode\u0026gt;0008\u0026lt;/sectCode\u0026gt; \t\u0026lt;sectName\u0026gt;民權段\u0026lt;/sectName\u0026gt; \t\u0026lt;villageCode\u0026gt;65000010020\u0026lt;/villageCode\u0026gt; \t\u0026lt;villageName\u0026gt;漢生里\u0026lt;/villageName\u0026gt; \u0026lt;/townVillageItem\u0026gt; 參考資料 https://data.gov.tw/dataset/101898\n","permalink":"https://blog.simba-fs.dev/posts/other/taiwan-town-location/","summary":"這是一個給經緯度吐地址的 api，甚至路段都會出來，搭配 web geolocation api 蠻不錯的，精確度不錯。可以不知道有沒有 rate limited 的問題，目前看起來連 token 都不用。\n網址 https://api.nlsc.gov.tw/other/TownVillagePointQuery/\n用法 https://api.nlsc.gov.tw/other/TownVillagePointQuery/經度/緯度\n舉例： request GET https://api.nlsc.gov.tw/other/TownVillagePointQuery/121.46278679999999/25.0169826 response \u0026lt;townVillageItem\u0026gt; \t\u0026lt;ctyCode\u0026gt;F\u0026lt;/ctyCode\u0026gt; \t\u0026lt;ctyName\u0026gt;新北市\u0026lt;/ctyName\u0026gt; \t\u0026lt;townCode\u0026gt;F14\u0026lt;/townCode\u0026gt; \t\u0026lt;townName\u0026gt;板橋區\u0026lt;/townName\u0026gt; \t\u0026lt;officeCode\u0026gt;FA\u0026lt;/officeCode\u0026gt; \t\u0026lt;officeName\u0026gt;板橋\u0026lt;/officeName\u0026gt; \t\u0026lt;sectCode\u0026gt;0008\u0026lt;/sectCode\u0026gt; \t\u0026lt;sectName\u0026gt;民權段\u0026lt;/sectName\u0026gt; \t\u0026lt;villageCode\u0026gt;65000010020\u0026lt;/villageCode\u0026gt; \t\u0026lt;villageName\u0026gt;漢生里\u0026lt;/villageName\u0026gt; \u0026lt;/townVillageItem\u0026gt; 參考資料 https://data.gov.tw/dataset/101898","title":"taiwan-town-location"},{"content":"有沒有一種經驗是某的應用程式手機板操作勉強算順暢，但是一電腦上就炸開，反應慢到靠北、界面又很難用（沒錯 messenger 我正在看著你）。這個時候相信你會和我一樣想把手機畫面投影到電腦上的一個視窗裡面，最好可以互動、可以打字。有人第一個想法是在手機開 VNC 伺服器，但是這個方法有點麻煩，這篇文章介紹的是目前我覺得最佳解決方案。\nSCRCPY 這個軟體支援有線（ USB debug ）、無線（ WIFI ）的連接，還支援螢幕錄影和傳檔案。最重要的是，開在電腦上的視窗可以調整大小，不需要侷限在一個小小的視窗內，你最大可以放大到全螢幕！在某種意義上你獲得了一台和電腦一樣大的手機。\nInstallation 安裝流程意外的簡單，只需要用 apt 就可以安裝了，或是你可以自己 build，稍微看了一下 說明 ，看起來不困難，但是既然 apt 就可以安裝了我們就省一點時間\n$ sudo apt install scrcpy USB debug 首先無論是有線無線都要先打開手機的 USB debug 選項，在開發人員選項裡面，詳細步驟請看 官方文件。\nUSB 如果不介意有一條線插著~~（順便充電）~~的話，投影畫面非常簡單，只有兩個步驟：\n 插上 USB 並且無論跳出什麼都按「同意」「OK」 打開終端機，執行 scrcpy 然後就會有一個視窗跳出來，你現在就可以在電腦上滑手機了！  Wireless 無線的話比較麻煩，首先是必須要可以連線，看是在同一個區域網路或是 VPN、ssh tunnel 都可以。再來是因為連線設定頗麻煩，所以我把相關的步驟寫成一個 script，下載後給予執行權限就可以執行了（當然要安裝 scrcpy ）。有線的方式一樣很簡單，不用加任何選項就可以連接了。\n如果要啟用無線，只需要加上 -w 選項（用預設的 ip 192.168.43.1)\n如果 ip 不是預設的話，可以加上 -i IP 來指定其他的 ip\n加上 -f 可以開啟全螢幕\n參連連結 https://github.com/Genymobile/scrcpy https://developer.android.com/studio/debug/dev-options https://gist.github.com/simba-fs/9132289f63368ad325d6a2ef62be7a20\n","permalink":"https://blog.simba-fs.dev/posts/linux/cast-phone-screen-to-computer/","summary":"有沒有一種經驗是某的應用程式手機板操作勉強算順暢，但是一電腦上就炸開，反應慢到靠北、界面又很難用（沒錯 messenger 我正在看著你）。這個時候相信你會和我一樣想把手機畫面投影到電腦上的一個視窗裡面，最好可以互動、可以打字。有人第一個想法是在手機開 VNC 伺服器，但是這個方法有點麻煩，這篇文章介紹的是目前我覺得最佳解決方案。\nSCRCPY 這個軟體支援有線（ USB debug ）、無線（ WIFI ）的連接，還支援螢幕錄影和傳檔案。最重要的是，開在電腦上的視窗可以調整大小，不需要侷限在一個小小的視窗內，你最大可以放大到全螢幕！在某種意義上你獲得了一台和電腦一樣大的手機。\nInstallation 安裝流程意外的簡單，只需要用 apt 就可以安裝了，或是你可以自己 build，稍微看了一下 說明 ，看起來不困難，但是既然 apt 就可以安裝了我們就省一點時間\n$ sudo apt install scrcpy USB debug 首先無論是有線無線都要先打開手機的 USB debug 選項，在開發人員選項裡面，詳細步驟請看 官方文件。\nUSB 如果不介意有一條線插著~~（順便充電）~~的話，投影畫面非常簡單，只有兩個步驟：\n 插上 USB 並且無論跳出什麼都按「同意」「OK」 打開終端機，執行 scrcpy 然後就會有一個視窗跳出來，你現在就可以在電腦上滑手機了！  Wireless 無線的話比較麻煩，首先是必須要可以連線，看是在同一個區域網路或是 VPN、ssh tunnel 都可以。再來是因為連線設定頗麻煩，所以我把相關的步驟寫成一個 script，下載後給予執行權限就可以執行了（當然要安裝 scrcpy ）。有線的方式一樣很簡單，不用加任何選項就可以連接了。\n如果要啟用無線，只需要加上 -w 選項（用預設的 ip 192.168.43.1)\n如果 ip 不是預設的話，可以加上 -i IP 來指定其他的 ip\n加上 -f 可以開啟全螢幕\n參連連結 https://github.com/Genymobile/scrcpy https://developer.android.com/studio/debug/dev-options https://gist.github.com/simba-fs/9132289f63368ad325d6a2ef62be7a20","title":"Cast Phone Screen to Computer"},{"content":"下載 source code  編輯 ~/.vimrc  Plug \u0026#39;Valloric/YouCompleteMe\u0026#39;接著按下 esc:w | so %載入設定 接著 :PlugInstall下載 source code 存檔離開  編譯  執行 sudo apt install python3-dev build-essential 進入 ~/.vim/plugged/YouCompleteMe 執行 ./install.py --help 並挑選需要的選項 執行 ./install.py \u0026lt;你要的選項\u0026gt;  ","permalink":"https://blog.simba-fs.dev/posts/linux/vim/youcomopleteme-install/","summary":"下載 source code  編輯 ~/.vimrc  Plug \u0026#39;Valloric/YouCompleteMe\u0026#39;接著按下 esc:w | so %載入設定 接著 :PlugInstall下載 source code 存檔離開  編譯  執行 sudo apt install python3-dev build-essential 進入 ~/.vim/plugged/YouCompleteMe 執行 ./install.py --help 並挑選需要的選項 執行 ./install.py \u0026lt;你要的選項\u0026gt;  ","title":"YouComopleteMe install"},{"content":"再換了觸控筆電後，在 firefox 一直有個問題：觸控往下滑會被當成選取，要卷動一定要用右邊的 scroll bar\n解決方案 按照 https://askubuntu.com/questions/853910/ubuntu-16-and-touchscreen-scrolling-in-firefox 的最佳解法，真的加上 MOZ_USE_XINPUT2=1 的環境變數就可以了。\n另外在設定 ~/.local/share/applications/firefox.desktop 的時候要注意有不只一個 Exec，改完如果沒有生效可以重開機看看。\n","permalink":"https://blog.simba-fs.dev/posts/linux/firefox-touch-screen-scroll/","summary":"再換了觸控筆電後，在 firefox 一直有個問題：觸控往下滑會被當成選取，要卷動一定要用右邊的 scroll bar\n解決方案 按照 https://askubuntu.com/questions/853910/ubuntu-16-and-touchscreen-scrolling-in-firefox 的最佳解法，真的加上 MOZ_USE_XINPUT2=1 的環境變數就可以了。\n另外在設定 ~/.local/share/applications/firefox.desktop 的時候要注意有不只一個 Exec，改完如果沒有生效可以重開機看看。","title":"firefox touch screen scroll"},{"content":"val vs var    kotlin JS     val const   var let    a..b    kotlin JS     a..b Array(b-a+1).fill(0).map(i =\u0026gt; i + a)    when kotlin fun main (){ \tval luckyNum = 4 \tval yourNum = (1..6).random() \tval result = when(yourNum){ \tluckyNum -\u0026gt; \u0026#34;You get the lucky num ${luckyNum}\u0026#34; \t1 -\u0026gt; \u0026#34;Sorry, you get 1\u0026#34; \t2 -\u0026gt; \u0026#34;Sorry, you get 2\u0026#34; \t3 -\u0026gt; \u0026#34;Sorry, you get 3\u0026#34; \t4 -\u0026gt; \u0026#34;Sorry, you get 4\u0026#34; \t5 -\u0026gt; \u0026#34;Sorry, you get 5\u0026#34; \t6 -\u0026gt; \u0026#34;Sorry, you get 6\u0026#34; \telse -\u0026gt; \u0026#34;Sorry, you get a number out of 1..6\u0026#34; \t} \tprintln(result) } ","permalink":"https://blog.simba-fs.dev/posts/kotlin/beginning-of-kotlin/","summary":"val vs var    kotlin JS     val const   var let    a..b    kotlin JS     a..b Array(b-a+1).fill(0).map(i =\u0026gt; i + a)    when kotlin fun main (){ \tval luckyNum = 4 \tval yourNum = (1..6).random() \tval result = when(yourNum){ \tluckyNum -\u0026gt; \u0026#34;You get the lucky num ${luckyNum}\u0026#34; \t1 -\u0026gt; \u0026#34;Sorry, you get 1\u0026#34; \t2 -\u0026gt; \u0026#34;Sorry, you get 2\u0026#34; \t3 -\u0026gt; \u0026#34;Sorry, you get 3\u0026#34; \t4 -\u0026gt; \u0026#34;Sorry, you get 4\u0026#34; \t5 -\u0026gt; \u0026#34;Sorry, you get 5\u0026#34; \t6 -\u0026gt; \u0026#34;Sorry, you get 6\u0026#34; \telse -\u0026gt; \u0026#34;Sorry, you get a number out of 1.","title":"beginning of kotlin"},{"content":"師大科技系面試  兩關各十分鐘\n 第一關：  自我介紹 一分鐘補充說明（有利備審、競賽）解決問題的經驗 自由談話時間  第二關：  自我介紹一分鐘 科技系分幾組？差別在哪？你會選哪組？ 我看你的自傳有寫「專案開發」，有例子嗎？ 如果團隊合作時有人擺爛，你會怎麼做？（20秒）  心得 這個系是團體面試，三個教授對三個考生，輪流回答問題，因為我是那組第一個，所以幾乎都是我先回答，教授沒有問什麼很難得問題，另外系主任看起來人很好。\n","permalink":"https://blog.simba-fs.dev/posts/other/college-exam-interview-and-written-test/","summary":"師大科技系面試  兩關各十分鐘\n 第一關：  自我介紹 一分鐘補充說明（有利備審、競賽）解決問題的經驗 自由談話時間  第二關：  自我介紹一分鐘 科技系分幾組？差別在哪？你會選哪組？ 我看你的自傳有寫「專案開發」，有例子嗎？ 如果團隊合作時有人擺爛，你會怎麼做？（20秒）  心得 這個系是團體面試，三個教授對三個考生，輪流回答問題，因為我是那組第一個，所以幾乎都是我先回答，教授沒有問什麼很難得問題，另外系主任看起來人很好。","title":"college-exam-interview-and-written-test"},{"content":"前言 我的無線華和滑鼠和鍵盤都是羅技的，在我的 Ubuntu 筆電上一直都沒有問題。有一次我想改我的鍵盤被配置，但是因為 logitech unifying 沒有 Linux 版，所以我另一個軟體叫 solaar，功能是差不多的。 當我裝好軟體以後，鍵盤滑鼠操作都沒問題，只有插上滑鼠的接收器以後都對跳出一個 permission error 的錯誤視窗。雖然在 solaar 裡面就無法看到我的滑鼠就是了，但是完全不影響使用，所以我就擺在那邊放它爛，反正就是多按一個叉叉。\n嘗試自己解 今天閒閒沒事做剛好來看看這個怎麼解。我一開始想說，把他的 permission 改成和鍵盤一樣就啦！於是我進行了下面的操作\n$ ls /dev/hidraw* 拔下鍵盤的接收器，發現他是 /dev/hidraw4 和 /dev/hidraw5，再插上去。拔下滑鼠接收器，發現他是 /dev/hidraw2。\n並找到鍵盤的權限是 rw-rw----，滑鼠是 rw-------。\n$ chmod 660 /dev/hidraw2 拔下滑鼠接收器，插上。\n沒用。\n我猜這個方法會失敗應該是因為他在我改之前就已經先跳錯誤了，等我改完它右沒有偵測，我就得把它拔下來在插上去，我又會看到錯誤訊息\u0026hellip;\u0026hellip; (looping\n於是我上網找答案\n網路上的解 我 Google ubuntu logitech permission error 第一個就是我要的！\n","permalink":"https://blog.simba-fs.dev/posts/linux/logitech-mouse-permission-error/","summary":"前言 我的無線華和滑鼠和鍵盤都是羅技的，在我的 Ubuntu 筆電上一直都沒有問題。有一次我想改我的鍵盤被配置，但是因為 logitech unifying 沒有 Linux 版，所以我另一個軟體叫 solaar，功能是差不多的。 當我裝好軟體以後，鍵盤滑鼠操作都沒問題，只有插上滑鼠的接收器以後都對跳出一個 permission error 的錯誤視窗。雖然在 solaar 裡面就無法看到我的滑鼠就是了，但是完全不影響使用，所以我就擺在那邊放它爛，反正就是多按一個叉叉。\n嘗試自己解 今天閒閒沒事做剛好來看看這個怎麼解。我一開始想說，把他的 permission 改成和鍵盤一樣就啦！於是我進行了下面的操作\n$ ls /dev/hidraw* 拔下鍵盤的接收器，發現他是 /dev/hidraw4 和 /dev/hidraw5，再插上去。拔下滑鼠接收器，發現他是 /dev/hidraw2。\n並找到鍵盤的權限是 rw-rw----，滑鼠是 rw-------。\n$ chmod 660 /dev/hidraw2 拔下滑鼠接收器，插上。\n沒用。\n我猜這個方法會失敗應該是因為他在我改之前就已經先跳錯誤了，等我改完它右沒有偵測，我就得把它拔下來在插上去，我又會看到錯誤訊息\u0026hellip;\u0026hellip; (looping\n於是我上網找答案\n網路上的解 我 Google ubuntu logitech permission error 第一個就是我要的！","title":"logitech-mouse-permission-error"},{"content":"安裝  去 https://extensions.libreoffice.org/en/extensions/show/code-highlighter 下載最新的外掛 把檔名前面的前綴刪掉，   例如：ea4db15f_codehighlighter.oxt -\u0026gt; codehighlighter.oxt\n 安裝相依性套件  sudo apt install libreoffice-script-provider-python python3-pip sudo pip3 install pygments 安裝外掛   工具 \u0026gt; 擴充套件管理員 \u0026gt; 加入 \u0026gt; 選擇你的檔案\n 使用  插入文字方塊   插入 \u0026gt; 文字方塊\n 貼上程式碼 選擇文字方塊，不是文字（按文字方塊的邊邊） format   工具 \u0026gt; highlight code \u0026gt; 選得語言、style\n 參考資料 Libreoffice extensions issue\n","permalink":"https://blog.simba-fs.dev/posts/linux/libreoffice-code-format-plugin-install/","summary":"安裝  去 https://extensions.libreoffice.org/en/extensions/show/code-highlighter 下載最新的外掛 把檔名前面的前綴刪掉，   例如：ea4db15f_codehighlighter.oxt -\u0026gt; codehighlighter.oxt\n 安裝相依性套件  sudo apt install libreoffice-script-provider-python python3-pip sudo pip3 install pygments 安裝外掛   工具 \u0026gt; 擴充套件管理員 \u0026gt; 加入 \u0026gt; 選擇你的檔案\n 使用  插入文字方塊   插入 \u0026gt; 文字方塊\n 貼上程式碼 選擇文字方塊，不是文字（按文字方塊的邊邊） format   工具 \u0026gt; highlight code \u0026gt; 選得語言、style\n 參考資料 Libreoffice extensions issue","title":"libreoffice-code-format-plugin-install"},{"content":"strapi 是一個 headless CMS (content management system)，透過 web 介面就可以建立一個 api server\nstrapi 什麼是 headless CMS headless CMS 顧名思義是「無頭的 內容管理系統」，意思是沒有前端、只有後端，它就是一個 DB 的 web 界面 + api server。headless CMS 專注於處理 api 的部份，前端的部份一律不關心。這對於前後端分離有很大的幫助，基本上 headless CMS 已經解決了後端 80% 的工作，剩下的就是一些客製化的邏輯，像是登入、特殊的計算等等。\nstrapi 的優點  他的界面完善 支援多種 DB   MySQL \u0026gt;= 5.6\nMariaDB \u0026gt;= 10.1\nPostgreSQL \u0026gt;= 10\nSQLite \u0026gt;= 3\nMongoDB \u0026gt;= 3.6\n 存取權限控制 外掛  quickstart 以下步驟是補充 官網的 quick start\n 安裝\n$ npx create-strapi-app my-project --quickstart; cd my-project\n這是候應該會爆出一個關於 knex 的 dependency 的錯誤，先暫時跳過不理它 解決 dependency 的錯誤\n把 package.json 裡面 dependencies 裡面 knex 的版本中 \u0026lt; 拿掉，然後下 npm update 再 npm start 就可以了 build\n這時候如果你按照官網的教學 npm start 一定會出錯，你要先 npm run build 然後它才不會一直說找不到檔案 建立第一個 user\n接著它應該會自動幫你開啟一個頁面，如果沒有的話可以按這個連結。再來我們要建立使用者，他的密碼要求特別機掰，一定要英數大小寫混合才給過，太短也不行。 建立 collection type\n如果你按照官網的說法，這裡又會讓你很困惑，+ Create new collection type 按鈕到底它ㄇ的在哪？其實只要在開啟伺服器時用 develop mode 開就可以了，這個重要要的東西它又沒寫了，把你的 server 關掉，下 npm run develop 然後再去剛剛的頁面，重新整理就可以看到那個調皮的按鈕了。  再來的內容基本上沒有太多錯誤，希望官方趕快更新文件吧，這個真的害人不淺阿。\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/strapi-quick-start/","summary":"strapi 是一個 headless CMS (content management system)，透過 web 介面就可以建立一個 api server\nstrapi 什麼是 headless CMS headless CMS 顧名思義是「無頭的 內容管理系統」，意思是沒有前端、只有後端，它就是一個 DB 的 web 界面 + api server。headless CMS 專注於處理 api 的部份，前端的部份一律不關心。這對於前後端分離有很大的幫助，基本上 headless CMS 已經解決了後端 80% 的工作，剩下的就是一些客製化的邏輯，像是登入、特殊的計算等等。\nstrapi 的優點  他的界面完善 支援多種 DB   MySQL \u0026gt;= 5.6\nMariaDB \u0026gt;= 10.1\nPostgreSQL \u0026gt;= 10\nSQLite \u0026gt;= 3\nMongoDB \u0026gt;= 3.6\n 存取權限控制 外掛  quickstart 以下步驟是補充 官網的 quick start\n 安裝\n$ npx create-strapi-app my-project --quickstart; cd my-project","title":"strapi-quick-start"},{"content":"node.js VM 模組 VM 是 node.js 的核心模組，提供安全的環境 (沙箱) 來測試不信任的程式碼。\n基本概念 在 VM 模組裡面，有兩個基本的物件，script 和 context。script 是經過「編譯」程式，context 是給在沙箱裡面的程式碼的全域物件 (global) 。沙箱中的程式只能存取透過 context 指定的物件。\n建立 script VM 模組提供 Script 建構子，可以透過他來建立 Script 物件。\nconst vm = require(\u0026#39;vm\u0026#39;);  const script = new vm.Script(\u0026#39;i++\u0026#39;); 也可以用 vm.createScript\nconst vm = require(\u0026#39;vm\u0026#39;);  const script = vm.createScript(\u0026#39;i++\u0026#39;);  vm.Script\nvm.createScript 在 nodejs docs 上我沒有找到，但是我在自己的電腦上 (node v14.15.0) 測試是可以用的\n 建立 context vm 模組沒有提供建立 context 的建構子，我們只能透過 vm.createContext 來建立 context。\n注意 vm.createContext 不是 pure function，除了會回傳 context 以外，還會把傳入的物件變成 context，兩者傳入 vm.isContext 都會回傳 true。\nconst vm = require(\u0026#39;vm\u0026#39;);  const context1 = { i: 0 }; const context2 = vm.createContext(context1);  vm.isContext(context1); // true vm.isContext(context2); // true  // 注意，其實 context1 和 context2 指向同一個物件。 context1 === context2 // true  vm.createContext\nvm.isContext\n 執行 script (預先編譯 Script) 最基本的函式是 script.runInContext，它會把傳入的 context 當作 vm 的全域執行裡面的程式，script 的最後一個表達式的回傳值會被當作這次執行的回傳值。\n下面的範例，會把 context 中的 i 複製一遍後回傳他的值和長度。\nconst vm = require(\u0026#39;vm\u0026#39;);  const script = vm.createScript(\u0026#39;i += i; [i, i.length]\u0026#39;); const context = vm.createContext({i: \u0026#39;node\u0026#39;});  script.runInContext(context); // [ \u0026#39;nodenode\u0026#39;, 8 ] 如果沒有事先準備 context，可以用 script.runInNewContext，直接把還沒 contextify 物件傳進來，這個函式會 自動建立 context。這個參數是可略的，如果沒傳物件進進來的話，context 就會是空物件。\n如果想要讓 script 直接存取全域物件的話，可以用 script.runInThisContext。這個函式不接受 context，因為 context 就是全域 (this) 了。\n   method context     runInContext contextified object   runInNewContext any Object   runInThisContext 不用傳，this    執行 script (沒有預先編譯 Script) 如果你很懶，或是你只是想要一次行的執行這段 code，可以用 vm.runInContext、vm.runInNewContext 和 vm.runInThisContext。用法跟先編譯過再執行一樣，只是其中第一個參數變成還沒編譯過的 code (String)。\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/node-vm/","summary":"node.js VM 模組 VM 是 node.js 的核心模組，提供安全的環境 (沙箱) 來測試不信任的程式碼。\n基本概念 在 VM 模組裡面，有兩個基本的物件，script 和 context。script 是經過「編譯」程式，context 是給在沙箱裡面的程式碼的全域物件 (global) 。沙箱中的程式只能存取透過 context 指定的物件。\n建立 script VM 模組提供 Script 建構子，可以透過他來建立 Script 物件。\nconst vm = require(\u0026#39;vm\u0026#39;);  const script = new vm.Script(\u0026#39;i++\u0026#39;); 也可以用 vm.createScript\nconst vm = require(\u0026#39;vm\u0026#39;);  const script = vm.createScript(\u0026#39;i++\u0026#39;);  vm.Script\nvm.createScript 在 nodejs docs 上我沒有找到，但是我在自己的電腦上 (node v14.15.0) 測試是可以用的\n 建立 context vm 模組沒有提供建立 context 的建構子，我們只能透過 vm.createContext 來建立 context。","title":"node-vm"},{"content":"前情提要 我們社團的短網址服務裡面常常出現一些奇怪的網址，我猜可能是有機器人在刷，所以我想加入 captcha 減少這類問題。我選擇的是 hCaptcha 這套，能不依賴 Google 就盡量不要。\n安裝步驟 申請帳號 先到 hCaptcha 註冊、新增一個網站，複製 sitekey (Sites \u0026gt; site setting) 和 secret key (Settings)，我們等等會用到\n前端  首先引入 script ，在 \u0026lt;head\u0026gt; 加入  \u0026lt;script src=\u0026#34;https://hcaptcha.com/1/api.js\u0026#34; async defer\u0026gt;\u0026lt;/script\u0026gt; 接著在你的 \u0026lt;form\u0026gt; 裡面加入，這邊的 your_site_key 就是剛剛複製的那個。記得 \u0026lt;form\u0026gt; 的 method 要設成 post  \u0026lt;div class=\u0026#34;h-captcha\u0026#34; data-sitekey=\u0026#34;your_site_key\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 後端（node express）   SECRET\n首先，你要把剛剛的 SECRET 給 server 知道，我用的是 dotenv，當然其他的套件也是可以。\n簡而言之，剛剛複製下來的 SECRET 就是用在這裡。\n  驗證 後端我選用的套件是 express-hcaptcha ，它提供一個 middleware 驗證 hcaptcha 的 token。 按照 README.md 的說明，應該是像這樣就可以了，當驗證通過時就會執行第二個 middleware\n  const router = require(\u0026#39;express\u0026#39;).Router(); const captcha = require(\u0026#39;express-hcaptcha\u0026#39;);  const SECRET = process.env.HCAPTCHA_SECRET_KEY;  if(SECRET){  // 這個 route 就是本來接收/處理 form 傳遞資料進來來的 route，只是加一個 captcha.middleware.validate(SECRET)  router.post(\u0026#39;/\u0026#39;, captcha.middleware.validate(SECRET), (req, res, next) =\u0026gt; {  res.json({  message: \u0026#39;verified!\u0026#39;,  hcaptcha: req.hcaptcha  });  }); } module.exports = router;  很不幸的，你會發現不管怎麼試，都驗證都不會通過，因為有一個 README.md 沒寫的 bug\n 解 bug 閱讀 express-hcaptcha 的 source code，你會在 這行 發現它用的是 req.body.token ，但是 hCaptcha 的回傳是在 req.body.h-captcha-token 裡面 \u0026hellip;\u0026hellip;\n有夠蠢的 bug\n所以剛剛的程式碼就需要修改一下 在驗證之前先把 req.body.h-captcha-token 的內容塞進 req.body.token 裡面  const router = require(\u0026#39;express\u0026#39;).Router(); const captcha = require(\u0026#39;express-hcaptcha\u0026#39;);  const SECRET = process.env.HCAPTCHA_SECRET_KEY;  if(SECRET){  router.post(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; {  req.body.token = req.body[\u0026#39;h-captcha-response\u0026#39;];  next();  }, captcha.middleware.validate(SECRET), (req, res, next) =\u0026gt; {  res.json({  message: \u0026#39;verified!\u0026#39;,  hcaptcha: req.hcaptcha  });  }); }  module.exports = router; 結論 看原始碼很重要\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/hcaptcha/","summary":"前情提要 我們社團的短網址服務裡面常常出現一些奇怪的網址，我猜可能是有機器人在刷，所以我想加入 captcha 減少這類問題。我選擇的是 hCaptcha 這套，能不依賴 Google 就盡量不要。\n安裝步驟 申請帳號 先到 hCaptcha 註冊、新增一個網站，複製 sitekey (Sites \u0026gt; site setting) 和 secret key (Settings)，我們等等會用到\n前端  首先引入 script ，在 \u0026lt;head\u0026gt; 加入  \u0026lt;script src=\u0026#34;https://hcaptcha.com/1/api.js\u0026#34; async defer\u0026gt;\u0026lt;/script\u0026gt; 接著在你的 \u0026lt;form\u0026gt; 裡面加入，這邊的 your_site_key 就是剛剛複製的那個。記得 \u0026lt;form\u0026gt; 的 method 要設成 post  \u0026lt;div class=\u0026#34;h-captcha\u0026#34; data-sitekey=\u0026#34;your_site_key\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 後端（node express）   SECRET\n首先，你要把剛剛的 SECRET 給 server 知道，我用的是 dotenv，當然其他的套件也是可以。\n簡而言之，剛剛複製下來的 SECRET 就是用在這裡。\n  驗證 後端我選用的套件是 express-hcaptcha ，它提供一個 middleware 驗證 hcaptcha 的 token。 按照 README.","title":"hCaptcha"},{"content":"錯誤說明 昨天我在 terminal 登入 docker 的時候發現不知道為什麼不能登入，我先透過網頁登入確認過密碼沒有問題，也不是打錯字的關係，但還是不能當入。總是會有類似以下的錯誤訊息。\nError saving credentials: error storing credentials - err: exit status 1, out: `exit status 1: gpg: simbafs: 已跳過: 沒有公鑰 gpg: [stdin]: encryption failed: 沒有公鑰 Password encryption aborted.` 解決方法 經過搜尋之後，我按照 https://github.com/docker/docker-credential-helpers/issues/102#issuecomment-388634452 的方法成功登入了，但是在這之前要先安裝 gpg 和 pass\napt install gnupg2 pass 接下來是我用的指令\napt install gnupg2 wget https://github.com/docker/docker-credential-helpers/releases/download/v0.6.3/docker-credential-pass-v0.6.3-amd64.tar.gz tar xvf docker-credential-pass-v0.6.3-amd64.tar.gz chmod 755 docker-credential-pass sudo mv docker-credential-pass /usr/bin/ ass insert docker-credential-helpers/docker-pass-initialized-check pass insert docker-credential-helpers/docker-pass-initialized-check pass show docker-credential-helpers/docker-pass-initialized-check docker-credential-pass list docker login 參考連結  https://github.com/docker/docker-credential-helpers/issues/102#issuecomment-388634452 https://stackoverflow.com/questions/50151833/cannot-login-to-docker-account/52881198#52881198 https://gist.github.com/dataday/3c267be29e32573829c4781c99ea3395  ","permalink":"https://blog.simba-fs.dev/posts/linux/docker/docker-login-error/","summary":"錯誤說明 昨天我在 terminal 登入 docker 的時候發現不知道為什麼不能登入，我先透過網頁登入確認過密碼沒有問題，也不是打錯字的關係，但還是不能當入。總是會有類似以下的錯誤訊息。\nError saving credentials: error storing credentials - err: exit status 1, out: `exit status 1: gpg: simbafs: 已跳過: 沒有公鑰 gpg: [stdin]: encryption failed: 沒有公鑰 Password encryption aborted.` 解決方法 經過搜尋之後，我按照 https://github.com/docker/docker-credential-helpers/issues/102#issuecomment-388634452 的方法成功登入了，但是在這之前要先安裝 gpg 和 pass\napt install gnupg2 pass 接下來是我用的指令\napt install gnupg2 wget https://github.com/docker/docker-credential-helpers/releases/download/v0.6.3/docker-credential-pass-v0.6.3-amd64.tar.gz tar xvf docker-credential-pass-v0.6.3-amd64.tar.gz chmod 755 docker-credential-pass sudo mv docker-credential-pass /usr/bin/ ass insert docker-credential-helpers/docker-pass-initialized-check pass insert docker-credential-helpers/docker-pass-initialized-check pass show docker-credential-helpers/docker-pass-initialized-check docker-credential-pass list docker login 參考連結  https://github.","title":"docker login error"},{"content":"如何在 docker container 裡連接 ethernet 今天突然有個需求是在一個已經開啟的 container 弄東西，需要網路，但是不知道為什麼一直不上，後來發現是 docker 沒有設定 DNS 的問題，只要在外面輸入兩行指令就可以了\nDOCKER_OPTS=\u0026#34;--dns 8.8.8.8\u0026#34; systemctl restart docker 然後重新啟動 docker\n","permalink":"https://blog.simba-fs.dev/posts/linux/docker/connect-to-ethernet-in-docker-container/","summary":"如何在 docker container 裡連接 ethernet 今天突然有個需求是在一個已經開啟的 container 弄東西，需要網路，但是不知道為什麼一直不上，後來發現是 docker 沒有設定 DNS 的問題，只要在外面輸入兩行指令就可以了\nDOCKER_OPTS=\u0026#34;--dns 8.8.8.8\u0026#34; systemctl restart docker 然後重新啟動 docker","title":"connect to ethernet in docker container"},{"content":"前言 上次提到可以用 Dockerfile 建立 docker image，但我們還有令一個方法可以建立 docker image，那就是 docker commit 指令\n和 Dockerfile 差別 docker commit 有點像是手動版的 Dockerfile，在用 Dockerfile 建構 docker image 的時候，docker build 的工作就像是自動根據 Dockerfile 操作 docker commit。 Dockerfile 比較適合用在自動化交付和部屬，例如說你有一份程式碼，要將他包成 Docker 就很適合用 Dockerfile 自動化操作，因為程式碼會改變，但是包裝的流程基本上都是一樣的。 docker commit 適合用在建構環境，因為會有比較麻煩的操作，如果寫成 Dockerfile 會比較麻煩，當然如果可以的話還是寫成 Dockerfile 會比較好，因為更新的時候會比較方便。 在建構 image 的時候要用哪個方法就看個人取捨了。\ndocker commit 指令 docker commit 可以把運行中的 comtainer 轉成 images，有點類似令存新檔的概念。先來看看參數吧！\n參數 $ docker commit --help Usage:\tdocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]  Create a new image from a container\u0026#39;s changes  Options:  -a, --author string Author (e.g., \u0026#34;John Hannibal Smith \u0026lt;hannibal@a-team.com\u0026gt;\u0026#34;)  -c, --change list Apply Dockerfile instruction to the created image  -m, --message string Commit message  -p, --pause Pause container during commit (default true)    選項 說明     -a 作者的名字   -c 我還沒研究出來有什麼用   -m 訊息   -p 建構時停容器    ","permalink":"https://blog.simba-fs.dev/posts/linux/docker/docker-commit/","summary":"前言 上次提到可以用 Dockerfile 建立 docker image，但我們還有令一個方法可以建立 docker image，那就是 docker commit 指令\n和 Dockerfile 差別 docker commit 有點像是手動版的 Dockerfile，在用 Dockerfile 建構 docker image 的時候，docker build 的工作就像是自動根據 Dockerfile 操作 docker commit。 Dockerfile 比較適合用在自動化交付和部屬，例如說你有一份程式碼，要將他包成 Docker 就很適合用 Dockerfile 自動化操作，因為程式碼會改變，但是包裝的流程基本上都是一樣的。 docker commit 適合用在建構環境，因為會有比較麻煩的操作，如果寫成 Dockerfile 會比較麻煩，當然如果可以的話還是寫成 Dockerfile 會比較好，因為更新的時候會比較方便。 在建構 image 的時候要用哪個方法就看個人取捨了。\ndocker commit 指令 docker commit 可以把運行中的 comtainer 轉成 images，有點類似令存新檔的概念。先來看看參數吧！\n參數 $ docker commit --help Usage:\tdocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]  Create a new image from a container\u0026#39;s changes  Options:  -a, --author string Author (e.","title":"docker commit"},{"content":"今天在某的地方剛好看到一個 bash 的小技巧，當我們要從 1 數到 100 時，通常會用 seq 指令來做，但是如果我們的需求剛剛好是每次遞增（遞減）1 的話，就可以使用 {start..end} 縮寫，下面兩個範例的效果是一樣的：\n# for 迴圈 + seq 的寫法 for i in $(seq 1 1 100); do \techo $i done # 用 {start..end} echo {1..100} 這個技巧也可以用在建立檔案，像這樣：\ntouch user{1..100} ","permalink":"https://blog.simba-fs.dev/posts/linux/bash/bash-number-loop/","summary":"今天在某的地方剛好看到一個 bash 的小技巧，當我們要從 1 數到 100 時，通常會用 seq 指令來做，但是如果我們的需求剛剛好是每次遞增（遞減）1 的話，就可以使用 {start..end} 縮寫，下面兩個範例的效果是一樣的：\n# for 迴圈 + seq 的寫法 for i in $(seq 1 1 100); do \techo $i done # 用 {start..end} echo {1..100} 這個技巧也可以用在建立檔案，像這樣：\ntouch user{1..100} ","title":"bash number loop"},{"content":"需求 今天寫了一個 bash script 幫我管理 mongodb docker，在使用的時候一些子命令，像是 up、down、clean。我希望可以讓 bash 當我自動補齊這些選項。\nbash_completion bash_completion 是一個可以幫我們做程式化補齊的工具，像是 git 就有使用到這個工具，在 commit、push 的時候按 tab 都會顯示出當下我們可以用的東西，像是 git push\u0026lt;tab\u0026gt;\u0026lt;tab\u0026gt; 就會自動補齊 origin 而不是給我們看檔案（bash 預設只會補齊檔案和命令）。我們這次只須要用基本的 complete 就可以了\ncomplete complete 可以幫命令加上簡單的自動完成，其實 bash_completion 也是去呼叫這個命令來達成自動補齊。complete 傻用非常簡單，像下面這樣就可以幫 mongodb 這個命令加上自動補齊\ncomplete -W \u0026#34;up down clean\u0026#34; mongodb -W 選項代表後面是字詞列表，用 -F 後面可以接一個函數，但是這個我沒研究，也許下一個專案就是研究 complete 也說不定。\n","permalink":"https://blog.simba-fs.dev/posts/linux/bash/bash-completion/","summary":"需求 今天寫了一個 bash script 幫我管理 mongodb docker，在使用的時候一些子命令，像是 up、down、clean。我希望可以讓 bash 當我自動補齊這些選項。\nbash_completion bash_completion 是一個可以幫我們做程式化補齊的工具，像是 git 就有使用到這個工具，在 commit、push 的時候按 tab 都會顯示出當下我們可以用的東西，像是 git push\u0026lt;tab\u0026gt;\u0026lt;tab\u0026gt; 就會自動補齊 origin 而不是給我們看檔案（bash 預設只會補齊檔案和命令）。我們這次只須要用基本的 complete 就可以了\ncomplete complete 可以幫命令加上簡單的自動完成，其實 bash_completion 也是去呼叫這個命令來達成自動補齊。complete 傻用非常簡單，像下面這樣就可以幫 mongodb 這個命令加上自動補齊\ncomplete -W \u0026#34;up down clean\u0026#34; mongodb -W 選項代表後面是字詞列表，用 -F 後面可以接一個函數，但是這個我沒研究，也許下一個專案就是研究 complete 也說不定。","title":"bash completion"},{"content":"Mongoose Model 環境設定 這是這次實驗用的 code\nconst mongoose = require(\u0026#39;mongoose\u0026#39;); mongoose.connect(\u0026#39;mongodb://127.0.0.1:27017\u0026#39;, {useNewUrlParser: true, useUnifiedTopology: true}) \t.then(() =\u0026gt; console.log(\u0026#39;Connected to DB\u0026#39;)) \t.catch(e =\u0026gt; console.error(e));  const requiredString = { \ttype: String, \trequired: true } const UserSchema = new mongoose.Schema({ \tusername: requiredString, \tpassword: requiredString });  const UserModel = mongoose.model(\u0026#39;User\u0026#39;, UserSchema); mongo db 用 docker 開一個實驗用的 server\nversion: \u0026#39;3\u0026#39; services: db: image: \u0026#39;mongo\u0026#39; container_name: \u0026#39;aurl-mongodb\u0026#39; volumes: - ./data/mongo:/data/db - ./data/dump:/dump ports: - \u0026#39;27017:27017\u0026#39; 取得原 schema 在一般操作的時候都是用 UserModel 在操作資料庫，當要取得 schema 的時候當然也是從他裡面找最方便，當然也可以把 schema 特別弄出來，但是有點麻煩，以這次的例子說明，原本的 UserSchema 會存在 UserModel.schema.obj 裡。\n真實資料庫結構 在建立 model 後 mongoose 會自動新增一些欄位，例如說 _id 之類的，要取得包含這些欄位的真實 model 結構的話可以在 UserModel.schema.tree 找到\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/mongoose-model/","summary":"Mongoose Model 環境設定 這是這次實驗用的 code\nconst mongoose = require(\u0026#39;mongoose\u0026#39;); mongoose.connect(\u0026#39;mongodb://127.0.0.1:27017\u0026#39;, {useNewUrlParser: true, useUnifiedTopology: true}) \t.then(() =\u0026gt; console.log(\u0026#39;Connected to DB\u0026#39;)) \t.catch(e =\u0026gt; console.error(e));  const requiredString = { \ttype: String, \trequired: true } const UserSchema = new mongoose.Schema({ \tusername: requiredString, \tpassword: requiredString });  const UserModel = mongoose.model(\u0026#39;User\u0026#39;, UserSchema); mongo db 用 docker 開一個實驗用的 server\nversion: \u0026#39;3\u0026#39; services: db: image: \u0026#39;mongo\u0026#39; container_name: \u0026#39;aurl-mongodb\u0026#39; volumes: - .","title":"Mongoose Model"},{"content":"Install apt install docker docker.io docker-compose What is docker Docker 是一個容器化的技術，基本上使用的時候可以把他當成虛擬機，雖然他們的使用的技術完全不一樣。對新手來說，在 Docker 裡面有四個重要的名詞：dockerfile, docker image, docker container, docker-compose。\n dockerfile\n純文字檔，定義建立 docker image 的步驟，有點像是一個 bash shell。通常命名成 Dockerfile ，在 build 的時候會預設用這個，也可以用 -f 來指定其他的檔案。 docker image\n這是透過 docker build 編譯出來的東西。可以想成 docker container 的藍圖，在 docker pull 的時候也是下載 docker image 而不是 dockerfile。基本上 image 裡面已經包括了編譯好的執行檔和基本的環境設定，所以在 docker 外面是不用做他設定的，這也是 docker 的魅力所在。 docker container\n每個 docker image 可以產生很多個 container，也就是執行中的程式。在這裡你已經可以用 docker 來建立各種服務了。這裡也可以想像成虛擬機，用 docker exec -it container_name bash 可以進到 container 裡面(如果裡面有 bash 的話) docker-compose\n一個服務不是一個 container 就可以架起來的，通常需要好幾個 container。這時候如果透過指令啟動也許會有忘記啟動和設定複雜的問題，所以有了這個工具。他透過 yml 設定來啟動服務。值得注意的是在同一個 docker-compose.yml 啟動的 container 會在同一個網路內而和外面隔開，所以如果是 containers 之間的通訊不用把 port 暴露出來，只有開給外面的要 expose。  ","permalink":"https://blog.simba-fs.dev/posts/linux/docker/docker-%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/","summary":"Install apt install docker docker.io docker-compose What is docker Docker 是一個容器化的技術，基本上使用的時候可以把他當成虛擬機，雖然他們的使用的技術完全不一樣。對新手來說，在 Docker 裡面有四個重要的名詞：dockerfile, docker image, docker container, docker-compose。\n dockerfile\n純文字檔，定義建立 docker image 的步驟，有點像是一個 bash shell。通常命名成 Dockerfile ，在 build 的時候會預設用這個，也可以用 -f 來指定其他的檔案。 docker image\n這是透過 docker build 編譯出來的東西。可以想成 docker container 的藍圖，在 docker pull 的時候也是下載 docker image 而不是 dockerfile。基本上 image 裡面已經包括了編譯好的執行檔和基本的環境設定，所以在 docker 外面是不用做他設定的，這也是 docker 的魅力所在。 docker container\n每個 docker image 可以產生很多個 container，也就是執行中的程式。在這裡你已經可以用 docker 來建立各種服務了。這裡也可以想像成虛擬機，用 docker exec -it container_name bash 可以進到 container 裡面(如果裡面有 bash 的話) docker-compose","title":"docker 基礎指令"},{"content":"問題 在 mxlinux 裡面，預設的 init 不是 systmed，這導致如果想用 systemctl 的時候就會跳出錯誤說\nSystem has not been booted with systemd as init system 像是在安裝 mongodb-org 的時候他就要用到 systemctl 然後就會出錯。\n解法 其實 mxlinux 已經幫我們想好解法了，在開機選項時選 Advence \u0026gt; Systemd 就會以 systemd 開機\n","permalink":"https://blog.simba-fs.dev/posts/linux/mxlinux-boot-with-systemd/","summary":"問題 在 mxlinux 裡面，預設的 init 不是 systmed，這導致如果想用 systemctl 的時候就會跳出錯誤說\nSystem has not been booted with systemd as init system 像是在安裝 mongodb-org 的時候他就要用到 systemctl 然後就會出錯。\n解法 其實 mxlinux 已經幫我們想好解法了，在開機選項時選 Advence \u0026gt; Systemd 就會以 systemd 開機","title":"mxlinux boot with systemd"},{"content":"問題 在寫一個專案的時候，有時候會有一些小程式重複在不同的檔案裡用到，這時候我們會把他打包成模組放在 lib/。但是如果資料夾結構有點點複雜的時候， require() 的路徑就會很複雜：\n. ├── index.js ├── lib │ └── random.js └── routes └── page └── signup └── index.js 在 index.js 裡面如果要引入 random.js 就會變成這樣\nconst random = require(\u0026#39;../../lib/random.js\u0026#39;); 爛解法 如果我們想要直接用 require('lib/random') 的話做簡單的方式是上傳 npm，但是這樣稍嫌麻煩，而且別的專案不一定用的到。每一次修改都要上傳 npm 很不方便。\n好解法 在 linux 裡面要把執行檔做成指令有兩個方法\n 放到 /usr/bin 之類的地方 把這個路徑直接加到 PATH 裡面  在 node 裡面也有 path 設定，module.paths，在 require 時會去這個裡面的目路尋找檔案。所以如果要達成上述的功能的話就只要加這行就可以了\nmodule.paths.push(process.cwd()); 這樣就可以直接用 require('lib/random') 引入了\n參考資料 https://github.com/nodejs/node/issues/4223\nhttps://github.com/nodejs/node/issues/1979\nhttps://www.npmjs.com/package/rooty\n^^^\n這個是在 github issue 裡面看到的，沒試過，但是應該也可以用吧？只是我覺得沒有 paths 的解法來的優雅。\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/node-require-from-project-root/","summary":"問題 在寫一個專案的時候，有時候會有一些小程式重複在不同的檔案裡用到，這時候我們會把他打包成模組放在 lib/。但是如果資料夾結構有點點複雜的時候， require() 的路徑就會很複雜：\n. ├── index.js ├── lib │ └── random.js └── routes └── page └── signup └── index.js 在 index.js 裡面如果要引入 random.js 就會變成這樣\nconst random = require(\u0026#39;../../lib/random.js\u0026#39;); 爛解法 如果我們想要直接用 require('lib/random') 的話做簡單的方式是上傳 npm，但是這樣稍嫌麻煩，而且別的專案不一定用的到。每一次修改都要上傳 npm 很不方便。\n好解法 在 linux 裡面要把執行檔做成指令有兩個方法\n 放到 /usr/bin 之類的地方 把這個路徑直接加到 PATH 裡面  在 node 裡面也有 path 設定，module.paths，在 require 時會去這個裡面的目路尋找檔案。所以如果要達成上述的功能的話就只要加這行就可以了\nmodule.paths.push(process.cwd()); 這樣就可以直接用 require('lib/random') 引入了\n參考資料 https://github.com/nodejs/node/issues/4223\nhttps://github.com/nodejs/node/issues/1979\nhttps://www.npmjs.com/package/rooty\n^^^\n這個是在 github issue 裡面看到的，沒試過，但是應該也可以用吧？只是我覺得沒有 paths 的解法來的優雅。","title":"node require from project root"},{"content":"套件 nerdcommenter\n好用的指令 在每次動作前都要按 \u0026lt;leader\u0026gt;，預設是 反斜線 \\\nc\u0026lt;space\u0026gt; 簡單來說就是 toggle 你的註解\ncA 跳到行尾並在行尾加上註解\n","permalink":"https://blog.simba-fs.dev/posts/linux/vim/vim-auto-comment-plugin/","summary":"套件 nerdcommenter\n好用的指令 在每次動作前都要按 \u0026lt;leader\u0026gt;，預設是 反斜線 \\\nc\u0026lt;space\u0026gt; 簡單來說就是 toggle 你的註解\ncA 跳到行尾並在行尾加上註解","title":"vim auto comment plugin"},{"content":"問題 在設定完 GitHub Action 之後，我發現我的文章的更新時間都錯了，會全部變成當天日期。但是本地生成的就沒有這個問題，經過一番盤查和猜測後，我發現問題是因為 git 不會把 modified date 紀錄，因為每台電腦的時區都是不一樣的，紀錄起來沒有意義。但是我們需要這項 meta data，所以我們就要自己想法紀錄\n解法 v1.0 首先，因為每一篇文章 hexo 都會紀錄建立時間，所以我們可以直接把他抓出來，然後把檔案的更新時間設成這個時間就可以啦！\n更改檔案的 modified time 這個功能只要用我們最熟悉的 touch 就可以做到了。一般我們使用 touch 的時候會把 modified time 改成當下時間，那要改任意時間只要加上 -t 選項就可以啦\n-t STAMP use [[CC]YY]MMDDhhmm[.ss] instead of current time 假設我們有個檔案 tmp ，我想把他的日期改成 1999/3/23 12:32:33 ，那我可以這樣下指令\nted timeouch -t\u0026#39;19993231232.33\u0026#39; tmp 抓出檔名、日期 # git create time grep -rnw source/_posts -e \u0026#39;date\u0026#39; output:（這裡的 date: 後面我多加了一個空白，原因後面會說）\nsource/_posts/hexo-installation.md:3:date: 2020-02-10 17:26:45 source/_posts/blessed.md:3:date: 2020-02-17 23:24:10 source/_posts/bash.md:3:date: 2020-02-16 22:15:10 source/_posts/hexo-cli-extras.md:3:date: 2020-02-11 21:26:30 source/_posts/remind-daniel.md:3:date: 2020-03-15 21:35:25 source/_posts/jquery.md:3:date: 2020-03-15 11:38:47 source/_posts/nginx-reverse-proxy-setup.md:3:date: 2020-02-13 10:34:58 source/_posts/nginx-ui.md:3:date: 2020-06-23 22:50:29 source/_posts/reverse-ssh.md:3:date: 2020-02-23 21:24:34 source/_posts/webpack-react.md:3:date: 2020-06-28 22:39:57 source/_posts/mxlinux-change-workspace.md:3:date: 2020-05-08 17:59:22 分離時間，檔名 觀察他的輸出\n檔名的部份是在以冒號分隔的第一欄\n日期/時間是在以空格分隔的第二、三欄 那我們就可以根據這個把他們分離出來\n# get name, time grep -rnw source/_posts -e \u0026#39;date\u0026#39; \u0026gt; t cut -d: -f1 t \u0026gt; name cut -d\u0026#39; \u0026#39; -f2,3 t \u0026gt; time output:（節錄，這邊沒有對的很好） name:\nsource/_posts/sqlite.md source/_posts/ssh-tunnel.md source/_posts/unix-socket.md source/_posts/webpack-react.md source/_posts/youtube-dl.md source/_posts/加入-google-search-和-sitemap.md time:\n2020-02-24 22:14:36 2020-02-23 14:30:22 2020-06-28 22:39:57 2020-03-04 22:48:20 2020-08-19 22:37:52 2020-08-20 23:33:13 處理日期的格式 在 更改檔案的 modified time 提到的日期格式和我們抓出來的不太一樣，所以我們需要做一些處理\ncut -d\u0026#39; \u0026#39; -f2,3 t | sed \u0026#39;s/[- ]//g\u0026#39; | sed \u0026#39;s/://\u0026#39; | sed \u0026#39;s/:/./\u0026#39; \u0026gt; time 這樣就可以成功轉換日期格式了\n時間檔 接下來把 name、time 合起來就變成時間擋了，這裡有一點要注意，因為我們恢復的時候是用 for 迴圈，換行和空白都會被當成切斷符號，所以檔名和時間中間的間隔符號我們選用冒號 :\npaste -d: name time \u0026gt; source/_posts/time 清垃圾 最後記得把剛才產生出來但是用不到的檔案清掉\nrm t name time 完整程式碼 # updateDate.sh #!/bin/bash if [[ -z $1 ]];then  dir=\u0026#34;source/_posts\u0026#34; else  dir=$1 fi  grep \u0026#39;date: [0-9]{4}\u0026#39; $dir/*.md \u0026gt; t cut -d: -f1 t \u0026gt; name cut -d\u0026#39; \u0026#39; -f2,3 t | sed \u0026#39;s/[- ]//g\u0026#39; | sed \u0026#39;s/://\u0026#39; | sed \u0026#39;s/:/./\u0026#39; \u0026gt; time paste -d: name time \u0026gt; $dir/time  for i in $(cat $dir/time);do  n=$(echo $i | cut -d: -f1);  d=$(echo $i | cut -d: -f2);  touch -t$d $n; done  rm t name time 備註 剛剛有說到在這份教學中的 date:  都多加一個空白，原因是因為 grep 在抓時候不會只抓第一個，為了避免抓到錯的所以我故意讓他不匹配，不然再生成時間檔的時候會出錯，所以你們的文章中如果出現會匹配 date: [0-9]{4} 的字串，記得要做一下手腳\n解法 v2.0 上一個作法雖然可行，但是有一個缺點，就是他的更新時間都會是建立時間，不會是 modified time，所以解法二誕生了\n其實很簡單，改上面的一小行就好了。首先用 stat 取出檔案的 modified time\nstat -c %y source/_posts/*.md \u0026gt; time 2020-03-04 22:48:20.000000000 +0800 2020-08-19 22:37:52.000000000 +0800 2020-08-21 22:15:44.366513358 +0800 2020-07-04 10:17:39.000000000 +0800 然後在經過適當的轉換變成我們要的格式就完成啦！\n完整程式碼 # storePostTime.sh #!/bin/bash if [[ -z $1 ]];then  dir=source/_posts else  dir=$1 fi  ls $dir/*.md \u0026gt; name stat -c %y $dir/*.md |\\  cut -d\u0026#39; \u0026#39; -f1,2 |\\  sed \u0026#39;s/[- ]//g\u0026#39; |\\  sed \u0026#39;s/://\u0026#39; |\\  sed \u0026#39;s/:/./\u0026#39; |\\  cut -d. -f1,2 \u0026gt; time paste -d: name time \u0026gt; t mv t $dir/time rm name time # recorverDate.sh #!/bin/bash if [[ -z $1 ]];then  file=\u0026#34;source/_posts/time\u0026#34; else  file=$1 fi for i in $(cat $file);do  n=$(echo $i | cut -d: -f1);  d=$(echo $i | cut -d: -f2);  touch -t$d $n; done ","permalink":"https://blog.simba-fs.dev/posts/nodejs/hexo/%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E6%99%82%E9%96%93%E9%8C%AF%E4%BA%82%E5%95%8F%E9%A1%8C/","summary":"問題 在設定完 GitHub Action 之後，我發現我的文章的更新時間都錯了，會全部變成當天日期。但是本地生成的就沒有這個問題，經過一番盤查和猜測後，我發現問題是因為 git 不會把 modified date 紀錄，因為每台電腦的時區都是不一樣的，紀錄起來沒有意義。但是我們需要這項 meta data，所以我們就要自己想法紀錄\n解法 v1.0 首先，因為每一篇文章 hexo 都會紀錄建立時間，所以我們可以直接把他抓出來，然後把檔案的更新時間設成這個時間就可以啦！\n更改檔案的 modified time 這個功能只要用我們最熟悉的 touch 就可以做到了。一般我們使用 touch 的時候會把 modified time 改成當下時間，那要改任意時間只要加上 -t 選項就可以啦\n-t STAMP use [[CC]YY]MMDDhhmm[.ss] instead of current time 假設我們有個檔案 tmp ，我想把他的日期改成 1999/3/23 12:32:33 ，那我可以這樣下指令\nted timeouch -t\u0026#39;19993231232.33\u0026#39; tmp 抓出檔名、日期 # git create time grep -rnw source/_posts -e \u0026#39;date\u0026#39; output:（這裡的 date: 後面我多加了一個空白，原因後面會說）\nsource/_posts/hexo-installation.md:3:date: 2020-02-10 17:26:45 source/_posts/blessed.md:3:date: 2020-02-17 23:24:10 source/_posts/bash.md:3:date: 2020-02-16 22:15:10 source/_posts/hexo-cli-extras.","title":"文章更新時間錯亂問題"},{"content":"問題 在 express route 裡面，我通常會在 res.send() 之類的函式前面都會加一個 return 防止因為程式邏輯漏洞造成重複送出然後噴 error。像是這樣\nroute.get(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; {  return res.send(\u0026#39;Hello world\u0026#39;); }); 但是如果我們用到 Promise 的時候 return 並不會跳出整個 route，所以我們需要另一個方法，我的想法是一個變數儲存是否送出，然後在每次送出前都判斷，送出候更改變數值\n+--------------------------+ | is sent( flag === false) | +-+------------------------+ |no | +-+----+ | send | +-+----+ | +-+-----------+ | change flag | +-------------+ route.get(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; {  let flag = false;  doSomePromise()  .then(() =\u0026gt; {  // do something  if(!flag){  res.send(\u0026#39;Hello world\u0026#39;);  flag = true;  }  }) }) 這樣就不會噴一堆 error 啦！\n改進版 用了之後發現這樣有點麻煩，express 應該有內建變數儲存是否已送出才對，如果沒有，我應該也有更好的方法可以直接從 req 或 res 的狀態判斷是否已送出。找了一下，真的被我找到了 res.headersSent 這個內建變數，他的行為就和上面的 flag 一模一樣，但是我們不用自己去維護他的狀態。所以上面的範例就可以改寫成這樣\nroute.get(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; {  doSomePromise()  .then(() =\u0026gt; {  // do something  res.headersSent || res.send(\u0026#39;Hello world\u0026#39;);  }) }) ","permalink":"https://blog.simba-fs.dev/posts/nodejs/express-%E9%87%8D%E8%A4%87-send/","summary":"問題 在 express route 裡面，我通常會在 res.send() 之類的函式前面都會加一個 return 防止因為程式邏輯漏洞造成重複送出然後噴 error。像是這樣\nroute.get(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; {  return res.send(\u0026#39;Hello world\u0026#39;); }); 但是如果我們用到 Promise 的時候 return 並不會跳出整個 route，所以我們需要另一個方法，我的想法是一個變數儲存是否送出，然後在每次送出前都判斷，送出候更改變數值\n+--------------------------+ | is sent( flag === false) | +-+------------------------+ |no | +-+----+ | send | +-+----+ | +-+-----------+ | change flag | +-------------+ route.get(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; {  let flag = false;  doSomePromise()  .then(() =\u0026gt; {  // do something  if(!","title":"express 重複 send"},{"content":"前置設定 npm 安裝 hexo-generator-sitemap npm i -S hexo-generator-sitemap 設定插件 將以下內容加到 _config.yml\n 注意空白\n # sitemap sitemap:  path: sitemap.xml 驗證網域 如果你的 hexo 是架在自己的網域可以跳過這步\n因為我的 hexo 是 託管在 GitHub page，在 Google Search Console 驗證的時候沒辦法用網域，所以要放一個特別的檔案到我們的網站根目錄\n 首先到 Google Search Console 新增一個網域 選擇右邊，輸入你的網址  下載提供的 html 並放到 source/ 資料夾  忽略 接下來會遇到 hexo 在生成的時候把這個 html 也放到模板裡面，所以我們要把他加入忽略清單裡面\n在 _config.yml 裡面找到 skip_render\n把直接檔名寫在後面或是用清單都可以   注意空白\n # 直接寫 skip_render: \u0026#39;googlebabababababa.html\u0026#39; # 或是用清單 skip_render:  - \u0026#39;googlebabababababa.html\u0026#39; 按下驗證，完成  Sitemap 驗證好了之後進入 Google Search Console，在側邊欄找到 索引 -\u0026gt; Sitemap 輸入 sitemap.xml 按提交 Google analytics 待新增\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/hexo/%E5%8A%A0%E5%85%A5-google-search-%E5%92%8C-sitemap/","summary":"前置設定 npm 安裝 hexo-generator-sitemap npm i -S hexo-generator-sitemap 設定插件 將以下內容加到 _config.yml\n 注意空白\n # sitemap sitemap:  path: sitemap.xml 驗證網域 如果你的 hexo 是架在自己的網域可以跳過這步\n因為我的 hexo 是 託管在 GitHub page，在 Google Search Console 驗證的時候沒辦法用網域，所以要放一個特別的檔案到我們的網站根目錄\n 首先到 Google Search Console 新增一個網域 選擇右邊，輸入你的網址  下載提供的 html 並放到 source/ 資料夾  忽略 接下來會遇到 hexo 在生成的時候把這個 html 也放到模板裡面，所以我們要把他加入忽略清單裡面\n在 _config.yml 裡面找到 skip_render\n把直接檔名寫在後面或是用清單都可以   注意空白\n # 直接寫 skip_render: \u0026#39;googlebabababababa.html\u0026#39; # 或是用清單 skip_render:  - \u0026#39;googlebabababababa.","title":"加入 google search 和 sitemap"},{"content":"前言 本來部署 hexo 都是手動下指令，但是這樣在手機上因為沒辦法裝 hexo ,所以一直不能在手機上寫文章。剛好想到 GitHub Action 可以滿足我的需求，上網查了一下資料發現蠻多人有和我一樣的需求，這次參考的是 owlran 大大的文章。\nssh key 因為要部署到 GitHub repo，最方便的方法當然是 ssh key 啦。\nssh-keygen 首先隨便找個資料夾產生一組 ssh key\nssh-keygen -f deploy-key GitHub 再來要讓 GitHub 知道你的 ssh key（public/secret 都要）\npublic key public key 是要放在你的 \u0026lt;username\u0026gt;.github.io 的 repo 下\n .ggithub.io -\u0026gt; settings -\u0026gt; Deploy keys -\u0026gt; add deploy key\n 新增一個 ssh key，名字叫 DEPLOY_KEY_PUB\n把 depoly-key.pub 的內容貼上，記得下面的勾勾（Allow write access ）要選起來\nsecret key secret key 要放在你存放部落格檔案的 repo，owlran 大大是放在同一個 repo 不同 branch，我是放在兩個不同 repo，其中放部落格檔案的 repo 我設成 private repo（因為我放了一些 gitalk 要用的 clientSecret，這個不能公開）。\n總之到你要放部落格檔案的那個 repo，新增一個 secret，等等要再 GitHub Action 裡面調用。\n 你放部落格檔案的那個 repo -\u0026gt; reposettings -\u0026gt; Secrets -\u0026gt; add a new secret\n 名字是 DEPLOY_KEY，內容是 deploy-key 裡面的東西\n接下來就可以進入到 Action 了\nAction 我的 Action 內容基本上是複製 owlran 大大的，但是因為 repo 結構有小小不同所以我了一些修改，如果你要改的話應該是不難才對，GitHub Action 的設定檔我覺得還好懂的。\n這個設定是放在你放部落格檔案的那個 repo\n 注意：第 27, 28 行的 username 和 email 記得改成你的，不然 git commit message 會有問題\n  你放部落格檔案的那個 repo -\u0026gt; Action -\u0026gt; New workflow -\u0026gt; set up a workflow yourself\n name: Hexo on:  push:  branches:  - master  jobs:  build:  runs-on: ubuntu-latest   steps:  - uses: actions/checkout@v1  - name: Use Node.js ${{ matrix.node_version }}  uses: actions/setup-node@v1  with:  node_version: ${{ matrix.node_version }}  - name: Configuration environment  env:  DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}  run: |mkdir -p ~/.ssh/ echo \u0026#34;$DEPLOY_KEY\u0026#34; | tr -d \u0026#39;\\r\u0026#39; \u0026gt; ~/.ssh/id_rsa echo \u0026#34;$DEPLOY_KEY\u0026#34; chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com \u0026gt;\u0026gt; ~/.ssh/known_hosts  - name: git config  env:  username:  email:  run: |git config --global user.name \u0026#34;$username\u0026#34; git config --global user.email \u0026#34;$email\u0026#34; git config --global commit.gpgsign true  - name: Imoport GPG key  id: import_gpg  uses: crazy-max/ghaction-import-gpg@v2  with:  git_user_signingkey: true  git_commit_gpgsign: true  env:  GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}  PASSPHRASE: ${{ secrets.PASSPHRASE }}  - name: Update themes  run: |git submodule init git submodule update  - name: Install dependencies  run: |npm i -g hexo-cli npm i  - name: Clean file  run: | hexo clean   - name: Generate hexo  run: | hexo generate  - name: list posts  run: | hexo list post  - name: Deploy hexo  run: | hexo deploy ","permalink":"https://blog.simba-fs.dev/posts/nodejs/hexo/github-action-%E8%87%AA%E5%8B%95%E9%83%A8%E7%BD%B2-hexo/","summary":"前言 本來部署 hexo 都是手動下指令，但是這樣在手機上因為沒辦法裝 hexo ,所以一直不能在手機上寫文章。剛好想到 GitHub Action 可以滿足我的需求，上網查了一下資料發現蠻多人有和我一樣的需求，這次參考的是 owlran 大大的文章。\nssh key 因為要部署到 GitHub repo，最方便的方法當然是 ssh key 啦。\nssh-keygen 首先隨便找個資料夾產生一組 ssh key\nssh-keygen -f deploy-key GitHub 再來要讓 GitHub 知道你的 ssh key（public/secret 都要）\npublic key public key 是要放在你的 \u0026lt;username\u0026gt;.github.io 的 repo 下\n .ggithub.io -\u0026gt; settings -\u0026gt; Deploy keys -\u0026gt; add deploy key\n 新增一個 ssh key，名字叫 DEPLOY_KEY_PUB\n把 depoly-key.pub 的內容貼上，記得下面的勾勾（Allow write access ）要選起來\nsecret key secret key 要放在你存放部落格檔案的 repo，owlran 大大是放在同一個 repo 不同 branch，我是放在兩個不同 repo，其中放部落格檔案的 repo 我設成 private repo（因為我放了一些 gitalk 要用的 clientSecret，這個不能公開）。","title":"GitHub Action 自動部署 hexo"},{"content":"問題 今天在研究 React 遇到一個問題 當我從外面更新 props 的時候 component 內的 state 不會更新\nfunction Input(props){ \tconst [text, setText] = React.useState(props.text);  \treturn ( \t\u0026lt;input type=\u0026#34;text\u0026#34; value={text}\u0026gt; \t) } 如同上面程式，第二行的 useState 不會隨著 props 更新而更新\n解法 後來找到解法，加上一個 useEffect 監聽 props.text 然後更新 state 就好了\nfunction Input(props){ \tconst [text, setText] = React.useState(props.text); \tReact.useEffect(() =\u0026gt; { \tsetText(props.text); \t}, [props.text]); \treturn ( \t\u0026lt;input type=\u0026#34;text\u0026#34; value={text}\u0026gt; \t) } 如此一來 state 就會和 props 同步了\n參考資料 https://stackoverflow.com/questions/54865764/react-usestate-does-not-reload-state-from-props https://zh-hant.reactjs.org/docs/hooks-effect.html\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/react/react-update-state-on-props-change/","summary":"問題 今天在研究 React 遇到一個問題 當我從外面更新 props 的時候 component 內的 state 不會更新\nfunction Input(props){ \tconst [text, setText] = React.useState(props.text);  \treturn ( \t\u0026lt;input type=\u0026#34;text\u0026#34; value={text}\u0026gt; \t) } 如同上面程式，第二行的 useState 不會隨著 props 更新而更新\n解法 後來找到解法，加上一個 useEffect 監聽 props.text 然後更新 state 就好了\nfunction Input(props){ \tconst [text, setText] = React.useState(props.text); \tReact.useEffect(() =\u0026gt; { \tsetText(props.text); \t}, [props.text]); \treturn ( \t\u0026lt;input type=\u0026#34;text\u0026#34; value={text}\u0026gt; \t) } 如此一來 state 就會和 props 同步了","title":"React update state on props change"},{"content":"最近寫ˋreact 的時候只要遇到 jsx 語法 YCM 就會跳出這個錯誤\nCannot use JSX unless the \u0026#39;--jsx\u0026#39; flag is provided. (FixIt) 研究之後發現這是要給 tsserver 一個 --jsx 的 flag 就可以解決 爬文半個小時後發現只要在專案下的 jsconfig.json\n{  \u0026#34;compilerOptions\u0026#34;: {  \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;,  \u0026#34;checkJs\u0026#34;: true + }, + \u0026#34;compilerOptions\u0026#34;: { + \u0026#34;jsx\u0026#34;: \u0026#34;react\u0026#34;  } } ","permalink":"https://blog.simba-fs.dev/posts/linux/vim/%E8%AE%93-ycm-%E6%8E%A5%E5%8F%97-jsx/","summary":"最近寫ˋreact 的時候只要遇到 jsx 語法 YCM 就會跳出這個錯誤\nCannot use JSX unless the \u0026#39;--jsx\u0026#39; flag is provided. (FixIt) 研究之後發現這是要給 tsserver 一個 --jsx 的 flag 就可以解決 爬文半個小時後發現只要在專案下的 jsconfig.json\n{  \u0026#34;compilerOptions\u0026#34;: {  \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;,  \u0026#34;checkJs\u0026#34;: true + }, + \u0026#34;compilerOptions\u0026#34;: { + \u0026#34;jsx\u0026#34;: \u0026#34;react\u0026#34;  } } ","title":"讓 YCM 接受 jsx"},{"content":"前言 最近開始想學 react 在這之前當然要先把開發環境搞好 其中 react 最重要的就是 webpack 和 babel 了 babel 負責編譯 webpack 負責串街所有工作\n安裝套件 建立一個專案並初始化 mkdir react-test cd react-test npm init -y git init -y 安裝開發用套件 npm i -D \\ @babel/core \\ @babel/cli \\ @babel/preset-env \\ @babel/preset-react \\ babel-loader \\ react \\ react-dom \\ webpack package.json 加入以下的 script\n{ \t\u0026#34;dev\u0026#34;: \u0026#34;webpack --mode development\u0026#34;, \t\u0026#34;watch\u0026#34;: \u0026#34;webpack --mode development --watch\u0026#34;, \t\u0026#34;depoly\u0026#34;: \u0026#34;webpack --mode production\u0026#34; } webpack.config.js 建立 webpack.config.js 這是最小的版本了 沒有任何的擴充\nmodule.exports = {  module: {  rules: [  {  test: /\\.(js|jsx)$/,  exclude: /node_modules/,  use: {  loader: \u0026#34;babel-loader\u0026#34;  }  }  ]  } }; src/dist mkdir src dist 接下來可以把所有的 js 原始碼放在 src/ 下 html template 放在 dist/ 下 # 範例 https://github.com/simba-fs/react-template ","permalink":"https://blog.simba-fs.dev/posts/nodejs/react/webpack-react/","summary":"前言 最近開始想學 react 在這之前當然要先把開發環境搞好 其中 react 最重要的就是 webpack 和 babel 了 babel 負責編譯 webpack 負責串街所有工作\n安裝套件 建立一個專案並初始化 mkdir react-test cd react-test npm init -y git init -y 安裝開發用套件 npm i -D \\ @babel/core \\ @babel/cli \\ @babel/preset-env \\ @babel/preset-react \\ babel-loader \\ react \\ react-dom \\ webpack package.json 加入以下的 script\n{ \t\u0026#34;dev\u0026#34;: \u0026#34;webpack --mode development\u0026#34;, \t\u0026#34;watch\u0026#34;: \u0026#34;webpack --mode development --watch\u0026#34;, \t\u0026#34;depoly\u0026#34;: \u0026#34;webpack --mode production\u0026#34; } webpack.config.js 建立 webpack.","title":"webpack-react"},{"content":"前幾天發現一個專案 nginx ui 他是一個可以讓你在網頁上更改 nginx config 的專案 安裝：\ndocker pull schenkd/nginx-ui 啟動；\ndocker run -p 8080:8080 -v /etc/nginx:/etc/nginx schenkd/nginx-ui 然後打開瀏覽器 http://localhost:8080 就可以看到管理頁面了 很陽春，就是不用 ssh 進 server，沒什麼特點 我應該是不會用這套\n","permalink":"https://blog.simba-fs.dev/posts/linux/server/nginx-ui/","summary":"前幾天發現一個專案 nginx ui 他是一個可以讓你在網頁上更改 nginx config 的專案 安裝：\ndocker pull schenkd/nginx-ui 啟動；\ndocker run -p 8080:8080 -v /etc/nginx:/etc/nginx schenkd/nginx-ui 然後打開瀏覽器 http://localhost:8080 就可以看到管理頁面了 很陽春，就是不用 ssh 進 server，沒什麼特點 我應該是不會用這套","title":"nginx-ui"},{"content":"HTML 的 form 裡的按鈕預設是 submit 所以要加上 type=\u0026quot;button\u0026quot; 它才不會太心急送出表單\n按鈕的 css 「按下」 selector 好像可已用 :active、:focus 但是我兩個失敗了\n","permalink":"https://blog.simba-fs.dev/posts/frontend/html-form-button/","summary":"HTML 的 form 裡的按鈕預設是 submit 所以要加上 type=\u0026quot;button\u0026quot; 它才不會太心急送出表單\n按鈕的 css 「按下」 selector 好像可已用 :active、:focus 但是我兩個失敗了","title":"HTML form button"},{"content":"切換工作區 今天想要在 mxlinux 中快速的切換工作區 我看到可以用滑鼠滾輪切換 可是我想要的是鍵盤快捷鍵 上網查了一下 發現可以透過 Ctrl+Alt+up/down/home/end 來切換\n參考資料 https://unix.stackexchange.com/questions/270334/how-to-move-a-window-to-another-workspace-in-xfce\n","permalink":"https://blog.simba-fs.dev/posts/linux/mxlinux-change-workspace/","summary":"切換工作區 今天想要在 mxlinux 中快速的切換工作區 我看到可以用滑鼠滾輪切換 可是我想要的是鍵盤快捷鍵 上網查了一下 發現可以透過 Ctrl+Alt+up/down/home/end 來切換\n參考資料 https://unix.stackexchange.com/questions/270334/how-to-move-a-window-to-another-workspace-in-xfce","title":"mxlinux-change-workspace"},{"content":"今天心血來潮想設定 GPG，網路上查了一個教學，無疑的又遇到一個坑\n坑 \u0026amp; 解法 我按照他的作法弄完後就是沒辦法 commit 他說 GPG 無法簽章 後來我發現是我的 name 填錯（應該啦，我猜的） 總而言之就重新產生 GPG key 就好了 name 和 git 設定的一樣\n指令 $ gpg --full-gen-key $ gpg --list-secret-keys $ gpg --armor --export \u0026lt;secret key\u0026gt; 刪除金鑰 在刪除的時候分成兩步驟，刪除私鑰、刪除公鑰。在刪除之前要先知道要刪除的金鑰的 ID\ngpg --list-keys 找到那串很長的文字，那就是 ID，複製起來，他起來也許會像這樣\nJFDKSA8FEWHE29HFVC92UHFPA93WOHFVDOPA39U2 再來用兩個指令就可以刪除了，注意一定要先刪私鑰。\ngpg --delete-secret-key \u0026lt;ID\u0026gt; gpg --delete-key \u0026lt;ID\u0026gt; ","permalink":"https://blog.simba-fs.dev/posts/linux/gpg/","summary":"今天心血來潮想設定 GPG，網路上查了一個教學，無疑的又遇到一個坑\n坑 \u0026amp; 解法 我按照他的作法弄完後就是沒辦法 commit 他說 GPG 無法簽章 後來我發現是我的 name 填錯（應該啦，我猜的） 總而言之就重新產生 GPG key 就好了 name 和 git 設定的一樣\n指令 $ gpg --full-gen-key $ gpg --list-secret-keys $ gpg --armor --export \u0026lt;secret key\u0026gt; 刪除金鑰 在刪除的時候分成兩步驟，刪除私鑰、刪除公鑰。在刪除之前要先知道要刪除的金鑰的 ID\ngpg --list-keys 找到那串很長的文字，那就是 ID，複製起來，他起來也許會像這樣\nJFDKSA8FEWHE29HFVC92UHFPA93WOHFVDOPA39U2 再來用兩個指令就可以刪除了，注意一定要先刪私鑰。\ngpg --delete-secret-key \u0026lt;ID\u0026gt; gpg --delete-key \u0026lt;ID\u0026gt; ","title":"gpg"},{"content":"今天為了幫 Let\u0026rsquo;s Remind Daniel 做 SEO 在 免費資源網路社群 找到了一個工具可以直接生成 還有一個可以測試的工具\n連結 生成 測試\n","permalink":"https://blog.simba-fs.dev/posts/frontend/meta-tag/","summary":"今天為了幫 Let\u0026rsquo;s Remind Daniel 做 SEO 在 免費資源網路社群 找到了一個工具可以直接生成 還有一個可以測試的工具\n連結 生成 測試","title":"meta-tag"},{"content":"問題 最近在用 jquery 但是不知道為什麼每次 debugger 都會跳出一個通知 很煩\n解決 後來尋線發現原來是 firefox 好心的 debugger 在 DOM 發生改變的時候通知我 在 裡面 Debugger 頁籤左下有個拉頁叫「Event Listener Breakpoints」 把裡面的東西都點掉就好了 就是那個 DOM Mutation 心得 我原本還以為是 jquery 的問題 原來是好心的 firefox 啊\n","permalink":"https://blog.simba-fs.dev/posts/frontend/firefox-event-listener-breakpoint/","summary":"問題 最近在用 jquery 但是不知道為什麼每次 debugger 都會跳出一個通知 很煩\n解決 後來尋線發現原來是 firefox 好心的 debugger 在 DOM 發生改變的時候通知我 在 裡面 Debugger 頁籤左下有個拉頁叫「Event Listener Breakpoints」 把裡面的東西都點掉就好了 就是那個 DOM Mutation 心得 我原本還以為是 jquery 的問題 原來是好心的 firefox 啊","title":"firefox-event-listener-breakpoint"},{"content":"今天寫 jquery 遇到了一些坑\n1. submit .submit() 是要加在 form 上而不是 submit button 上\n2. this 在 jquery 裡有時後會用到 handler 正常情況下可以用 arrow function 但是如果用到 this 就不能用 arrow function 了 （這不只是 jquery, JS 都是這樣）\n","permalink":"https://blog.simba-fs.dev/posts/frontend/jquery/","summary":"今天寫 jquery 遇到了一些坑\n1. submit .submit() 是要加在 form 上而不是 submit button 上\n2. this 在 jquery 裡有時後會用到 handler 正常情況下可以用 arrow function 但是如果用到 this 就不能用 arrow function 了 （這不只是 jquery, JS 都是這樣）","title":"jquery"},{"content":"今天終於把登入做完了 我覺得最重要的是找好的教學文章、去看沒有人看得懂的程式碼\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/remind-daniel/","summary":"今天終於把登入做完了 我覺得最重要的是找好的教學文章、去看沒有人看得懂的程式碼","title":"remind-daniel"},{"content":"昨天是試著去理解 sqlite3，我發現他的 callback function 真的太煩了 於是我試著去尋找 async 的版本，還真找到了 這個套件把整個 sqlite 包成 async 了\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/sqlite/","summary":"昨天是試著去理解 sqlite3，我發現他的 callback function 真的太煩了 於是我試著去尋找 async 的版本，還真找到了 這個套件把整個 sqlite 包成 async 了","title":"sqlite"},{"content":"我有一個放了很久的計畫，就是自己寫一個 OJ，因為我覺得現在的那個太難用了。 我很快的建立 repo 但是卻完全沒有進展，我寫了一個 shell script 幫忙編譯執行程式之後我就在也沒有動過他了 我沒有繼續動工的原因是我不知道如何隔離使用者提交的程式碼 我想過 docker 可是據說還是不安全 還有 chroot 但是我不知道有沒有比 docker 安全而且設定好麻煩\n昨天去考 TOI　入營考（當然沒進）的時候，我終於看到大名鼎鼎的 CMS 了！ 出來之後我發現他是用一個叫 isolate 的程式來做沙箱測試 而且這好像是 IOI 自己寫的，應該是蠻安全的（吧？） 今天成功編譯過後把心得寫下來\n","permalink":"https://blog.simba-fs.dev/posts/linux/isolate/","summary":"我有一個放了很久的計畫，就是自己寫一個 OJ，因為我覺得現在的那個太難用了。 我很快的建立 repo 但是卻完全沒有進展，我寫了一個 shell script 幫忙編譯執行程式之後我就在也沒有動過他了 我沒有繼續動工的原因是我不知道如何隔離使用者提交的程式碼 我想過 docker 可是據說還是不安全 還有 chroot 但是我不知道有沒有比 docker 安全而且設定好麻煩\n昨天去考 TOI　入營考（當然沒進）的時候，我終於看到大名鼎鼎的 CMS 了！ 出來之後我發現他是用一個叫 isolate 的程式來做沙箱測試 而且這好像是 IOI 自己寫的，應該是蠻安全的（吧？） 今天成功編譯過後把心得寫下來","title":"isolate"},{"content":"最近在下載 youtube 音樂，每次下載都要把檔案重新改名，很麻煩。所以就想要寫一個 shell script 來幫我解決。 首先改名字我相信 youtube-dl 一定有提供這個選項，於是開始查文件。 看到 -o ，接下來講遇到的坑\n-o 坑 -o 後面接的是一個 template string ，不是檔名，而且就算指定副檔名是 .mp3 了還是要寫成 %(ext)s\n","permalink":"https://blog.simba-fs.dev/posts/linux/youtube-dl/","summary":"最近在下載 youtube 音樂，每次下載都要把檔案重新改名，很麻煩。所以就想要寫一個 shell script 來幫我解決。 首先改名字我相信 youtube-dl 一定有提供這個選項，於是開始查文件。 看到 -o ，接下來講遇到的坑\n-o 坑 -o 後面接的是一個 template string ，不是檔名，而且就算指定副檔名是 .mp3 了還是要寫成 %(ext)s","title":"youtube-dl"},{"content":"這是一篇我在用 blessed 時踩的一些雷 會持續的更新\n1. 記得 render 今天在寫 API 時踩到兩次 更新了資料卻沒有 render 例如 textarea.setValue() 這個函式設定完之後他畫面不會更新 要自己 render\n2. textarea.setValue() 只接受字串當參數 我個人覺得 blessed 缺少一個像是 jquery 的函式庫 沒有一個很好的 API 包裝 例如說這個函式 textarea.setValue() 就只吃字串 因為他用了 String.prototype.replace 這個函數 而且他沒有一個很好的防呆機制例如參數型別檢查 幸好是他的程式碼沒有做 uglify 還算簡單易懂 而且 node 的錯誤訊息的 stack 可以引導到真正出錯的地方\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/blessed/blessed-landmine/","summary":"這是一篇我在用 blessed 時踩的一些雷 會持續的更新\n1. 記得 render 今天在寫 API 時踩到兩次 更新了資料卻沒有 render 例如 textarea.setValue() 這個函式設定完之後他畫面不會更新 要自己 render\n2. textarea.setValue() 只接受字串當參數 我個人覺得 blessed 缺少一個像是 jquery 的函式庫 沒有一個很好的 API 包裝 例如說這個函式 textarea.setValue() 就只吃字串 因為他用了 String.prototype.replace 這個函數 而且他沒有一個很好的防呆機制例如參數型別檢查 幸好是他的程式碼沒有做 uglify 還算簡單易懂 而且 node 的錯誤訊息的 stack 可以引導到真正出錯的地方","title":"blessed-landmine"},{"content":"昨天架好了 reverse ssh 讓我可以連回學校 server 今天來研究 ssh tunnel\n簡介 ssh tunnel 分正反向 其實他們的差別只有在方向不一樣 連語法參數都一樣\n正向 tunnel 正向的 tunnel 參數是 -L 語法：\nssh -L [bind_address:]port:host:hostport ssh -L [bind_address:]port:remote_socket ssh -L local_socket:host:hostport ssh -L local_socket:remote_socket 反向 tunnel ssh -R [bind_address:]port:host:hostport ssh -R [bind_address:]port:local_socket ssh -R remote_socket:host:hostport ssh -R remote_socket:local_socket ssh -R [bind_address:]port 心得 看起來好像很難 但是其實用下面這個就夠了 正向：\nssh -L \u0026lt;local port\u0026gt;:localhost:\u0026lt;remote port\u0026gt; \u0026lt;user\u0026gt;@\u0026lt;remote\u0026gt; 反向;\nssh -R \u0026lt;remote port\u0026gt;:localhost:\u0026lt;local port\u0026gt; \u0026lt;user\u0026gt;@\u0026lt;remote\u0026gt; 總而言之就是前面的和選項一樣 如果是 -L 那前面就是 local port 如果是 -R 那前面就是 remote port\n參考連結 https://johnliu55.tw/ssh-tunnel.html\n","permalink":"https://blog.simba-fs.dev/posts/linux/ssh-tunnel/","summary":"昨天架好了 reverse ssh 讓我可以連回學校 server 今天來研究 ssh tunnel\n簡介 ssh tunnel 分正反向 其實他們的差別只有在方向不一樣 連語法參數都一樣\n正向 tunnel 正向的 tunnel 參數是 -L 語法：\nssh -L [bind_address:]port:host:hostport ssh -L [bind_address:]port:remote_socket ssh -L local_socket:host:hostport ssh -L local_socket:remote_socket 反向 tunnel ssh -R [bind_address:]port:host:hostport ssh -R [bind_address:]port:local_socket ssh -R remote_socket:host:hostport ssh -R remote_socket:local_socket ssh -R [bind_address:]port 心得 看起來好像很難 但是其實用下面這個就夠了 正向：\nssh -L \u0026lt;local port\u0026gt;:localhost:\u0026lt;remote port\u0026gt; \u0026lt;user\u0026gt;@\u0026lt;remote\u0026gt; 反向;\nssh -R \u0026lt;remote port\u0026gt;:localhost:\u0026lt;local port\u0026gt; \u0026lt;user\u0026gt;@\u0026lt;remote\u0026gt; 總而言之就是前面的和選項一樣 如果是 -L 那前面就是 local port 如果是 -R 那前面就是 remote port","title":"ssh-tunnel"},{"content":"一直以來連線回社辦的電腦都要走 webtty 再開 tmate 但是今天發現了一個新的方法可以透過反向的 ssh 連回社辦\nreverse ssh 在社辦電腦\n$ ssh -NfR 2222:localhost:22 simba@simba-vps 這可以建立一個連線 這時候到 simba-vps\n$ ssh server@localhost -p 2222 就可以連線回社辦伺服器了\nautossh 但是這樣做 ssh 連線有可能會超時然後斷掉 這時候可以透過 autossh 來幫我們自動建立連線 在社辦電腦\n$ apt install autossh $ autossh -Mf 2222 -NR 1111:localhost:22 simba@simba-vps -p 22 這樣就可以在 vps 上\n$ ssh server@localhost -p 1111 來連回社辦啦！ 最後可以把這堆在 vps 上再做一次就可以在 internet 連回社辦伺服器了\n參考網址 https://stackoverflow.com/questions/15983795/how-do-i-establish-a-bidirectional-ssh-tunnel\nhttps://ez3c.tw/2043\nhttps://www.ubuntu-tw.org/modules/newbb/viewtopic.php?viewmode=compact\u0026amp;topic_id=17538\u0026amp;forum=7\nhttp://blog.adahsu.net/2007/11/ssh-reverse-tunnel.html\nhttps://codertw.com/%E4%BC%BA%E6%9C%8D%E5%99%A8/377688/\n這篇講 ssh tunnel 最清楚\nhttps://yu-jack.github.io/2019/01/08/ssh-tunnel/\n","permalink":"https://blog.simba-fs.dev/posts/linux/reverse-ssh/","summary":"一直以來連線回社辦的電腦都要走 webtty 再開 tmate 但是今天發現了一個新的方法可以透過反向的 ssh 連回社辦\nreverse ssh 在社辦電腦\n$ ssh -NfR 2222:localhost:22 simba@simba-vps 這可以建立一個連線 這時候到 simba-vps\n$ ssh server@localhost -p 2222 就可以連線回社辦伺服器了\nautossh 但是這樣做 ssh 連線有可能會超時然後斷掉 這時候可以透過 autossh 來幫我們自動建立連線 在社辦電腦\n$ apt install autossh $ autossh -Mf 2222 -NR 1111:localhost:22 simba@simba-vps -p 22 這樣就可以在 vps 上\n$ ssh server@localhost -p 1111 來連回社辦啦！ 最後可以把這堆在 vps 上再做一次就可以在 internet 連回社辦伺服器了\n參考網址 https://stackoverflow.com/questions/15983795/how-do-i-establish-a-bidirectional-ssh-tunnel\nhttps://ez3c.tw/2043\nhttps://www.ubuntu-tw.org/modules/newbb/viewtopic.php?viewmode=compact\u0026amp;topic_id=17538\u0026amp;forum=7\nhttp://blog.adahsu.net/2007/11/ssh-reverse-tunnel.html\nhttps://codertw.com/%E4%BC%BA%E6%9C%8D%E5%99%A8/377688/\n這篇講 ssh tunnel 最清楚\nhttps://yu-jack.github.io/2019/01/08/ssh-tunnel/","title":"reverse-ssh"},{"content":"今天心血來潮在看 unix socket 突然想到 node 可不可以把 服務監聽在一個 socket file 這樣在設定的時候就不用記哪個服務是幾 port\nnode 部份 監聽在 unix socket 查完資料後發現其實只要把原本填 port 的地方改成 socket file 的路徑就好了 像這樣\nconst express = require(\u0026#39;express\u0026#39;); const app = express();  app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {  res.send(\u0026#39;Hello World\\n\u0026#39;); });  app.listen(\u0026#39;/tmp/express.sock\u0026#39;); 刪除 socket file 因為每次的 listen 都會新增一個 socket file 相當於佔用一個 port 如果不刪除的話就相當於 port 被佔用了 會噴錯 所以每次程式結束的時候要把這個 socket file 刪掉 然後在 /tmp 下的檔案會在開機後自動刪掉 所以如果部屬後發什麼問題重開機就對了！ 修改完的 code 長這樣\nconst fs = require(\u0026#39;fs\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const app = express();  app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {  res.send(\u0026#39;Hello World\\n\u0026#39;); }); app.listen(\u0026#39;/tmp/express.sock\u0026#39;, console.log); process.on(\u0026#39;SIGINT\u0026#39;, () =\u0026gt; {  fs.unlinkSync(\u0026#39;/tmp/express.sock\u0026#39;);  process.exit(0); }) 測試 弄完了伺服器 要怎麼測試呢？ 這時候可以用 curl 來測試\n$ curl --unix-socket /tmp/express.sock http://localhost Hello World nginx reverse proxy 現在我們把伺服器開好了 但是 unix socket 只能在本機瀏覽啊！ 所以我們要透過 nginx 來幫忙做 reverse proxy 先新增一個 /etc/nginx/sites-available/test.conf\nserver{ listen 80; server_name t.localhost; location / { proxy_pass http://unix:/tmp/express.sock:/; } } 然後在 /etc/hosts 新增一條\n127.0.0.1\tt.localhost 最後就可以打開瀏覽器 http://t.localhost 應該會出現 502 Getway Error 為什麼呢？ 因為 socket file 的權限設定 其他使用者 (nginx) 無法開啟 所以要\n$ chmod 777 /tmp/express.sock 這樣就可以啦！\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/unix-socket/","summary":"今天心血來潮在看 unix socket 突然想到 node 可不可以把 服務監聽在一個 socket file 這樣在設定的時候就不用記哪個服務是幾 port\nnode 部份 監聽在 unix socket 查完資料後發現其實只要把原本填 port 的地方改成 socket file 的路徑就好了 像這樣\nconst express = require(\u0026#39;express\u0026#39;); const app = express();  app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {  res.send(\u0026#39;Hello World\\n\u0026#39;); });  app.listen(\u0026#39;/tmp/express.sock\u0026#39;); 刪除 socket file 因為每次的 listen 都會新增一個 socket file 相當於佔用一個 port 如果不刪除的話就相當於 port 被佔用了 會噴錯 所以每次程式結束的時候要把這個 socket file 刪掉 然後在 /tmp 下的檔案會在開機後自動刪掉 所以如果部屬後發什麼問題重開機就對了！ 修改完的 code 長這樣\nconst fs = require(\u0026#39;fs\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const app = express();  app.","title":"unix-socket"},{"content":"今天完成了新版本的 treetify 看這 同時我設計好了右邊的 edit 但是我的問題是他要根據情況不同切換不同的頁面 來看看我的一些想法：\n 從 screen.children[2] 把他會掉，可是會出錯不行 有一個元件 Carousel 好像可以但是他其實是用方向鍵控制所以也不行 終於我想了一個方法，接下來來介紹 這是測試程式碼  const blessed = require(\u0026#39;blessed\u0026#39;); const contrib = require(\u0026#39;blessed-contrib\u0026#39;);  const screen = blessed.screen({  title: \u0026#39;JSON viewer\u0026#39;,  debug: true }); const grid = new contrib.grid({  rows: 1,  cols: 2,  screen: screen });  const tree = grid.set(0, 0, 1, 1, blessed.box, {  border: {type: \u0026#39;line\u0026#39;},  content: \u0026#39;Tree\u0026#39;,  label: \u0026#39;Tree\u0026#39; });  const edit = grid.set(0, 1, 1, 1, blessed.box, {  border: {type: \u0026#39;line\u0026#39;},  content: \u0026#39;Edit\u0026#39;,  label: \u0026#39;Edit\u0026#39; });  const box2 = blessed.box({  border: {type: \u0026#39;line\u0026#39;},  content: \u0026#39;Box2\u0026#39;,  label: \u0026#39;Box2\u0026#39; }); const box3 = blessed.box({  border: {type: \u0026#39;line\u0026#39;},  content: \u0026#39;Box3\u0026#39;,  label: \u0026#39;Box3\u0026#39; }); const box4 = blessed.box({  border: {type: \u0026#39;line\u0026#39;},  content: \u0026#39;Box4\u0026#39;,  label: \u0026#39;Box4\u0026#39; }); const box5 = blessed.box({  border: {type: \u0026#39;line\u0026#39;},  content: \u0026#39;Box5\u0026#39;,  label: \u0026#39;Box5\u0026#39; });  edit.append(box2); edit.append(box3); edit.append(box4); edit.append(box5); edit.append(box2); edit.append(box3); console.log(Object.keys(edit.children));  screen.key([\u0026#39;escape\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;C-c\u0026#39;], () =\u0026gt; {  process.exit(0); });  tree.focus();  screen.key([\u0026#39;tab\u0026#39;, \u0026#39;t\u0026#39;], function(ch, key) {  if(screen.focused == tree.rows)  edit.focus();  else  tree.focus(); });  screen.render(); 這裡建立三個 box 要顯示哪一個的時候就將他 append 實驗證實這樣不會建立新的圖層 而是把下面的那個搬到最上面 完美的解決了這個問題\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/blessed/blessed%E5%88%87%E6%8F%9B%E7%95%AB%E9%9D%A2/","summary":"今天完成了新版本的 treetify 看這 同時我設計好了右邊的 edit 但是我的問題是他要根據情況不同切換不同的頁面 來看看我的一些想法：\n 從 screen.children[2] 把他會掉，可是會出錯不行 有一個元件 Carousel 好像可以但是他其實是用方向鍵控制所以也不行 終於我想了一個方法，接下來來介紹 這是測試程式碼  const blessed = require(\u0026#39;blessed\u0026#39;); const contrib = require(\u0026#39;blessed-contrib\u0026#39;);  const screen = blessed.screen({  title: \u0026#39;JSON viewer\u0026#39;,  debug: true }); const grid = new contrib.grid({  rows: 1,  cols: 2,  screen: screen });  const tree = grid.set(0, 0, 1, 1, blessed.box, {  border: {type: \u0026#39;line\u0026#39;},  content: \u0026#39;Tree\u0026#39;,  label: \u0026#39;Tree\u0026#39; });  const edit = grid.","title":"blessed切換畫面"},{"content":"Tree 想說先想一個專案來練練手 熟悉一下 blessed 突然看到 blessed-contrib 裡有個元件叫 tree 想說可以做成 JSON viewer 於是就開工了！\n其中最重要的部份就是搞定樹狀結構 因為他有特定的格式和選項 下面是官方的範例\n範例 {  extended: true,  children: {  \u0026#39;Fruit\u0026#39;: {  children: {  \u0026#39;Banana\u0026#39;: {},  \u0026#39;Apple\u0026#39;: {},  \u0026#39;Cherry\u0026#39;: {},  \u0026#39;Exotics\u0026#39;: {  children: {  \u0026#39;Mango\u0026#39;: {},  \u0026#39;Papaya\u0026#39;: {},  \u0026#39;Kiwi\u0026#39;: {  name: \u0026#39;Kiwi(notthebird!)\u0026#39;,  myCustomProperty: \u0026#34;hairyfruit\u0026#34;  }  }  },  \u0026#39;Pear\u0026#39;: {}  }  },  \u0026#39;Vegetables\u0026#39;: {  children: {  \u0026#39;Peas\u0026#39;: {},  \u0026#39;Lettuce\u0026#39;: {},  \u0026#39;Pepper\u0026#39;: {}  }  }  } } 每個節點都是物件 他的子節點存在 children 裡 如果是空物件代表這是葉節點 extended 屬性是是否展開，預設 true name 是顯示出來的字，如果要改再設，預設是 index myCustomProperty 直翻是自訂屬性，應該是當 tree.on('select') 觸發時傳進去的\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/blessed/blessed-contrib-tree/","summary":"Tree 想說先想一個專案來練練手 熟悉一下 blessed 突然看到 blessed-contrib 裡有個元件叫 tree 想說可以做成 JSON viewer 於是就開工了！\n其中最重要的部份就是搞定樹狀結構 因為他有特定的格式和選項 下面是官方的範例\n範例 {  extended: true,  children: {  \u0026#39;Fruit\u0026#39;: {  children: {  \u0026#39;Banana\u0026#39;: {},  \u0026#39;Apple\u0026#39;: {},  \u0026#39;Cherry\u0026#39;: {},  \u0026#39;Exotics\u0026#39;: {  children: {  \u0026#39;Mango\u0026#39;: {},  \u0026#39;Papaya\u0026#39;: {},  \u0026#39;Kiwi\u0026#39;: {  name: \u0026#39;Kiwi(notthebird!)\u0026#39;,  myCustomProperty: \u0026#34;hairyfruit\u0026#34;  }  }  },  \u0026#39;Pear\u0026#39;: {}  }  },  \u0026#39;Vegetables\u0026#39;: {  children: {  \u0026#39;Peas\u0026#39;: {},  \u0026#39;Lettuce\u0026#39;: {},  \u0026#39;Pepper\u0026#39;: {}  }  }  } } 每個節點都是物件 他的子節點存在 children 裡 如果是空物件代表這是葉節點 extended 屬性是是否展開，預設 true name 是顯示出來的字，如果要改再設，預設是 index myCustomProperty 直翻是自訂屬性，應該是當 tree.","title":"blessed-contrib-tree"},{"content":"某天我有一個問題 gtop 的圖畫界面是怎麼做的，我知道他是用 node 寫的，對他別有興趣 我上 github 看他的 package.json 發現他的 depandence 只有三個\n... \t\u0026#34;dependencies\u0026#34;: { \t\u0026#34;blessed\u0026#34;: \u0026#34;^0.1.81\u0026#34;, \t\u0026#34;blessed-contrib\u0026#34;: \u0026#34;^4.8.16\u0026#34;, \t\u0026#34;systeminformation\u0026#34;: \u0026#34;^4.14.4\u0026#34; \t}, ... 其中 systeminformation 很顯然是取得系統資訊 那 GUI 的 library 應該就是 blessed 和 blessed-contrib 了 去 blessed 的 github 看看 沒想到這是一個超強大的函式庫 可是網路上的教學卻很少 只好自己看 docs 啦\n接下來是我測試的一些程式碼和截圖\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/blessed/blessed/","summary":"某天我有一個問題 gtop 的圖畫界面是怎麼做的，我知道他是用 node 寫的，對他別有興趣 我上 github 看他的 package.json 發現他的 depandence 只有三個\n... \t\u0026#34;dependencies\u0026#34;: { \t\u0026#34;blessed\u0026#34;: \u0026#34;^0.1.81\u0026#34;, \t\u0026#34;blessed-contrib\u0026#34;: \u0026#34;^4.8.16\u0026#34;, \t\u0026#34;systeminformation\u0026#34;: \u0026#34;^4.14.4\u0026#34; \t}, ... 其中 systeminformation 很顯然是取得系統資訊 那 GUI 的 library 應該就是 blessed 和 blessed-contrib 了 去 blessed 的 github 看看 沒想到這是一個超強大的函式庫 可是網路上的教學卻很少 只好自己看 docs 啦\n接下來是我測試的一些程式碼和截圖","title":"blessed"},{"content":"用 bash 寫 log 分析工具 因為我們的 server 不知道是為什麼一直受到 DDoS 攻擊\n我想知道是什麼時段容易受到攻擊和每次多久、來自那個 ip\n於是我花了一點時間寫了幾個簡單的 script\n","permalink":"https://blog.simba-fs.dev/posts/linux/server/server-tool/","summary":"用 bash 寫 log 分析工具 因為我們的 server 不知道是為什麼一直受到 DDoS 攻擊\n我想知道是什麼時段容易受到攻擊和每次多久、來自那個 ip\n於是我花了一點時間寫了幾個簡單的 script","title":"server-tool"},{"content":"伺服器被 DDoS 惹 今天早上把社團的 reverse proxy server 換成 nginx\n下午心血來潮看看 log 檔 因為沒有寫好的工具\n首先把 log 檔 cp 到我的電腦再來處理\n","permalink":"https://blog.simba-fs.dev/posts/linux/server/ddos/","summary":"伺服器被 DDoS 惹 今天早上把社團的 reverse proxy server 換成 nginx\n下午心血來潮看看 log 檔 因為沒有寫好的工具\n首先把 log 檔 cp 到我的電腦再來處理","title":"ddos"},{"content":"nginx 反向代理伺服器 (reverse proxy) 之前社網 server 因為學校防火牆限制只能對外開 80 443 兩個 port\n而且我們只有一個 ip (203.64.138.177)\n所以要用 reverse proxy 來代理我們的多項服務\n原本我只會用 apache2 後來不知道是不是因為 apache 太肥導致有時候回應時間會很久\n所以我起了將 proxy server 換成 nginx 的想法\n","permalink":"https://blog.simba-fs.dev/posts/linux/server/nginx-reverse-proxy-setup/","summary":"nginx 反向代理伺服器 (reverse proxy) 之前社網 server 因為學校防火牆限制只能對外開 80 443 兩個 port\n而且我們只有一個 ip (203.64.138.177)\n所以要用 reverse proxy 來代理我們的多項服務\n原本我只會用 apache2 後來不知道是不是因為 apache 太肥導致有時候回應時間會很久\n所以我起了將 proxy server 換成 nginx 的想法","title":"nginx-reverse-proxy-setup"},{"content":"各種設定值嘗試 Highlight - # highlight: rainbow + highlight: rainbow var a = 7122; console.log(a); var a = 7122; console.log(a); int a = 7122; cout \u0026lt;\u0026lt; a; ","permalink":"https://blog.simba-fs.dev/posts/nodejs/hexo/hexo-config/","summary":"各種設定值嘗試 Highlight - # highlight: rainbow + highlight: rainbow var a = 7122; console.log(a); var a = 7122; console.log(a); int a = 7122; cout \u0026lt;\u0026lt; a; ","title":"hexo-config"},{"content":"自動部屬部落格 參考網址：https://op30132.github.io/2020/02/05/github-action/ 生成公私鑰時不用在部落格根目錄，記的不要加入 git，要刪掉\nname: HEXO CI  on:  push:  branches:  - master  jobs:  build:  runs-on: ubuntu-latest  strategy:  matrix:  node-version: [12.x]   steps:  - uses: actions/checkout@v1   - name: Use Node.js ${{ matrix.node-version }}  uses: actions/setup-node@v1  with:  node-version: ${{ matrix.node-version }}   - name: Configuration environment  env:  HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}}  run: |mkdir -p ~/.ssh/ echo \u0026#34;$HEXO_DEPLOY_PRI\u0026#34; | tr -d \u0026#39;\\r\u0026#39; \u0026gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com \u0026gt;\u0026gt; ~/.ssh/known_hosts git config --global user.name \u0026#34;simba-fs\u0026#34; git config --global user.email \u0026#34;simba-fsgmail.com\u0026#34;  - name: Install dependencies  run: |npm i -g hexo-cli npm i -S hexo npm i  - name: hexo  run: | git checkout hexo  - name: config  run: | hexo config  - name: test hexo  run: | hexo new post telsst  - name: list  run: |ls source/_posts PWD=$(pwd) hexo list post  - name: clean  run: | hexo clean  - name: generate  run: | hexo g  - name: deploy  run: | hexo d ","permalink":"https://blog.simba-fs.dev/posts/nodejs/hexo/audo-depoly-by-github-action/","summary":"自動部屬部落格 參考網址：https://op30132.github.io/2020/02/05/github-action/ 生成公私鑰時不用在部落格根目錄，記的不要加入 git，要刪掉\nname: HEXO CI  on:  push:  branches:  - master  jobs:  build:  runs-on: ubuntu-latest  strategy:  matrix:  node-version: [12.x]   steps:  - uses: actions/checkout@v1   - name: Use Node.js ${{ matrix.node-version }}  uses: actions/setup-node@v1  with:  node-version: ${{ matrix.node-version }}   - name: Configuration environment  env:  HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}}  run: |mkdir -p ~/.","title":"audo-depoly-by-github-action"},{"content":"啟用 gitalk 留言  到這個網址填資料 加入下面的片段到_config.yml  disqus: enabled: false gitalk: enabled: true owner: \u0026lt;username\u0026gt; repo: \u0026lt;username\u0026gt;.github.io admin: [\u0026#39;\u0026lt;username\u0026gt;\u0026#39;] clientID: \u0026lt;clientID\u0026gt; clientSecret: \u0026lt;clientSecret\u0026gt; 加入下面的片段到themes/cactus/layout/_partial/comments.ejs  \u0026lt;% if(page.comments \u0026amp;\u0026amp; theme.gitalk.enabled){ %\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;gitalk-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var gitalk = new Gitalk({ clientID: \u0026#39;\u0026lt;%= theme.gitalk.clientID %\u0026gt;\u0026#39;, clientSecret: \u0026#39;\u0026lt;%= theme.gitalk.clientSecret %\u0026gt;\u0026#39;, id: md5(window.location.pathname), repo: \u0026#39;\u0026lt;%= theme.gitalk.repo %\u0026gt;\u0026#39;, owner: \u0026#39;\u0026lt;%= theme.gitalk.owner %\u0026gt;\u0026#39;, admin: \u0026#39;\u0026lt;%= theme.gitalk.admin %\u0026gt;\u0026#39;, distractionFreeMode: \u0026#39;\u0026lt;%= theme.gitalk.on %\u0026gt;\u0026#39; }) gitalk.render(\u0026#39;gitalk-container\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;% } %\u0026gt; 完成！注意 gitalk 在本地端是沒有用的喔！記得 hexo g; hexo d  ","permalink":"https://blog.simba-fs.dev/posts/nodejs/hexo/gitalk/","summary":"啟用 gitalk 留言  到這個網址填資料 加入下面的片段到_config.yml  disqus: enabled: false gitalk: enabled: true owner: \u0026lt;username\u0026gt; repo: \u0026lt;username\u0026gt;.github.io admin: [\u0026#39;\u0026lt;username\u0026gt;\u0026#39;] clientID: \u0026lt;clientID\u0026gt; clientSecret: \u0026lt;clientSecret\u0026gt; 加入下面的片段到themes/cactus/layout/_partial/comments.ejs  \u0026lt;% if(page.comments \u0026amp;\u0026amp; theme.gitalk.enabled){ %\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;gitalk-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var gitalk = new Gitalk({ clientID: \u0026#39;\u0026lt;%= theme.gitalk.clientID %\u0026gt;\u0026#39;, clientSecret: \u0026#39;\u0026lt;%= theme.gitalk.clientSecret %\u0026gt;\u0026#39;, id: md5(window.location.pathname), repo: \u0026#39;\u0026lt;%= theme.gitalk.repo %\u0026gt;\u0026#39;, owner: \u0026#39;\u0026lt;%= theme.gitalk.owner %\u0026gt;\u0026#39;, admin: \u0026#39;\u0026lt;%= theme.gitalk.admin %\u0026gt;\u0026#39;, distractionFreeMode: \u0026#39;\u0026lt;%= theme.","title":"gitalk"},{"content":"好用的插件 因為 hexo 本身沒有提供編輯器\n所以每次在編輯文章時都需要打路徑\n這個插件他會去找到你的文章\n然後給你選要編輯那一個\n這只是其中一個功能\n還有重新命名、刪除、隔離和加入\n隔離是將其他文章暫時隔離，加入是將文章加回來\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/hexo/hexo-cli-extras/","summary":"好用的插件 因為 hexo 本身沒有提供編輯器\n所以每次在編輯文章時都需要打路徑\n這個插件他會去找到你的文章\n然後給你選要編輯那一個\n這只是其中一個功能\n還有重新命名、刪除、隔離和加入\n隔離是將其他文章暫時隔離，加入是將文章加回來","title":"hexo-cli-extras"},{"content":"把 hexo 部屬到 gh-page 執行\n$ npm i hexo -g $ hexo init blog $ cd blog 修改 _config.yml 刪除最後兩行，改成\ndeploy: type: git repo: git@github.com:\u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; branch: master 執行\n$ npm i hexo-deployer-git $ hexo depoly 在 repo 設定中 GitHub Pages 隨便選一個 Jekyll theme，這樣才不會 404\n 地雷：在之後都部屬要加上 -g\n $ hexo d -g 不然不會生效\n完成!\n將原始碼保存 執行\n$ git checkout -b hexo $ git add . $ git commit -m init $ git push -u origin hexo 完成\n","permalink":"https://blog.simba-fs.dev/posts/nodejs/hexo/hexo-installation/","summary":"把 hexo 部屬到 gh-page 執行\n$ npm i hexo -g $ hexo init blog $ cd blog 修改 _config.yml 刪除最後兩行，改成\ndeploy: type: git repo: git@github.com:\u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt; branch: master 執行\n$ npm i hexo-deployer-git $ hexo depoly 在 repo 設定中 GitHub Pages 隨便選一個 Jekyll theme，這樣才不會 404\n 地雷：在之後都部屬要加上 -g\n $ hexo d -g 不然不會生效\n完成!\n將原始碼保存 執行\n$ git checkout -b hexo $ git add . $ git commit -m init $ git push -u origin hexo 完成","title":"hexo-installation"},{"content":"🖐️ 哈囉！問世界安好  我目前是大學生，讀書閒暇時間會開發一些小專案。\n 成功高中電子計算機研習社 擔任 退休網管兼教學 本名: 陳宏彰 常用網名: simba-fs、simbafs Golang、NodeJS、HTML/CSS/JS   \n🛠 作品   telegrary Telegrary = Telegram + diary\nTelegrary 是一個 Telegram 機器人，讓你可以在 Telegram 上管理日記。同時 Telegrary 提供了一個 CLI 界面，讓你可以在終端機管理日記。\n  slides\n這個網站可以把 markdown 轉成線上簡報，還支援會議室模式，詳細可以參考 GitHub 或是 Help Page Demo\n  AURL\n這本來是我練習資料庫存取的一個專案，結果就越長越大，最後變成一個完整的專案了。\n目前正在做第二版，程式碼會更具易讀性、可維護性，也會導入權限系統 第二版胎死腹中\n  📬 聯絡方式  Discord id: simba-fs#2030 telegram: @simbafs twitter: @simbafs  ","permalink":"https://blog.simba-fs.dev/about/","summary":"🖐️ 哈囉！問世界安好  我目前是大學生，讀書閒暇時間會開發一些小專案。\n 成功高中電子計算機研習社 擔任 退休網管兼教學 本名: 陳宏彰 常用網名: simba-fs、simbafs Golang、NodeJS、HTML/CSS/JS   \n🛠 作品   telegrary Telegrary = Telegram + diary\nTelegrary 是一個 Telegram 機器人，讓你可以在 Telegram 上管理日記。同時 Telegrary 提供了一個 CLI 界面，讓你可以在終端機管理日記。\n  slides\n這個網站可以把 markdown 轉成線上簡報，還支援會議室模式，詳細可以參考 GitHub 或是 Help Page Demo\n  AURL\n這本來是我練習資料庫存取的一個專案，結果就越長越大，最後變成一個完整的專案了。\n目前正在做第二版，程式碼會更具易讀性、可維護性，也會導入權限系統 第二版胎死腹中\n  📬 聯絡方式  Discord id: simba-fs#2030 telegram: @simbafs twitter: @simbafs  ","title":""},{"content":"友站  蛋餅的競程隨筆 https://omeletwithoutegg.github.io  JS 資源  MDN https://developer.mozilla.org  其他  星八哥技術週刊 https://weekly.starbugs.dev  ","permalink":"https://blog.simba-fs.dev/resource/","summary":"resource","title":"Resource"}]