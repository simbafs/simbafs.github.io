<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Simba&#39;s Blog</title>
    <link>https://blog.simbafs.cc/</link>
    <description>Recent content on Simba&#39;s Blog</description>
    <image>
      <url>https://blog.simbafs.cc/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.simbafs.cc/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 15 Jun 2022 17:09:18 +0800</lastBuildDate><atom:link href="https://blog.simbafs.cc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Solarized</title>
      <link>https://blog.simbafs.cc/posts/linux/vim/solarized/</link>
      <pubDate>Wed, 15 Jun 2022 17:09:18 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/vim/solarized/</guid>
      <description>solarized 是一個文字界面常見的配色方案，不僅是用在 vim，大多數 terminal 和 editor 也都支援
install 加入 ```vim Plug &amp;rsquo;ericbn/vim-solarized&#39;
然後安裝 # transparent background 因為設定關係，所以如果你的終端機有設定透明背景，在 vim 中會全部變不透明，載入[這個設定](https://gist.github.com/fuadnafiz98/d91e468c9bc4689868eb0984a29fef66)就可以解決，你也可以放在另外檔案再引入 ```vim &amp;#34; https://gist.github.com/fuadnafiz98/d91e468c9bc4689868eb0984a29fef66 &amp;#34; for transparent background function! AdaptColorscheme() highlight clear CursorLine highlight Normal ctermbg=none highlight LineNr ctermbg=none highlight Folded ctermbg=none highlight NonText ctermbg=none highlight SpecialKey ctermbg=none highlight VertSplit ctermbg=none highlight SignColumn ctermbg=none endfunction autocmd ColorScheme * call AdaptColorscheme() highlight Normal guibg=NONE ctermbg=NONE highlight CursorColumn cterm=NONE ctermbg=NONE ctermfg=NONE highlight CursorLine cterm=NONE ctermbg=NONE ctermfg=NONE highlight CursorLineNr cterm=NONE ctermbg=NONE ctermfg=NONE highlight clear LineNr highlight clear SignColumn highlight clear StatusLine &amp;#34; Change Color when entering Insert Mode autocmd InsertEnter * set nocursorline &amp;#34; Revert Color to default when leaving Insert Mode autocmd InsertLeave * set nocursorline &amp;#34;&amp;#34; extra settings, uncomment them if necessary :) &amp;#34;set cursorline &amp;#34;set noshowmode &amp;#34;set nocursorline &amp;#34; trasparent end </description>
    </item>
    
    <item>
      <title>不同「邊數」的平面</title>
      <link>https://blog.simbafs.cc/posts/buckyball/plantofnumbers/</link>
      <pubDate>Sat, 11 Jun 2022 23:26:40 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/buckyball/plantofnumbers/</guid>
      <description>圖 先上圖，每個都是推到邊長為 4
3 4 5 6 7 8 9 10 11 12 13 共通性質 堆積 相鄰三個球球都是最密堆積
球球數 球球數=邊數*Σn
特殊性質 平面 只有 n=3,6 會形成完全平面
凹陷 當 n=4,5，會形成下凹的漏斗狀
多層 只有 n=3,5,6 可以多層堆疊，其中 n=4,6 因為都是平面，可以形成一樣的堆積形式。n=5 會以類似立方最密堆積的方式形成立體形狀
鞍形 從 n=7 開始，堆積時會自然地形成鞍形，且角度越來越小
堆積技巧 首先取出「邊長」顆球球繞成環形，然後自然的繞成第二圈，整理角角形成最密堆積，然後在邊長大於 3 的邊上丟一顆球球，從最遠、最長的邊開始，邊長為三的邊會最穩定，盡量每次丟球球都要整理乾淨。堆積的時候要注意中心球球數是否跑掉。另外 11 顆前都還算好堆，12 開始會黏起來，但最後是可以穩定的分開的，13 就是完成也無法穩定分開，超過 13 還沒嘗試過。</description>
    </item>
    
    <item>
      <title>兩輸入生產單位的比較</title>
      <link>https://blog.simbafs.cc/posts/game/mindustry/two-input-compare/</link>
      <pubDate>Sun, 22 May 2022 23:06:02 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/game/mindustry/two-input-compare/</guid>
      <description>目的 驗證不同設計的生產效率差異 用科學的方式檢驗下面這些毫無根據、隨意編造的偏見 實驗方法 相同的物品源、相同的生產建築數量、相同的輸出軌數和時間，以不同的輸入方法配置，計算每秒生產量。
相同物品源：就一樣數量的物品源，本次實驗用兩組實驗，所以是四個沙、兩個煤 相同生產建築：八個煉矽廠 相同輸出軌數：各兩條 相同輸出時間：連接到同一個能量源，計時一段時間後拆除能量源，計算雙方生產數量 因為輸送帶用的是最低階，可能會補給不足或是消化不夠快，但是因為兩個都是相同的限制（輸出軌數），要卡一定是兩個一起卡，頂多被卡成平手。這個時候如果還輸，那就不知道是誰的問題了喔！
原始數據和計算結果 秒數 A B 10 10.8 11.0 20 9.6 10.9 30 9.2 9.7 40 9.1 9.6 50 9.0 9.5 60 8.9 9.2 平均 9.4 10.0 結果與討論 在時間拉長後，因為被卡住的東西被平均掉，因此兩個都生產效率都下降，這個很正常
根據結果，即便都被限制，生產效率都還是 B 配置比較高，無論時間拉多長。
根據我個人的猜測，B 因為輸入和輸出沒有混雜在一起，因此不會造成堵塞（仔細觀察 A，最後在反向分類器那邊常常會堵住，這就是輸入輸出混雜的後果），導致即使輸入比例不對，效率依舊比較高。
A 的穩定性高了那麼一點點，不重要
結果比較 根據可擴張性而言，B 的設計是可以橫向無限擴張，不像 A，縱向擴張受到輸送帶效率影響、橫向擴張受到輸入比須滿管影響（不滿管比例就不對，這個設計也就跟垃圾一樣毫無意義，因此必須滿管）。另外，一套 B 可以有比 A 更彈性的輸入和輸出輸送帶數量，因此可以適應更多的狀況。
B 唯一的缺點是佔體積大了一點點，但我個人認為，沒有任何事物是完美的，因此用一點點小缺點換取最多的優點，這個是比追求無謂的小體積來的更重要。
更重要的是，B 的設計更為簡單，建造成本低、可以無限擴張
後續實驗 根據 Magicaltank 和 a0000778 的建議，換成溢流器的確會增加效率，但即使沒換，但還是比 A 設計效率高。</description>
    </item>
    
    <item>
      <title>砲台自動瞄準</title>
      <link>https://blog.simbafs.cc/posts/game/mindustry/turretautoaim/</link>
      <pubDate>Wed, 18 May 2022 16:29:13 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/game/mindustry/turretautoaim/</guid>
      <description>用處理器可以控制砲台們打的方向和什麼時候打，這樣只要有一群受控的砲台，就可以在射程範圍內指哪打哪
單一砲台 如圖所示，砲台跟著玩家瞄準的方向打
以下是程式碼
radar player any any distance duo1 1 player sensor x player @shootX sensor y player @shootY sensor shoot player @shooting control shoot duo1 x y shoot 0 command description radar 取得玩家物件 sensor 抽出玩家物件的 shootX、shootY（瞄準的點）和 shooting（是否正在開火） control 控制 duo1 砲台 variable description player 玩家物件 x 瞄準的 X 座標 y 瞄準的 Y 座標 shooting 是否開火 多個砲台 上面的指令只能控制一個砲台，那麼要怎麼控制多個砲台呢？答案是 loop，但是 Mindustry 沒有提供 loop，我們只能用 jump，那麼就來看看程式吧！
set n 0 getlink result n radar player any any distance result 1 player sensor x player @shootX sensor y player @shootY sensor shoot player @shooting control shoot result x y shoot 0 op add n n 1 op mod n n @links jump 1 always x false 以下重複的就不會再多講了</description>
    </item>
    
    <item>
      <title>控制敵方路徑</title>
      <link>https://blog.simbafs.cc/posts/game/mindustry/pathofenemy/</link>
      <pubDate>Tue, 17 May 2022 16:16:27 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/game/mindustry/pathofenemy/</guid>
      <description>在遊戲中，如何有效的讓資源集中在前線是一門學問，最好的情況當然是所有可能路徑都佈置強大的火力，但真實情況往往不是如此。
當遇到有多個洞口的地圖時，你可能堵好一個洞，敵方就從令一個洞跑進來，然後核心就被攻破了，但是你又沒有足夠的資源和時間在第一時間把所有的洞都佈置火力。這時候你就必須了解的方式如何行動的。
本文提到的敵方都是遊戲電腦 AI，所以比較笨、很好騙，如果是和你的朋友對打，可能就不適用了。
自動找路 尋找路徑可說是電腦科學一個很常見又基本的問題，Mindustry 尋路演算法會考慮預估時間。這個預估時間包括距離、要打破的牆等等，計算出來了之後選擇一條最段時間的路。注意，這裡他不會考慮沿途可能遭受的火力，我們就是要利用他這點來設計。
我的習慣作法 首先，最靠近空降區的洞不一定適合佈置砲台（例如第三關廢墟海岸左上角那個超級小的洞）這些地方可能是腹地狹小或是資源不足，總之你不會想要在這裡放砲台。那就用三層銅牆（不一定要 2x2 的，1x1 也可以）把他堵起來，一層防守兩層緩衝。挑選到適合的地方佈置砲台後，不要堵死，要留一條寬至少 3 格、夠長的通道。這個通道你要確保通暢，可以毫無阻礙的通到你的核心，這樣電腦就會判定這條路毫無阻礙，優先選擇，敵人就不會亂走到你沒有佈防的地方。這樣做還有一個好處，當你可以生產機甲時，友方機甲就可以直接走出去，不會受到阻礙，你也不用幫他們開門。
然後在左右佈滿砲台，記得一定要放修理方塊，這樣你才不用常常來修方塊。至於通道長度和牆壁厚度，取決於這關敵方火力強度和你選用的砲台射程，如果你能夠在對方開火之前就幹掉他們，當然牆壁可以一層意思意思就好。</description>
    </item>
    
    <item>
      <title>Merge</title>
      <link>https://blog.simbafs.cc/posts/game/mindustry/merge/</link>
      <pubDate>Tue, 17 May 2022 08:32:38 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/game/mindustry/merge/</guid>
      <description>Mindustry 中，某條輸送帶（A）合併到另一條未滿的輸送帶（B）上時，如果 B 有一個足夠小的空隙，A 是有機會無法補滿的
這種情況通常出現在兩列礦機的合併
要解決這個狀況，最簡單的方法是加上一個分配器
當然這裡的輸出是不能被堵住的，不然就沒有意義了(X</description>
    </item>
    
    <item>
      <title>Yubikey</title>
      <link>https://blog.simbafs.cc/posts/linux/yubikey/</link>
      <pubDate>Tue, 19 Apr 2022 15:22:55 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/yubikey/</guid>
      <description>感謝廖煥杰 liaojason2 賣我一個 1200，撿到寶啦！我買的是 Yubikey 5C NFC，看起來幾乎所有功能都有
login 如果開啟這個，登入、解除鎖定等等動作都需要 Yubikey，聽起還很安全，但是因為我的筆電只有一個 type C，所以必須把 USB hub 拔掉，挺麻煩，我就把他關掉了。
在密碼輸入框的地方，先插入 yubikey，輸入密碼、按 enter，然後轉圈圈的時候按 yubikey 上金色按鈕（這個似乎是指紋辨識），就可以登入了。
Yubico Yubikey 5C NFC setup on Ubuntu 21.04
ssh gpg 研究中&amp;hellip;
如何在 Mac 上，把 YubiKey 與 GPG、SSH 搭配在一起 OpenPGP SSH access with Yubikey and GnuPG
2FA 按照各個網站的說明設定，下面是我找到可以設定 Yubikey 的網站/APP
Google（我買這個 yubikey 最主要目的） Github twitter facebook heroku twitter 在手機登入好像怪怪的，試了 5 分鐘才成功登入了</description>
    </item>
    
    <item>
      <title>Anbox</title>
      <link>https://blog.simbafs.cc/posts/linux/anbox/</link>
      <pubDate>Mon, 18 Apr 2022 18:53:50 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/anbox/</guid>
      <description>anbox 是 Android in a box，是一種基於容器化技術的 Android 模擬器，所以執行速度會比較快、比較省資源，而且因為每個 App 都在各自的容器裡面，所以比較安全 （應該沒理解錯吧？）。
安裝 anbox 需要先安裝兩個 kernal modules，然後安裝 anbox 後，為了之後方便，所以要裝 Google Play，不裝也是可以，但之後安裝其他 App 比較麻煩
系統 我用的系統是 Ubuntu 21.04，如果你的系統不一樣，可能會有某些步驟不太一樣。
這次安裝因為涉及 Linux Kernel 所以隨時重開機有很大機會幫助改善遇到的問題
安裝 Linux Kernal Modules 如果你的 Linux kernale &amp;gt; 5.0，那理論上已經包在 Kernel 裡面了，所以不用安裝
Starting with Ubuntu 19.04 binder and ashmem are now build with the standard Ubuntu kernel (&amp;gt;= 5.0) and you don’t have to install the modules from the PPA anymore.</description>
    </item>
    
    <item>
      <title>Ibus Font</title>
      <link>https://blog.simbafs.cc/posts/linux/ibus-font/</link>
      <pubDate>Sat, 16 Apr 2022 21:47:25 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/ibus-font/</guid>
      <description>最近在打字時總覺得中文選字的時候 ibus 字體好小，於是就開始查怎麼弄
經過搜尋後，找到 https://askubuntu.com/questions/1030442/how-to-increase-font-size-of-preview-options-when-using-an-input-method 這個網頁，總而言之就是先去裝 ibus font setting 這個外掛，然後就可以用 ibus-setup 調整了
照做之後的確可以調大小字體，但我不知道是不是因為裝了這個外掛的關係，反正我是成功改好了</description>
    </item>
    
    <item>
      <title>kdeconnect</title>
      <link>https://blog.simbafs.cc/posts/linux/kdeconnect/</link>
      <pubDate>Thu, 07 Apr 2022 23:25:28 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/kdeconnect/</guid>
      <description>kdeconnect 顧名思義是 kde 出的一款 connect 軟體，功能非常多而且方便。電腦和手機都安裝好軟體後，只要在同一個網域就可以配對連接
功能介紹 基本訊息 - 在電腦和手機上可以互相看到電池、網路等基本訊息 通知 - 可以設定電腦顯示手機通知或手機顯示電腦通知，或是兩者都開啟，我通常只開前者 媒體控制 - 無論是 VLC、YouTube、Nefflix 或任何網頁，都可以控制進度、音量、暫停，而且雙方都可以控制。這個是我最愛的功能之一 命令控制 - kdeconnect 可以讓你在手機上執行電腦上預先設定好的指令，像是關機、鎖定等等，下面會推薦幾個我設定的命令 傳檔案和資料夾共用 - kdeconnect 可以讓你連接電腦和手機上特定的資料夾，或是傳送單一檔案 共用剪貼簿 - 如其名，這是一個非常實用的功能，但是有時候觸發條件怪怪的 輸入 - 不論是滑鼠、鍵盤，兩邊都可以互相當對方的輸入裝置，這個功能非常好用 還有像是讓手機大叫（找手機用）、簡報控制、傳簡訊、手機有電話的時候自動暫停音樂等等奇奇怪怪的功能 推薦命令 Description Command 鎖定螢幕並暫停 VLC 播放 loginctl lock-session; dbus-send --type=method_call --dest=org.mpris.MediaPlayer2.vlc /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.PlayPause 解除鎖定螢幕（免密碼） loginctl unlock-session </description>
    </item>
    
    <item>
      <title>Modeline</title>
      <link>https://blog.simbafs.cc/posts/linux/vim/modeline/</link>
      <pubDate>Thu, 07 Apr 2022 23:13:04 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/vim/modeline/</guid>
      <description>modeline 是一個可以將 vim 設定嵌入檔案的方式，這樣就可以讓某些檔案有自己的設定，像是折疊、不要行數、tab 等於多少空白等等。
簡單的條件 簡單的 modeline 需要滿足幾個條件：
開頭（不必是行首）至少有一個空白/tab 用 vim、vi 等字開頭，這裡還可以設定哪個版本才要載入 基本的範例 vim: wrap 參考資料 https://stackoverflow.com/questions/3958416/embed-vim-settings-in-file
help page in :help modeline</description>
    </item>
    
    <item>
      <title>用 Github Action 編譯並發 Release</title>
      <link>https://blog.simbafs.cc/posts/golang/github-action-release/</link>
      <pubDate>Sun, 27 Mar 2022 11:00:18 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/golang/github-action-release/</guid>
      <description>如果自己寫的小工具的 GitHub 頁面右邊 Release 那欄有個什麼東西，一定很酷對吧！如果裡面已經提供了不同作業系統編譯好的程式，一定更酷！
想要建立 Release，你可以在新版本發布時自己手動 crose compile 再手動設定 Release，這個方法可行，但是聽起來全手動就很 low，我們要用一個全自動的方式發 Release！
Github Actioin 既然我們程式碼都託管在 GitHub 了，直接用 Gtithub Action 是很合理的吧！
觸發條件 因為我們要做的是發布版本，不是每個 commit 都要觸發，因此觸發條件就設成
on: push: tags: - &amp;#34;v[0-9]+.[0-9]+.[0-9]+&amp;#34; 意思是只有像是 v0.1.13 這樣的標籤會觸發，也就是你建立新版本時。
編譯 在嘗試各種套件之後，我覺得 goreleaser-action 是我用起來最舒服的，不用太多設定，就直接都編譯好了（詳細設定可以去 goreleaser 的網站看 )
在 GitHub Action 中設定就下面幾行，第一個步驟是安裝 go，再來就是編譯了。
- name: Set up Go uses: actions/setup-go@v3.0.0 with: go-version: 1.17.x - name: Run GoReleaser uses: goreleaser/goreleaser-action@v2.9.1 with: version: latest args: release --rm-dist env: GITHUB_TOKEN: ${{ secrets.</description>
    </item>
    
    <item>
      <title>震動 vs 振動</title>
      <link>https://blog.simbafs.cc/posts/daily/vibrate/</link>
      <pubDate>Wed, 09 Mar 2022 23:16:55 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/daily/vibrate/</guid>
      <description>震動 vs 振動 都是往復運動，但有不同，簡單來說，振動比震動有規律。 像是單擺是振動，地震是震動，因為單擺的運動是規律的，而地震波比較不規律
https://pedia.cloud.edu.tw/Entry/Detail/?title=%E6%8C%AF%E5%8B%95 https://pedia.cloud.edu.tw/Entry/Detail?title=%E9%9C%87%E5%8B%95
至於為什麼我會去查這個呢？因為我發現物理實驗預報寫「簡諧震動」，但是我覺得「震」筆畫太多了，我想寫「振」於是就跑去查教育部字典
得證：懶惰使人進步</description>
    </item>
    
    <item>
      <title>Bluetooth 突然卡住都不動</title>
      <link>https://blog.simbafs.cc/posts/linux/bluwtooth-error/</link>
      <pubDate>Wed, 02 Mar 2022 23:31:59 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/bluwtooth-error/</guid>
      <description>裝了 Ubuntu 20.04 之後不知道為什麼藍芽用一用就會卡住，所有設備都連不上，也關不掉。一開始的解決方式是重開機（這時候關機會跳一個奇怪的錯誤訊息），但是覺得太沒效率了，上網查了一下。
原因 根據 這個網頁，這個似乎是 linux 核心的藍芽驅動有問題（我沒有認真看，但好像是升級到最新的 linux kernel 就可以解決了）。
雖然升級 linux kernel 應該可以一勞永逸解決這個問題，但是這個 bug 其實不常出現，為了他編譯核心有點大題小做，所以我們需要一個簡單的方法解決。
輕便解法 根據 這篇問答，經過我的測試，第一個答案就可以解決了，當藍芽又掛掉時，執行
sudo rmmod btusb sudo modprobe btusb 這樣藍芽就回來了。這兩個指令簡單來說就是重新載入藍芽模組，這就是為什麼重開機可以解決（重開機就是重新載入所有模組）</description>
    </item>
    
    <item>
      <title>Golang Plguin</title>
      <link>https://blog.simbafs.cc/posts/golang/plguin/</link>
      <pubDate>Mon, 21 Feb 2022 18:54:55 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/golang/plguin/</guid>
      <description>Go 動態載入程式 Go 是一個編譯式的語言，也就是說他不像 JS 那樣可以動態執行程式碼。像是 Hexo 和 Hugo，前者因為是 JS 寫的，因此支援非常豐富的外掛，但後者因為是 Go 寫的，因此在不使用其他直譯式程式語言的情況下，很難製作外掛。
另一個 Go 寫的軟體 ponzu 則是在加入一段程式碼後，重新編譯自己。這麼做解決了外掛的問題，而且又不會失去 Go 的快速，但是就必須保留整個主程式的原始碼，而且也不那麼的「動態」
ponzu 這個軟體兩年沒人維護了，很多東西都怪怪的，超級難編譯
Plugin in Go 在 1.8 版的時候，Go 推出了 Plguin 套件，可以將外掛和主程式分開編譯，如果外掛有更動，不需要重新編譯主程式；主程式也可以動態載入外掛。
外掛 如果要將一個 package 編譯成外掛，首先他的 package 必須是 main，但是裡面的函式 main、init 都不會被執行，只有大寫開頭的變數、型態、函式會被暴露給主程式。
編譯外掛時，需要加上 -buildmode=plguin，這樣 go build 就會將原始碼編譯成 .so（share object）檔，這樣就可以被主程式呼叫。
主程式 主程式要載入外掛前，需要引用 plugin 套件
import &amp;#34;plugin&amp;#34; 用 func Open(path string) (*Plugin, error) 可以載入一個編譯過的外掛，如果重複呼叫這個函式，除了第二次外都會回傳第一次載入的結果，也就是說假如你在很多個 gorutine 中載入同一個外掛，go 會保證他是「安全」的。注意看，path 是個字串，因此你可以動態產生外掛的路徑，不需要寫死。
載入完了之後，用 func (p *Plugin) Lookup(symName string) (Symbol, error) 可以取得外掛暴露出來的變數、函式，因為 symName 是字串，因此這裡也可以動態選擇要的變數。現在你有一個型態是 Symbol 的變數了，其實這個 Symbol 就是 interface{} 所以不管要做什麼事，你都要先用 symbol.</description>
    </item>
    
    <item>
      <title>React 解決中文輸入法</title>
      <link>https://blog.simbafs.cc/posts/frontend/react-composition/</link>
      <pubDate>Sat, 05 Feb 2022 16:59:44 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/frontend/react-composition/</guid>
      <description>今天在開發晶晶體產生器的時候，發現中文輸入總是有問題，這時候我想起以前看過 Hackmd 官方的一篇 blog，提到中文輸入法如果有問題，可能和組字事件有關。於是就開始研究。首先我將以下設定加入 textarea 裡觀察組字事件的行為
onCompositionStart={(e) =&amp;gt; console.log(&amp;#39;compositionStart&amp;#39;, e.data)} onCompositionEnd={(e) =&amp;gt; console.log(&amp;#39;compositionEnd&amp;#39;, e.data)} onCompositionUpdate={(e) =&amp;gt; console.log(&amp;#39;compositionUpdate&amp;#39;, e.data)} 當我打「今天我想要吃蛋餅」的時候，console 長這樣
compositionStart &amp;lt;empty string&amp;gt; compositionUpdate ㄐ compositionUpdate ㄐㄧ compositionUpdate ㄐㄧㄣ compositionUpdate 今 compositionUpdate 今ㄊ compositionUpdate 今ㄊㄧ compositionUpdate 今ㄊㄧㄢ compositionUpdate 今天 compositionUpdate 今天ㄨ compositionUpdate 今天ㄨㄛ compositionUpdate 今天ㄒㄨㄛ compositionUpdate 今天ㄒㄨ compositionUpdate 今天ㄒ compositionUpdate 今天 compositionUpdate 今天ㄨ compositionUpdate 今天ㄨㄛ compositionUpdate 今天我 compositionUpdate 今天我ㄒ compositionUpdate 今天我ㄒㄧ compositionUpdate 今天我ㄒㄧㄤ compositionUpdate 今天我想 compositionUpdate 今天我想ㄧ compositionUpdate 今天我想ㄧㄠ compositionUpdate 今天我想要 compositionUpdate 今天我想要ㄔ compositionUpdate 今天我想要吃 compositionUpdate 今天我想要吃ㄉ compositionUpdate 今天我想要吃ㄉㄢ compositionUpdate 今天我想要吃但 compositionUpdate 今天我想要吃但ㄅ compositionUpdate 今天我想要吃但ㄅㄧ compositionUpdate 今天我想要吃但ㄅㄧㄥ compositionUpdate 今天我想要吃蛋餅 compositionUpdate &amp;lt;empty string&amp;gt; compositionEnd &amp;lt;empty string&amp;gt; 根據實驗結果，我猜我們可以用 onCompositionUpdate 事件來修正，於是現在 textarea 變成這樣</description>
    </item>
    
    <item>
      <title>LaTeX Starter</title>
      <link>https://blog.simbafs.cc/posts/other/latex-starter/</link>
      <pubDate>Wed, 22 Dec 2021 23:18:41 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/other/latex-starter/</guid>
      <description>LaTeX 是一老牌的排版系統，基本的概念是內容與呈現分離，在撰寫內容時不用管排版（所以你就不會擔心移動圖片一咪咪整份文件就跑版了）。除了排版，LaTeX 還很擅長輸出各種莫名其妙的東西，像是超複雜的數學式、象棋棋譜、化學結構&amp;hellip;&amp;hellip;
credit:https://zh.wikipedia.org/wiki/LaTeX 在使用 LaTeX 一段時間之後，對它的印象就是加強版的 Markdown（或是說 Markdown 是簡化版的 LaTeX），而且他還有巨集，可以擴展原版沒有提供的功能（就是上面那些奇奇怪怪的東西）。
幾個重點 中文 使用 LaTeX 對大部分人最重要的就是「怎麼打中文」，總不可能打全英文報告吧！要用中文，渲染引擎要用 XLaTeX，然後加上以下設定
（.ttf 可以指向你自己喜歡的中文字型檔）
\usepackage[CJKmath=true,AutoFakeBold=3,AutoFakeSlant=.2]{xeCJK} \newCJKfontfamily\Kai{[jf-openhuninn-1.1.ttf]} \newCJKfontfamily\Hei{[jf-openhuninn-1.1.ttf]} \newCJKfontfamily\NewMing{[jf-openhuninn-1.1.ttf]} \usepackage{fontspec} \setmainfont{[jf-openhuninn-1.1.ttf]} \setmonofont{[jf-openhuninn-1.1.ttf]} \XeTeXlinebreaklocale &amp;#34;zh&amp;#34; 換行 LaTeX 在換行這個設計和 Markdown 一樣，因為內容與呈現分離，所以你的換行不是真的換行。Markdown 用 （兩個空白），在 LaTeX 是 \\（兩個反斜線）
巨集與 Package LaTeX 一個核心概念是巨集，就是函數啦，巨集的開頭是 \（反斜線），巨集可以自己定義，也可以用 \usepackage{} 載入別人寫好的
overleaf overleaf 是一個線上編輯 LaTeX 的網站，預裝了幾乎所有寫報告用得到的 packages，而且可以上傳自己的字型、圖片，而且右邊可以顯示產生的 PDF（非即時，按 CTRL-Enter 編譯）。這個網站整體使用體驗還算不錯，該有的功能都有了。
表格 切版 畫 LaTeX 表格最簡單的方式是用 Google Sheet + latexkit，這個外掛可以幫你把跨行、跨欄表格通通弄好，你只需要再調整格線和格式就行了（latexkit 只負責切版）
格線 直線 如果直線你需要兩條，在 \begin{tabular}{|L|L|} 這裡多加幾條 | 就可以了。直線如果遇到跨列的格子會自動跳過，所以你不需要處理</description>
    </item>
    
    <item>
      <title>ExecCmd</title>
      <link>https://blog.simbafs.cc/posts/golang/exec-cmd/</link>
      <pubDate>Tue, 19 Oct 2021 00:06:19 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/golang/exec-cmd/</guid>
      <description>Golang 執行外部命令 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os/exec&amp;#34; ) func checkErr(err error) { if err != nil { panic(err) } } func main() { pw := exec.Command(&amp;#34;wc&amp;#34;) stdin, err := pw.StdinPipe() checkErr(err) fmt.Fprintln(stdin, &amp;#34;fjasdfkjsad\njdfaksdfjksdfjkasdfj\ndjfkajsdk&amp;#34;) output, err := pw.Output() checkErr(err) fmt.Println(string(output)) } </description>
    </item>
    
    <item>
      <title>Aconf</title>
      <link>https://blog.simbafs.cc/posts/golang/aconf/</link>
      <pubDate>Fri, 24 Sep 2021 08:46:37 +0800</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/golang/aconf/</guid>
      <description>aconf 是個可以直接幫你解決所有「設定」問題的套件，設定可以有預設、從命令列參數、環境變數和設定檔，設定檔還有官方支援四種格式，dotEnv、HCL、toml、yaml 和 json。
而且設定檔還可以有不只一個，他可以把多個設定檔合成，相當方便
基本使用 定義 struct 首先我們需要一個 struct 來定義我們的設定
type Config struct { Addr string `default:&amp;#34;:3000&amp;#34;` Title string `default:&amp;#34;Aconf Testing&amp;#34;` SysAdmin []string `default:&amp;#34;simba-fs,peter&amp;#34;` } 載入設定 再來，我們可以設定要從哪些來源載入設定值
loader := aconfig.LoaderFor(&amp;amp;config, aconfig.Config{ // 這四個預設都是關閉的，如果你想關閉任何一個隨時都可以關閉他 // SkipDefaults: false, // SkipFiles: false, // SkipEnv: false, // SkipFlags: false, EnvPrefix: &amp;#34;APP&amp;#34;, FlagPrefix: &amp;#34;app&amp;#34;, Files: []string{&amp;#34;~/.config/app.toml&amp;#34;, &amp;#34;app.toml&amp;#34;}, FileDecoders: map[string]aconfig.FileDecoder{ &amp;#34;.toml&amp;#34;: aconfigtoml.New(), }, }) if err := loader.Load(); err != nil { panic(err) } 這樣你就可以用檔案、環境變數和命令列參數設定了。</description>
    </item>
    
    <item>
      <title>Day 21：儲存器與剪貼簿</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day21/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day21/</guid>
      <description>from: https://stackoverflow.blog/2021/04/19/how-often-do-people-actually-copy-and-paste-from-stack-overflow-now-we-know/ 這個是一個 梗圖，大意是你寫程式一定會用到 CTRL-C 和 CTRL-V。我們今天就來看看 vim 的剪貼簿吧！
在用剪貼簿時，複製的來源可能會有很多種，以我們的環境為例，可能會用系統剪貼簿、tmux 和 vim 本身的剪貼簿
系統剪貼簿 基本上對 vim 來說系統剪貼簿和 tmux 在複製貼上是差不多的，在輸入模式貼上就可以了
但是要注意多行的程式碼貼上時 vim 會把縮排搞亂，所以你要嘛用 &amp;lt;leader&amp;gt;f 重新整理程式碼，或是用命令 :r!cat，貼上後再按 C-d 貼到程式裡面。
:r!cat 這個命令在 Day 13 時有把他寫成快捷鍵 &amp;lt;F3&amp;gt; 了，所以你也可以直接按 &amp;lt;F3&amp;gt; 會有一樣的效果
另外，下面會講到用 vim 命令存取系統剪貼簿
❓ :r!cat 是什麼意思？ r 這個命令是「載入某個檔案並貼到游標行下面」，用法是 :r {file}。但是我們這裡不用檔名，!cat 在這裡的意思是「shell 命令 cat 的 stdout 這個檔案」，而執行 cat 時需要 stdin，也就是你剛剛貼上程式碼的地方（在 status bar 下面）。這個方法可以繞過自動縮排，就不會出現程式碼貼上被 vim 弄亂的情形了。 從 vim 複製 複製到系統剪貼簿很簡單，在選取時記的按住 &amp;lt;SHIFT&amp;gt; 就行了，但是因為我們有開啟 vim 滑鼠模式，所以 tmux 剪貼簿就不能複製了（滑鼠被 vim 搶走）（關於 tmux 剪貼簿請看 Day 09#複製。</description>
    </item>
    
    <item>
      <title>Day 20：切水果囉！vim 切螢幕與分頁</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day20/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day20/</guid>
      <description>分割螢幕 記的 tmux 可以切螢幕嗎？vim 也可以喔！
命令 我們快速用表格帶過命令
快捷鍵 命令 效果 s :sp[lit] {file} 水平分割 v :vs[plit] {file} 垂直分割 + 把目前視窗放大一點 - 把目前視窗縮小一點 = 等大 c :q 關掉目前視窗 o 關掉其他視窗 方向鍵/h/j/k/l/tag 在視窗間移動 如果你在 day 13 有開啟滑鼠模式，那你可以直接用滑鼠拉動邊框調整大小
vim 分割視窗的優點 與 tmux 比起來，我更常用 tmux 分割視窗，因為快捷鍵比較直覺好用，但是 vim 有個 tmux 做不到的優點
如果你用 tmux 分割視窗並開啟同一個檔案，對於系統來說你其實是開了兩次，兩個的更改互相不相關。
但是 vim 不一樣，他是「同一份檔案」，也就是說左邊的改動會立刻同步到右邊
如果開啟一個檔案，左邊的更改會立刻同步到右邊 這個特性有個好處，如果檔案太長，你要主要要編輯了兩個區域沒辦法在同一個螢幕顯示，就可以用 vim 的分割畫面，左邊編輯上面，右邊編輯下面。
分頁 比起切割螢幕，我更常用分頁功能。vim 每個分頁都和 tmux 一樣，可以隨便你亂切，不會互相影響。
快捷鍵 一樣快速看過命令
快捷鍵 命令 效果 :tabe {file} 開啟新分頁並開啟檔案，如果不指定檔名會開啟一個空白檔案 gt 下一個分頁 gT 上一個分頁 一樣，如果你開啟了滑鼠模式，你可以用滑鼠點擊切換分頁（最上面）</description>
    </item>
    
    <item>
      <title>Day 19：該是時候升級你的噴射引擎囉！vim-emmet 重複與迭代</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day19/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day19/</guid>
      <description>重複 如果想讓某個標籤/群組重複，只要用乘號 * 加上數字就可以讓他重複了
h1.title*5 -&amp;gt; &amp;lt;h1 class=&amp;#34;title&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 class=&amp;#34;title&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 class=&amp;#34;title&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 class=&amp;#34;title&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 class=&amp;#34;title&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; ------------ (p.artical+br)*3 -&amp;gt; &amp;lt;p class=&amp;#34;artical&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;br&amp;gt; &amp;lt;p class=&amp;#34;artical&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;br&amp;gt; &amp;lt;p class=&amp;#34;artical&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;br&amp;gt; 迭代 在重複的時候，你可能會有某些地方是要要變化的，例如從 id 從 1 開始遞增，你可以使用錢號 $ 代表要遞增的位數
如果你不是要從 1 開始迭代，可以使用小老鼠 @ 指定開始的數字
如果要反著數，用 @- 可以倒數到 0，當然也可以指定倒數到多少
h1#title$$*12 -&amp;gt; &amp;lt;h1 id=&amp;#34;title01&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title02&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title03&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title04&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title05&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title06&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title07&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title08&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title09&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title10&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title11&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;title12&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; ------------ h1#$@10*3 -&amp;gt; &amp;lt;h1 id=&amp;#34;10&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;11&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;12&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; ------------ h1#$@-*3 -&amp;gt; &amp;lt;h1 id=&amp;#34;2&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;1&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;0&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; ------------ h1#$@-6*3 -&amp;gt; &amp;lt;h1 id=&amp;#34;8&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;7&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1 id=&amp;#34;6&amp;#34;&amp;gt;&amp;lt;/h1&amp;gt; ------------ h$*6 -&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt; &amp;lt;h3&amp;gt;&amp;lt;/h3&amp;gt; &amp;lt;h4&amp;gt;&amp;lt;/h4&amp;gt; &amp;lt;h5&amp;gt;&amp;lt;/h5&amp;gt; &amp;lt;h6&amp;gt;&amp;lt;/h6&amp;gt; 範本包圍 我不確定這個叫什麼，反正就這樣啦</description>
    </item>
    
    <item>
      <title>Day 18：幫你的 HTML 開發裝上噴射引擎！vim-emmet</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day18/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day18/</guid>
      <description>emmet-vim 是 emmet 的 vim 版本（這句好像是廢話
注意：emmet-vim 用的是自己寫的而不是用 emmet.io 官方的解析引擎
emmet-vim 是一套外掛程式，他可以解析一段字串，然後根據規則變成 html，例如下面的例子
.tab&amp;gt;(tr#col$&amp;gt;td*3)*4 會被解析成 &amp;lt;div class=&amp;#34;tab&amp;#34;&amp;gt; &amp;lt;tr id=&amp;#34;col1&amp;#34;&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr id=&amp;#34;col2&amp;#34;&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr id=&amp;#34;col3&amp;#34;&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr id=&amp;#34;col4&amp;#34;&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/div&amp;gt; 是不是很方便，用一行的指令可以變成 22 行的 HTML，而且還會幫你排版好喔，有沒有香！
安裝 在 ~/.config/nvim/plugin.vim 加入一行
+ Plug &amp;#39;mattn/emmet-vim&amp;#39; 然後記得修改後需要打指令 :so % | PlugInstall 安裝
coc-emmet coc-emmet 是個可選可不選的 coc 擴充，可以讓你不用按 emmet-vim 的快捷鍵。雖然這個擴充幾乎可以代替 emmet-vim，但是因為他依靠 coc.nvim，所以有時候他會跳不出建議，例如右括號結尾：(p&amp;gt;div.title$)，你還是只能按 emmet-vim 的快捷鍵</description>
    </item>
    
    <item>
      <title>Day 17：coc.nvim 設定下集</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day17/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day17/</guid>
      <description>今天的東西相當多，在 GitHub README Example 中除了昨天介紹過得今天都收錄了，直接進主題吧！
喔！另外有些東西我真的不知道是什麼我會用原文寫並用中文括號括起來，歡迎知道的朋友留言告訴我
&amp;#34; 設定文字編碼（我想這個你的 init.vim/.vimrc 都應該有了） set encoding=utf-8 &amp;#34; 如果 hidden 沒有設定，「TextEdit」可能會失敗 &amp;#34; TextEdit 也許是彈出式輸入框吧？阿災 set hidden &amp;#34; 有些伺服器對於備份檔會出錯，請看 issue #649 &amp;#34; https://github.com/neoclide/coc.nvim/issues/649 set nobackup set nowritebackup &amp;#34; 把下面的命令欄變高，多一點空間 set cmdheight=2 &amp;#34; 不傳訊息給「|ins-completion-menu|」（這我看不太出來有什麼差 set shortmess+=c &amp;#34; 使用 &amp;lt;c-space&amp;gt; 觸發自動完成 if has(&amp;#39;nvim&amp;#39;) inoremap &amp;lt;silent&amp;gt;&amp;lt;expr&amp;gt; &amp;lt;c-space&amp;gt; coc#refresh() else inoremap &amp;lt;silent&amp;gt;&amp;lt;expr&amp;gt; &amp;lt;c-@&amp;gt; coc#refresh endif &amp;#34; 用 `[g` 和 `]g` 跳到診斷的位置（就是程式碼有問題地方 &amp;#34; 用命令 `:CocDiagnostics` 在分割視窗列出目前檔案中所有有問題的點 nmap &amp;lt;silent&amp;gt; [g &amp;lt;Plug&amp;gt;(coc-diagnostic-prev) nmap &amp;lt;silent&amp;gt; ]g &amp;lt;Plug&amp;gt;(coc-diagnostic-next) &amp;#34; 程式碼轉跳（這個我覺得有點難記，而且這四個實驗出來效果非常像，我的建議是試過後選你覺得順眼的，不要全上 nmap &amp;lt;silent&amp;gt; gd &amp;lt;Plug&amp;gt;(coc-definition) nmap &amp;lt;silent&amp;gt; gy &amp;lt;Plug&amp;gt;(coc-type-definition) nmap &amp;lt;silent&amp;gt; gi &amp;lt;Plug&amp;gt;(coc-implementation) nmap &amp;lt;silent&amp;gt; gr &amp;lt;Plug&amp;gt;(coc-references) &amp;#34; 用 K（注意大寫）顯示文件在分割視窗 nnoremap &amp;lt;silent&amp;gt; K :call &amp;lt;SID&amp;gt;show_documentation()&amp;lt;CR&amp;gt; function!</description>
    </item>
    
    <item>
      <title>Day 16：自動補全！coc.nvim</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day16/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day16/</guid>
      <description>一個好的自動補全工具可以讓你工作效率翻倍，你不用再去查文件了，自動補全不僅可以告訴你這裡有什麼函數可以用，還會告訴你參數的型態、函數功能的說明，可以說是把文件都寫在 vim 裡面了。
以前我用的自動補全是 You Complete Me(YCM)，現在我選擇使用 coc.nvim 原因是他提供更多的補全來源、外掛和設定，而且可以用 nodejs 自製外掛，據說所有純 JS 寫的 VS code 外掛都可以裝（這個我沒實驗過，只是傳聞）。關於這兩個自動補全外掛的比較礙於篇幅請自行 Google。
安裝 coc.nvim 和一般的 vim 外掛一樣，都是用 vim-plug 安裝就可以了，在 ~/.config/nvim/plugin.vim 中新增以下設定
Plug &amp;#39;neoclide/coc.nvim&amp;#39;, {&amp;#39;branch&amp;#39;: &amp;#39;release&amp;#39;} so ~/.config/nvim/coc-config.vim 因為 coc 有很多設定，為了避免檔案太雜亂我把 coc 相關的設定移到另一個檔案，就像我們在 前天 做得一樣
接下來建立 ~/.config/nvim/coc-config.vim，不然等等載入設定檔 vim 會報錯
:!touch ~/.config/nvim/coc-config.vim :! {cmd} 可以執行外部命令
接下來存檔安裝
:w | PlugInstall 跑完後，重開 vim，coc 就裝好了
lsp 語言伺服器協定 在講 coc 之前必須先講 Language Server Protocol，簡稱 lsp，中文是「語言伺服器協定」。lsp 做的事是提供自動補全和 go to def，能做到這兩個功能的原因是因為 lsp 懂程式碼，他知道你寫的每個字代表什麼。為什麼 lsp 這麼強呢？因為 lsp 什麼都不懂，他把所有事情丟給 language server 處理，所以只要你有裝 language server，那麼 lsp 什麼語言都懂。</description>
    </item>
    
    <item>
      <title>Day 15：vim 外掛大雜燴！</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day15/</link>
      <pubDate>Wed, 15 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day15/</guid>
      <description>看到這裡，你可能還是很疑惑，到底 vim 好用在哪？嘿嘿，那是因為強大的外掛還沒裝啦！網路上會有一些配好一堆外掛的，像是 spaceVim，他們的策略和 vs code 很像，先幫你裝好一對外掛，讓你隨開及用。這樣做好處是初學者比較愛，但是常常會裝了一堆用不到的功能，反而讓載入速度、記憶體用量大增。
所以我們自己挑我們需要的外掛裝起來，效果完全不會輸 vs code 這些笨重的編輯器！
今天要介紹很多模組，都是我選出來製作一個現代化 IDE 必備的模組，相當的精華，一起來看看吧！ 記得修改後需要打指令 :so % | PlugInstall
現代化 IDE 必裝模組 以下的內容直接貼到 ~/.config/nvim/plugin.vim 裡面裝模組的地方就可以了，說明附在裡面了
注意：我這裡沒有列出 Coc.nvim，因為我把他拉出來到另外一章了
&amp;#34; 彩色的 status bar Plug &amp;#39;itchyny/lightline.vim&amp;#39; &amp;#34; 有這個設定 lightline 在單個 vim 視窗中才會正常，沒錯！vim 也可以分割視窗，後天會講 set laststatus=2 &amp;#34; 在行號左側會顯示這行的 git 狀態，新增、刪除、修改，詳細請看 GitHub README Plug &amp;#39;airblade/vim-gitgutter&amp;#39; &amp;#34; 按下 &amp;lt;F5&amp;gt; 可以開啟檔案樹，按 h 有說明，再一下關掉說明 Plug &amp;#39;scrooloose/nerdtree&amp;#39; nmap &amp;lt;F5&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt; &amp;#34; Exit Vim if NERDTree is the only window left.</description>
    </item>
    
    <item>
      <title>Day 14：vim-plug</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day14/</link>
      <pubDate>Tue, 14 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day14/</guid>
      <description>前面講過了 zsh、tmux 的 plugin manager，vim 一樣有 plguin manager。跟前面幾個 plguin manager 很像，要安裝新的外掛只需要在某個地方加一行設定就好，這樣作的好處是哪天要再建立新的環境時只需要把設定檔帶走，而且集中式的管理可以一目了然。
安裝 vim-plug 記得昨天的 vimrc 最上面有一個備註解起來的區塊嗎？這就是載入 vim-plug 的地方，裡面就有安裝 vim-plug 的指令了。要注意你用的是 neovim 還是 vim，這兩個路徑不一樣
# neovim sh -c &amp;#39;curl -fLo &amp;#34;${XDG_DATA_HOME:-$HOME/.local/share}&amp;#34;/nvim/site/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&amp;#39; # vim sh -c &amp;#39;curl -fLo &amp;#34;${XDG_DATA_HOME:-$HOME/.local/share}&amp;#34;/nvim/site/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&amp;#39; 挑選你的 vim 版本，執行完就安裝好了！
安裝第一個 plugin 我們透過一個範例來說明如何安裝外掛，我們要來裝的第一個外掛是 preservim/nerdcommenter，這個外掛可以快速註解一行/一整段程式碼，這是我覺得比自動補全、語法突顯都還要好用的功能。現在我們來安裝吧！
1. 編輯 vimrc 打開你的 vimrc，把以下內容加在最下面
call plug#begin(&amp;#39;~/.vim/plugged&amp;#39;) call plug#end() 以後所有 plugin 的安裝設定就要放在這兩行裡面
加上 preservim/nerdcommenter 現在在兩個 call 中間插入以下這行
Plug &amp;#39;preservim/nerdcommenter&amp;#39; 然後存檔，這樣就算設定好了</description>
    </item>
    
    <item>
      <title>Day 13：vim 設定檔</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day13/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day13/</guid>
      <description>vim 在啟動時，都會去執行你的設定檔，這個檔案根據你的 vim 軟體不同而改變，如果是一般的 vim，那他會去讀 ~/.vimrc，如果是 neovim(nvim)，他會去找 ~/.config/nvim/init.vim。在接下來的文章中都以 vimrc 代指。
vimrc 內容是 vimscript，也就是所有的冒號命令去掉冒號之後的內容，例如有個命令是 :set nu，這個命令可以開啟行號顯示，如果要寫在 vimrc 裡面，就要寫成 set nu。
vimrc 通常我們會在 vimrc 中設定關於 vim 的外觀、行為、載入外掛等等，接下來是我用多年的 vimrc 的內容，我會一個一個用註解解說他們的用處(雙引號 &amp;quot; 開頭是 vimscript 的註解)
&amp;#34; 打開語法突顯 syntax on &amp;#34; load plguin &amp;#34; install vim-plug: &amp;#34; sh -c &amp;#39;curl -fLo &amp;#34;${XDG_DATA_HOME:-$HOME/.local/share}&amp;#34;/nvim/site/autoload/plug.vim --create-dirs \ &amp;#34; https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&amp;#39; &amp;#34; 這個是明天的東西，先註解掉，才不會出錯 &amp;#34; so ~/.config/nvim/plugin.vim &amp;#34; 256 色 set t_Co=256 &amp;#34; 解決和 tmux 衝突，https://vi.stackexchange.com/questions/238/tmux-is-changing-part-of-the-background-in-vim set t_ut= &amp;#34; 選一個你喜歡的 colorschema &amp;#34; available color schema &amp;#34; blue darkblue default delek desert elflord evening industry koehler &amp;#34; morning murphy pablo peachpuff ron shine slate torte zellner colorscheme koehler &amp;#34; 雜項設定，詳細解說請用 `:help &amp;lt;opeion&amp;gt;`，例如 `:help showcmd` set showcmd set nu set tabstop=4 set shiftwidth=4 set autoindent set nowrap set incsearch set autoindent set cindent set smartindent set cursorline &amp;#34; make lightline work in single screen &amp;#34; https://github.</description>
    </item>
    
    <item>
      <title>Day 12：vim 配色方案</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day12/</link>
      <pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day12/</guid>
      <description>俗話說人要衣裝，佛要金裝，我們的 vim 也得要有漂亮的外觀。今天就讓我們來看看如何調教調整 vim 的外觀吧！
Highlight group highlight group（以下簡稱 hg ）是 vim 中的一個概念，他會對應到 vim 畫面中的一段區塊，可能是一段文字，也可能是底下的 status bar 或是左側的行號。每一個 hg 都可以設定樣式，包括前景色、背景色、反白、加底線等等，你可以用 :so $VIMRUNTIME/syntax/hitest.vim 命令查看所有的 hg 名字，他們的樣式也會直接顯示出來。
如果想看某個 hg 的說明的話（必須是內建的才有），可以用 :help hl-hgName 來查詢說明，例如 CursorLine 就可以用 :help hl-CursorLine 來看說明
Highlight 用 :highlight 或是縮寫 :hi 可以設定特定 hg 的樣式
hi hgName arg=value arg=value...... hgName 就是你用 :so $VIMRUNTIME/syntax/hitest.vim 查出來的名字，而 arg 常見的有前景色 ctermfg、背景色 ctermbg 和 樣式 cterm
Color ctermbg 和 ctermfg 後面接的值會根據你的終端機支援的顏色不同而有變化，其中 8 色和 16 色的終端機都可以用 0 ~ 8 / 0 ~ 16 這樣的方式來表示顏色（數字代表的顏色要看終端機設定），vim help 提供了一個對照表可以參考各個數字代表的顏色</description>
    </item>
    
    <item>
      <title>Day 11：批次修改！！</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day11/</link>
      <pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day11/</guid>
      <description>昨天體驗了一些快捷鍵和命令，今天要講的是在 vim 中也很常用的搜尋與取代
搜尋與取代 vim 的搜尋與取代是由命令 s 達成的，命令格式長這樣
:[範圍修飾字]s/abcd/efgh/[旗標] 其中 abcd 是 正規表達式（regular expression，縮寫 regex，在中國常寫成「正則」），regex 除了在 vim 可以用之外，幾乎所有程式語言都可以用，還有 grep、sed 等 linux 指令也都是使用 regex，關於 regex 的用法在這裡就不多提了，MDN 上有很完整的解釋
你應該有注意到上面的命令格式裡面除了正規表達式之外還有「範圍修飾字」和「旗標」，這就是接下來這段的重點啦！
範圍修飾字 這個東西也不只是搜尋與取代可以用，只要你覺得需要限制某個指令的作用範圍都可以用樣的邏輯接下去
範圍修飾可寫可不寫，如果不寫的話搜尋與取代就只會在游標在的那一行起作用，加上百分比符號 % 代表作用範圍是整份文件，也可以加上行號代表只作用在某一行，如果是兩個行號中間以逗號隔開，代表是作用在這兩個行號之間
範圍修飾字範例 範圍選取 剛剛的範例中有出現用行號作範圍選取，其實範圍選取還有一個更簡單的方式 ——「選取模式」。選取模式和編輯模式、命令模式是同等地位的東西，進入選取模式的快捷鍵有下列幾個（一樣要進到命令模式才能進選取模式） 快捷鍵 說明 v 一般選取，以「字」為單位 S-v(大寫 v ) 一般選取，以「行」為單位 C-v 垂直選取，這個比較不常用，但是需要的時候蠻好用的 選取後一樣可以打指令和快捷鍵，但是這些就只會作用在選取的範圍內，常常搭配的有 d（剪下）、y（複製）、:s（搜尋與取代）
再把一個範圍選取起來後，如果是快捷鍵就直接按，如果是命令的話按下冒號 :，平常只有冒號的命令行會先出現 :&#39;&amp;lt;,&#39;&amp;gt;，這串東東代表的就是這一個範圍的範圍修飾字，不用刪掉，直打指令就可以了
選取結合指令與快捷鍵 旗標 旗標這個東西主要是在控制搜尋的行為，例如全部取代、取代前先問一下之類的，多個旗標可以組合，不管順序，下面是幾個可能會用到的旗標 旗標 說明 g 整行搜尋，如果不加的話只會取代第一個 c 在取代前先確認 i 忽略大小寫 旗標範例 結尾 這兩天講的大部份是操作性質的東西，不需要一次全部記起來，用的多了自然會記得，現在只需要先有個印象就可以了。其實 vim 很多操作、快捷鍵都很直覺，不妨自己多試試看加了 Shift、CTRL 之後原本的快捷鍵會有什麼變化
vim 的操作還有很多技巧，如果有興趣不妨去看看 vim 的文件（用命令 :help ）中相關章節（大概是 usr_03~04 左右）的介紹，你會對 vim 有非常全面的認識。雖然文件是英文寫的，但是並沒有太難的單字，大概國中程度就可以看了</description>
    </item>
    
    <item>
      <title>Day 10：新手殺，誰來教我離開 vim 阿～～</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day10/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day10/</guid>
      <description>前面 9 天都在介紹操作環境，今天終於要進到編輯器啦！我選用的編輯器是 nvim，但是如果你要用 vim 8 也是可以，因為這兩者之間幾乎沒什麼差別，只是你要注意這兩者的設定檔位置不同，目錄需要你自己轉換。唯一不同的點大概是 nvim 內建支援用 lua（一種程式語言）寫外掛，vim 8 只能用 vimscript。關於兩者之間的愛恨情仇請參考這裡，他講的非常詳細
接下來的文章可能會出現 vim、nvim 混用，但是他們都是指 neovim，也就是我們用的這個編輯器，不用特別跑去裝兩套軟體
安裝 nvim 基本上你的電腦的套件管理器裡面應該都有 nvim 了，但是他的名字可能不是 nvim，例如 apt 就是 neovim，如果你的套件管理器沒有收錄 nvim 或是你不知道該怎麼辦的話，可以看看這個文章 幾乎所有作業系統他都有介紹怎麼安裝了，當然他也有教你如何自己 build。
操作 vim 的前身—— vi 誕生於幾乎沒有圖形化界面的時候，那時候也沒有滑鼠，所以所有的操作都必須在鍵盤上達成，今天就來認識一些簡單的命令吧！
離開 vim 為什麼要在還沒進入 vim 之前就教如何離開呢？ 因為幾乎所有初學者都會有這個疑問，要怎麼離開 vim 啦！！ 這邊我提供一個必勝的方法，不論你在 vim 做了什麼操作，ESC 狂按個 100 次三到四次，然後輸入 :q!ENTER 就會離開了。
命令模式？編輯模式？ vim 的「模式」也是讓初學者很困擾的東西之一，下面用一張圖來解釋他們的關係
vim 模式切換 (From: 高見龍——超簡明 Vim 操作介紹) 通常 Normal Mode 中文是 「命令模式」 ，顧名思義這個模式下你可以打命令，Insert Mode 的中文是 「編輯模式」 ，在這個模式你可以編輯你的檔案。</description>
    </item>
    
    <item>
      <title>Day 09：今天又想不出標題了！tmux plugin 和 mouse mode</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day09/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day09/</guid>
      <description>tmux 本身已經是個非常完善的軟體了，因此我只選了一個外掛，tmux-resurrect 這個外掛讓你可以儲存目前的 tmux 版面配置（分頁、螢幕切割、名稱等等），在下次啟動時復原，這個功能在開發專案要切分編輯、編譯、測試版面時很好用，不需要每次開機都重新切版面
安裝 我們之前已經安裝過 tmp 了，現在我們只需要在 ~/.tmux.conf 中新增一行
+ set -g @plugin &amp;#39;tmux-plugins/tmux-resurrect&amp;#39; 接下來執行 tmux source ~/.tmux.conf 載入最新的設定檔，再來用快捷鍵 CTRLa + i 安裝
使用 切好版面後，按 CTRLa + s （save）儲存目前狀態，除了版面配置，每個 session 的工作路徑也會儲存，vim 開啟的檔案下次開啟有機會會幫你開，但是可能會遇到暫存檔的問題，所以我建議是儲存狀態時把 vim 關掉
下次要使用時，用 CTRLa + r （restore）恢復
更多外掛 在 https://github.com/tmux-plugins/list 有更多外掛，主要內容包括系統資訊顯示、複製貼上、搜尋，我個人覺得沒有重要到須要特別提出來介紹，就不一一介紹
更多 tmux 寫完今天的內容後我發現，內容好像有點少，於是就補充了一些 tmux 的東西
列出所有快捷鍵 tmux 的快捷非常方便，但是有時候真的想不起來某個功能怎麼按，這時候你可以用 tmux list-kyes 或是比較短的 tmux lsk 看看什麼按鍵對應到什麼功能。
有時候進來看看有什麼方便的快捷鍵自己還不知道也挺好玩的
滑鼠控制 不知道昨天的各種 tmux 移動、調整大小的快捷鍵有沒有嚇到你。tmux 其實還有提供一個更簡單的操作方式，如果你的終端機有支援滑鼠的話（像是我用的 gnome-terminal 就有提供）你可以在 ~/.tmux.conf 中加上一行
+ set -g mouse on 然後重新開啟 tmux，這時候你就可以用滑鼠換頁、切換分割畫面、調整大小等等操作，在不同的地方按右鍵還會有不同的功能呦！</description>
    </item>
    
    <item>
      <title>Day 08：八爪章魚之 tmux 快捷鍵</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day08/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day08/</guid>
      <description>tmux 有許多的快捷鍵來控制螢幕，不論是分割、移動都可以輕鬆完成
分割畫面 垂直分割畫面的快捷鍵是 CTRLa + %，水平分割的快捷鍵是 CTRLa + |(pipe，shift + enter 上面那個)。按下去畫面就會以中間分開，兩邊都是獨立的，即使一邊在編譯卡住了，另一邊的編輯器還是可以正常操作的 分割畫面，一邊編輯，一邊編譯，另一邊執行 在分割畫面中移動 現在你畫面分割好了，要怎麼移動呢？非常直覺，往上就是上，往右就是右。CTRLa + 方向鍵
你也可以用 CTRLa + tab 按照順序移動，CTRLa + SHIFTtab 反向移動
記得，按方向鍵時 CTRL 要放開，不然就會變接下來要介紹的快捷鍵
在分割畫面中移動 調整分割大小 有時候我們不一定是要分成一半，例如下面五行，上面滿版。這時候你可以用 CTRLa + CTRL方向鍵 調整大小 調整大小 新增分頁 你有沒有發現終端機最下面那行？那個是 tmux 的分頁，用 CTRLa + c 就可以新增一個分頁，新增順序會從 0 開始找空的補上
範例和分頁移動一起
分頁移動 在多個分頁中，你可以用 CTRLa + CTRLa 移動到上一次使用的分頁，或是用 CTRLa + 數字鍵 移動到特定 ID 的分頁。
新增分頁、在分頁間移動 結論 今天的內容比較偏操作，自己多試試就會熟悉了。掌握 tmux 之後你會發現你根本不需要開一堆終端機視窗，一個就夠用了。</description>
    </item>
    
    <item>
      <title>Day 07：整合 tmux 和 zsh</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day07/</link>
      <pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day07/</guid>
      <description>昨天的結尾提到要整合 tmux 和 zsh 不是在 ~/.zshrc 結尾執行 tmux 這麼簡單，今天就讓我們看看會遇到什麼問題吧！
直接執行 tmux 在正式開始前，先讓我們看看直接在 ~/.zshrc 後面執行 tmux 會發生什麼錯誤
直接執行 tmux 嗯，錯誤訊息說要 unset $TMUX 那我們就照作吧！
加上 unset TMUX，嗯，爆炸了！ 分析問題 可以看到，如果直接執行 tmux 的話總是會跳出一個錯誤 sessions should be nested with care, unset $TMUX to force，這段訊息告訴我們，不能建立巢狀 tmux，除非將 $TMUX 環境變數移除。欸？我們不是只執行一次 tmux 嗎？為什麼會他說我們建立巢狀 tmux？我們來看看登入之後發生了什麼事：
執行 zsh（因為我們的 default shell 是 zsh） zsh 執行 ~/.zshrc，初始化終端機後執行 tmux tmux 開啟了新的 session，執行 default shell ~/.zshrc 又被執行一次，tmux 被執行第二次 如果你沒有 unset TMUX，那 tmux 就會停下來並印出錯誤訊息，你總共得到兩層 tmux
如果你 unset TMUX，就是告訴 tmux 不管巢狀限制，就會回到第三步，你等越久會得到越多 tmux 看來問題在於 tmux 和 zsh 執行的迴圈停不下來，那我們就在執行 tmux 之前作個條件判斷，$TMUX 為空再執行 tmux 好了</description>
    </item>
    
    <item>
      <title>Day 06：螢幕切八段！多開神器 tmux</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day06/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day06/</guid>
      <description>今天起要介紹的是 tmux，這是一個終端機的 session 管理器，什麼是 session 呢？你可以把 session 理解為一個終端機（畫面）和主機 （你的電腦）的連線，tmux 做的事就是把一個終端機切分成多個終端機，白話說就是多開神器啦！這樣你就可以左邊編輯程式、右邊看執行結果（如圖）。而且一切操作都在一個終端機視窗裡面，這意味著即使你在沒有圖形界面的純文字模式（像是 single user mode、ssh 連線）也可以享受如同圖形界面的便利！
tmux demo 安裝 debian/ubuntu $ apt install tmux macOS $ brew install tmux 其他 or 自己編譯 其他可以參考 https://github.com/tmux/tmux/wiki/Installing 的說明
config tmux 啟動時會去讀取 ~/.tmux.conf 這個檔案，所以的設定檔都放在這，在這裡，我推薦一個我用很多年的設定檔，點擊這裡下載，或是執行以下命令
curl https://gist.githubusercontent.com/simba-fs/e06a1763c1967ce3f4b5ef643db5e0b3/raw/2f28c62d01f419a390bfc0e66a974985bacdefa5/.tmux.conf &amp;gt; ~/.tmux.conf 這個檔案是我從網路上找到的，後來有加一些自己的東西，把檔案下載下來並存到 ~/.tmux.conf 裡面，關於每一行的用途都有用註解標示，主要幾個改變有以下幾點：
把前置按鍵（prefix）從 Ctrlb 改成 Ctrla (第 16 ~ 19 行，不喜歡的話可以拿掉)，你也可以改成其他按鍵 底部 status bar 變成彩色，不再是單調的綠色 一些快捷鍵綁定 啟動 暫時我們不加入開啟終端機自動啟動 tmux，手動啟動方式是在終端機執行命令
tmux 這時候你會看到終端機最上面跳出一個錯誤訊息
~/.tmux/plugins/tpm/tpm&amp;#39; returned 127 這是因為我們還沒裝 tmux 的外掛管理器 tmp (是 tmux plugins mamager，不是最近 win 11 的 tpm 2.</description>
    </item>
    
    <item>
      <title>Day 05：是說，這個選項可以接什麼東西？autocomplete 與 auto-pair</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day05/</link>
      <pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day05/</guid>
      <description>今天會介紹兩個開箱即用（ out of box ）的外掛和簡化指令的 alias
zsh-autocomplete 在 CLI 下指令時，有時候會忘記選項叫什麼、檔名中的 k 到底是大寫還是小寫，這時候 autocomplete 就很好用，他會幫我們選出接下來可以填的字，像是選項、子命令、檔名等等。
❓ &amp;gt; autocomplete 和 autosuggestion 有什麼不同？會同衝突嗎？ 前者是從 completion function 中找建議，後者是從以前下過的指令中找建議，兩者不會衝突 安裝 autocomplete 托 zplug 的福，我們只需要修改 ~/.zshrc 就可以安裝外掛了。在 ~/.zshrc 中新增以下設定
+ zplug &amp;#39;marlonrichert/zsh-autocomplete&amp;#39; 然後重新開啟終端機並安裝新增的外掛就可以了
你會發現你現在打指令，下面都會出現一些可能可以選的選項，例如同樣開頭的指令、檔名。
在 https://github.com/marlonrichert/zsh-autocomplete 有快捷鍵教學
設定 這段是我在寫完第一版後新增了，所以在 純‧ CLI 整合開發環境 是沒有的
為了可以爽爽的用 autocomplete，我新增了一些設定，這些放到 ~/.zshrc 裡面隨便一個地方就可以了
# case sensitive zstyle &amp;#39;:completion:*&amp;#39; matcher-list &amp;#39;&amp;#39; &amp;#39;m:{a-zA-Z}={A-Za-z}&amp;#39; &amp;#39;r:|[._-]=* r:|=*&amp;#39; &amp;#39;l:|=* r:|=*&amp;#39; # zsh-autocomplete configure # Down arrow: bindkey &amp;#39;\e[B&amp;#39; down-line-or-select bindkey &amp;#39;\eOB&amp;#39; down-line-or-select # down-line-or-select: Open completion menu.</description>
    </item>
    
    <item>
      <title>Day 04：金魚記憶力太短暫，交給外掛記吧！autosuggestions 與 sugstring-search</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day04/</link>
      <pubDate>Sat, 04 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day04/</guid>
      <description>今天的內容會比平常多，但是非常紮實！
有時候我們在 CLI 操作時遇到很多重複的指令，像是 git add、git commit -m &#39;ba la ba la&#39; 等等，這些指令可能又長又複雜，一直都是自己打也不是辦法，這時候就該請出 autosuggestions 了
安裝 autosuggestions 老樣子，安裝外掛只須要修改 ~/.zshrc 就可以了
# plugins zplug &amp;#39;romkatv/powerlevel10k&amp;#39;, as:theme, depth:1 + zplug &amp;#39;zsh-users/zsh-autosuggestions&amp;#39; 因為 autosuggestions 是外掛，不需要特別寫 tag 了
[問題]好像有奇怪的字跑出來？ 寫好之後重開終端機，按下 enter 你可能會發現跳出了一堆東西，這是因為你開啟了 p10k 的 Instant Prompt Mode，這個雖然會讓你的終端機跑起來比較順（官方說的，我感覺不出來），但是在 zsh 載入完成之前就不能有任何字輸出。
可是你看看，如果我們新增了一個外掛，zplug 會跳出來問我們是否要安裝，這時後 Instant Prompt Mode 就出來抱怨了。
這個問題的解決方法直覺上有兩個，一是關掉 Instant Prompt Mode，二是讓 zplug 先不要吵
關掉 Instant Prompt Mode 關掉 Instant Prompt Mode 很簡單，重新設定一次 p10k 就好了，在設定程式問你是否要開啟 p10k 時選擇 (3) Off，這樣下次安裝外掛就不會有奇怪的警告訊息跳出來了。</description>
    </item>
    
    <item>
      <title>Day 03：轉吧轉吧七彩霓虹燈之 p10k</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day03/</link>
      <pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day03/</guid>
      <description>昨天裝好外掛管理器了，接下來我們要用 zplug 來裝一些好玩的外掛囉！
p10k p10k 是 powerlevel10k 的縮寫，這是一套 zsh 的 prompt 主題，是我用過設定最簡單效果也很好的，重點是不論有沒有裝特殊字型，他都可以用！
安裝字型（可跳過） p10k 官方推薦 nerd font，這是一個給開發者的字型集，包括各種程式語言、網路服務的 icon 等等。p10k 官方也有提供修改過專門給 p10k 的字型檔連結裡有各種終端機模擬器的字型安裝教學（英文）。
其實如果你只想要部份 icon，只要把 ttf 檔放在 ~/.fonts 下就可以了，不需要改終端機字型，他找不到時會去抓（我自己試是可以的，系統 ubuntu 20.04、terminal: gnome-terminal ）
如果你想要在 CLI 有各種 icon 的話你才需要安裝上述字型，如果不需要可以跳到下一小節
安裝 p10k p10k 說到底只是一個外掛，所以我們可以透過 zplug 安裝，打開 ~/.zshrc，在 # plugins 那行下面加上以下設定
# plugins + zplug &amp;#39;romkatv/powerlevel10k&amp;#39;, as:theme, depth:1 關於這段是什麼意思呢，zplug 提供了一張精美的圖來幫助我們理解
首先，以 zplug 開頭，然後接 github 的 username/reponame，再來可以用 tag 做修飾，例如我們安裝 p10k 時就用了 as:theme 和 depth:1 ，兩個 tag 之間以逗號加上一個以上的空白隔開</description>
    </item>
    
    <item>
      <title>Day 02 ：zsh 與 shell script</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day02/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day02/</guid>
      <description>今天內容不小心寫太長了 &amp;hellip;&amp;hellip;
首先，在介紹其他軟體之前，先來看看與 CLI 操作習習相關的「shell」，我選擇的 shell 是 zsh，zsh 在 bash 的基礎上擴充了很多實用的功能，像是支援更好的自動補全，各式各樣的主題等等。
zsh 安裝 如果你的作業系統是 debian 系列的話，可以直接用 apt 安裝 apt install zsh。其他的 linux 發行版可以到 這個網頁找找你的發行版
如果是 mac，理論上你的 shell 應該已經是 zsh 了（ mac 的 shell 從 2019 開始預設是 zsh ），如果不是的話你可以用 homebrew 安裝 brew install zsh。
如果是 windows 的話，建議你開啟 WSL2 或是找一台有 linux/mac 的電腦
現在我們可以透過這個指令檢查是否安裝成功
zsh --version 如果沒有錯誤就是安裝成功了
❓ &amp;gt; 現在用的是什麼 shell？ 你可以使用 echo $SHELL 來看你現在使用的 shell 是那一個 更換 shell 如果你之前的 shell 不是 zsh 那就要更換預設 shell，用以下指令可以更換</description>
    </item>
    
    <item>
      <title>Day 01：前言，這批很純，快進來吧！</title>
      <link>https://blog.simbafs.cc/posts/ithelp/day01/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/ithelp/day01/</guid>
      <description>Who Am I 我今年升大一，在此生最長的假期中寫寫文章打發時間。平常喜歡寫寫程式，研究新技術。是個 CLI 忠實擁護者，電腦通常只開瀏覽器和 terminal，terminal 就是我的開發環境。
慣用網名是 simba-fs、simbafs 或 SimbaFs。
略懂 nodejs 和一點網頁技術，這一個月開始研究 Golang
關於這個系列 為什麼寫這個系列 現代化 IDE 提供的各種功能給我們很好的開發體驗，尤其是當程式碼數量逐漸增加時，IDE 可以提供像是自動補全、型態提示等等。當 lsp(language server protocol) 開始流行之後，甚至不太需要查文件就能知道一個未知函數的用法。但是在這一切的方便的背後是犧牲有限的電腦資源換來的。這個時候資源需求少、發展越來越完善的的純文字界面就是解決這個問題的最佳方法了！不僅不會減少該有的語法突顯、自動補全，甚至可以借助 ssh 的力量，在任何裝置上開發（只要支援 ssh 都可以）。但是可惜的是網路上這方面的資源都很零散，於是我想說趁這次參賽將我所學整理起來。這個系列會帶領讀者一步一步建立一個好用、方便的 CLI 開發環境，如果有時間會講一下如何在任何裝置上開發（當然螢幕太小不適合啦）。
五種文字編輯器開啟一個約 60 byte 的文字檔所消耗的記憶體（KB) From https://medium.com/commitlog/why-i-still-use-vim-67afd76b4db6 這個系列在講什麼 以下是預計的寫作進度，中途可能會更改，我也會每天在這裡更新連結
Day 01: 簡介 Day 02 ~ 05: zsh Day 06 ~ 09: tmux Day 10 ~ 21: nvim Day 22 ~ 26: other tools Day 29 ~ 30: coding everywhere 仙貝先備（軟體） 最重要的，一個支援至少 8 色的、你用的順手的終端機模擬器，最好是可以自行安裝字體的。</description>
    </item>
    
    <item>
      <title>Golang Parse All Files In Directory Into Templates</title>
      <link>https://blog.simbafs.cc/posts/golang/golang-parse-all-files-in-directory-into-templates/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/golang/golang-parse-all-files-in-directory-into-templates/</guid>
      <description>在用 gin 寫伺服器的時候，我發現模板並不會被 go build 打包進執行檔裡面，所以在執行的時候就找不到檔案，當然這個問題可以用字串的形式直接把模板放進 golang 原始碼裡面，但是這樣程式碼一複雜就會不好用，這時候就可以用 golang 的 embed 函式庫把檔案「嵌入」到原始碼裡面。但是問題又來了，嵌入了之後要怎麼把字串變成模板物件呢？
Embed embed 套件是 1.16 新出的功能，所以如果想用的話記得要更新 go 到 1.16 以上
embed 嵌入檔案的方式是透過特殊格式的註解宣告，直接看官方範例：
package main import ( &amp;#34;embed&amp;#34; ) //go:embed hello.txt var s string //go:embed hello.txt var b []byte //go:embed hello.txt var f embed.FS func main() { print(s) print(string(b)) data, _ := f.ReadFile(&amp;#34;hello.txt&amp;#34;) print(string(data)) } 可以看到，embed 可以把檔案讀成三種格式 string、[]byte、embed.FS，前兩者只能讀「一個」檔案，如果你只用這兩個的話引入時要用 _ &amp;quot;embed&amp;quot;。embed.FS 除了可以嵌入多個檔案之外，因為實做了 fs.FS 所以可以使用當作一個檔案系統操作。
Tmeplate No Recursive 最簡單的方法，你可以直接使用
// go:embed view/* var f embed.</description>
    </item>
    
    <item>
      <title>ssh on gitea with docker</title>
      <link>https://blog.simbafs.cc/posts/linux/server/ssh-on-gitea-with-docker/</link>
      <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/server/ssh-on-gitea-with-docker/</guid>
      <description>Gitea 是一個開源的 git 伺服器，他的界面幾乎和 GitHub 一模一樣，但是完全開源而且非常輕，甚至一片樹梅派就可以開伺服器了。Gitea 因為是使用 Golang 編寫的，所以提供各種平台的執行檔。我選擇透過 docker 裝 Gitea 伺服器，但是這樣有一個問題，gitea 伺服器開在 container 內，沒辦法使用標準的 22 port，所以 git clone 就必須加上一個醜醜的數字，像是這樣
git clone git@domain:10022:user/repo.git 這個問題 Gitea 官方已經有提供完整的教學了，但是是英文版，我這篇文章是我讀完消化過後的中文版教學
容器 ssh 穿透 因為 Gitea 的 ssh 是跑在容器裡，我沒辦法讓他和 host 共用 22 port，所以要透過 host 「轉發」連線。
1. 建立 git 使用者 先在 host 建立一個名叫 git 的使用者，因為這個帳號會被對應到容器內的 git 使用者，所以要有一樣的 UID, GID
sudo adduser git grep git /etc/passwd 記好 git 的 UID 和 GID
git:x:1002:1002:,,,:/home/git:/bin/bash ------^^^^ ^^^^ ------GID UID 2.</description>
    </item>
    
    <item>
      <title>taiwan-town-location</title>
      <link>https://blog.simbafs.cc/posts/other/taiwan-town-location/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/other/taiwan-town-location/</guid>
      <description>這是一個給經緯度吐地址的 api，甚至路段都會出來，搭配 web geolocation api 蠻不錯的，精確度不錯。可以不知道有沒有 rate limited 的問題，目前看起來連 token 都不用。
網址 https://api.nlsc.gov.tw/other/TownVillagePointQuery/
用法 https://api.nlsc.gov.tw/other/TownVillagePointQuery/經度/緯度
舉例： request GET https://api.nlsc.gov.tw/other/TownVillagePointQuery/121.46278679999999/25.0169826 response &amp;lt;townVillageItem&amp;gt; &amp;lt;ctyCode&amp;gt;F&amp;lt;/ctyCode&amp;gt; &amp;lt;ctyName&amp;gt;新北市&amp;lt;/ctyName&amp;gt; &amp;lt;townCode&amp;gt;F14&amp;lt;/townCode&amp;gt; &amp;lt;townName&amp;gt;板橋區&amp;lt;/townName&amp;gt; &amp;lt;officeCode&amp;gt;FA&amp;lt;/officeCode&amp;gt; &amp;lt;officeName&amp;gt;板橋&amp;lt;/officeName&amp;gt; &amp;lt;sectCode&amp;gt;0008&amp;lt;/sectCode&amp;gt; &amp;lt;sectName&amp;gt;民權段&amp;lt;/sectName&amp;gt; &amp;lt;villageCode&amp;gt;65000010020&amp;lt;/villageCode&amp;gt; &amp;lt;villageName&amp;gt;漢生里&amp;lt;/villageName&amp;gt; &amp;lt;/townVillageItem&amp;gt; 參考資料 https://data.gov.tw/dataset/101898</description>
    </item>
    
    <item>
      <title>Cast Phone Screen to Computer</title>
      <link>https://blog.simbafs.cc/posts/linux/cast-phone-screen-to-computer/</link>
      <pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/cast-phone-screen-to-computer/</guid>
      <description>有沒有一種經驗是某的應用程式手機板操作勉強算順暢，但是一電腦上就炸開，反應慢到靠北、界面又很難用（沒錯 messenger 我正在看著你）。這個時候相信你會和我一樣想把手機畫面投影到電腦上的一個視窗裡面，最好可以互動、可以打字。有人第一個想法是在手機開 VNC 伺服器，但是這個方法有點麻煩，這篇文章介紹的是目前我覺得最佳解決方案。
SCRCPY 這個軟體支援有線（ USB debug ）、無線（ WIFI ）的連接，還支援螢幕錄影和傳檔案。最重要的是，開在電腦上的視窗可以調整大小，不需要侷限在一個小小的視窗內，你最大可以放大到全螢幕！在某種意義上你獲得了一台和電腦一樣大的手機。
Installation 安裝流程意外的簡單，只需要用 apt 就可以安裝了，或是你可以自己 build，稍微看了一下 說明 ，看起來不困難，但是既然 apt 就可以安裝了我們就省一點時間
$ sudo apt install scrcpy USB debug 首先無論是有線無線都要先打開手機的 USB debug 選項，在開發人員選項裡面，詳細步驟請看 官方文件。
USB 如果不介意有一條線插著~~（順便充電）~~的話，投影畫面非常簡單，只有兩個步驟：
插上 USB 並且無論跳出什麼都按「同意」「OK」 打開終端機，執行 scrcpy 然後就會有一個視窗跳出來，你現在就可以在電腦上滑手機了！ Wireless 無線的話比較麻煩，首先是必須要可以連線，看是在同一個區域網路或是 VPN、ssh tunnel 都可以。再來是因為連線設定頗麻煩，所以我把相關的步驟寫成一個 script，下載後給予執行權限就可以執行了（當然要安裝 scrcpy ）。有線的方式一樣很簡單，不用加任何選項就可以連接了。
如果要啟用無線，只需要加上 -w 選項（用預設的 ip 192.168.43.1)
如果 ip 不是預設的話，可以加上 -i IP 來指定其他的 ip
加上 -f 可以開啟全螢幕
參連連結 https://github.com/Genymobile/scrcpy https://developer.android.com/studio/debug/dev-options https://gist.github.com/simba-fs/9132289f63368ad325d6a2ef62be7a20</description>
    </item>
    
    <item>
      <title>YouComopleteMe install</title>
      <link>https://blog.simbafs.cc/posts/linux/vim/youcomopleteme-install/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/vim/youcomopleteme-install/</guid>
      <description>下載 source code 編輯 ~/.vimrc Plug &amp;#39;Valloric/YouCompleteMe&amp;#39; 接著按下 esc :w | so % 載入設定 接著 :PlugInstall 下載 source code 存檔離開 編譯 執行 sudo apt install python3-dev build-essential 進入 ~/.vim/plugged/YouCompleteMe 執行 ./install.py --help 並挑選需要的選項 執行 ./install.py &amp;lt;你要的選項&amp;gt; </description>
    </item>
    
    <item>
      <title>firefox touch screen scroll</title>
      <link>https://blog.simbafs.cc/posts/linux/firefox-touch-screen-scroll/</link>
      <pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/firefox-touch-screen-scroll/</guid>
      <description>再換了觸控筆電後，在 firefox 一直有個問題：觸控往下滑會被當成選取，要卷動一定要用右邊的 scroll bar
解決方案 按照 https://askubuntu.com/questions/853910/ubuntu-16-and-touchscreen-scrolling-in-firefox 的最佳解法，真的加上 MOZ_USE_XINPUT2=1 的環境變數就可以了。
另外在設定 ~/.local/share/applications/firefox.desktop 的時候要注意有不只一個 Exec，改完如果沒有生效可以重開機看看。</description>
    </item>
    
    <item>
      <title>beginning of kotlin</title>
      <link>https://blog.simbafs.cc/posts/kotlin/beginning-of-kotlin/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/kotlin/beginning-of-kotlin/</guid>
      <description>val vs var kotlin JS val const var let a..b kotlin JS a..b Array(b-a+1).fill(0).map(i =&amp;gt; i + a) when kotlin fun main (){ val luckyNum = 4 val yourNum = (1..6).random() val result = when(yourNum){ luckyNum -&amp;gt; &amp;#34;You get the lucky num ${luckyNum}&amp;#34; 1 -&amp;gt; &amp;#34;Sorry, you get 1&amp;#34; 2 -&amp;gt; &amp;#34;Sorry, you get 2&amp;#34; 3 -&amp;gt; &amp;#34;Sorry, you get 3&amp;#34; 4 -&amp;gt; &amp;#34;Sorry, you get 4&amp;#34; 5 -&amp;gt; &amp;#34;Sorry, you get 5&amp;#34; 6 -&amp;gt; &amp;#34;Sorry, you get 6&amp;#34; else -&amp;gt; &amp;#34;Sorry, you get a number out of 1.</description>
    </item>
    
    <item>
      <title>college-exam-interview-and-written-test</title>
      <link>https://blog.simbafs.cc/posts/other/college-exam-interview-and-written-test/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/other/college-exam-interview-and-written-test/</guid>
      <description>師大科技系面試 兩關各十分鐘
第一關： 自我介紹 一分鐘補充說明（有利備審、競賽）解決問題的經驗 自由談話時間 第二關： 自我介紹一分鐘 科技系分幾組？差別在哪？你會選哪組？ 我看你的自傳有寫「專案開發」，有例子嗎？ 如果團隊合作時有人擺爛，你會怎麼做？（20秒） 心得 這個系是團體面試，三個教授對三個考生，輪流回答問題，因為我是那組第一個，所以幾乎都是我先回答，教授沒有問什麼很難得問題，另外系主任看起來人很好。</description>
    </item>
    
    <item>
      <title>logitech-mouse-permission-error</title>
      <link>https://blog.simbafs.cc/posts/linux/logitech-mouse-permission-error/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/logitech-mouse-permission-error/</guid>
      <description>前言 我的無線華和滑鼠和鍵盤都是羅技的，在我的 Ubuntu 筆電上一直都沒有問題。有一次我想改我的鍵盤被配置，但是因為 logitech unifying 沒有 Linux 版，所以我另一個軟體叫 solaar，功能是差不多的。 當我裝好軟體以後，鍵盤滑鼠操作都沒問題，只有插上滑鼠的接收器以後都對跳出一個 permission error 的錯誤視窗。雖然在 solaar 裡面就無法看到我的滑鼠就是了，但是完全不影響使用，所以我就擺在那邊放它爛，反正就是多按一個叉叉。
嘗試自己解 今天閒閒沒事做剛好來看看這個怎麼解。我一開始想說，把他的 permission 改成和鍵盤一樣就啦！於是我進行了下面的操作
$ ls /dev/hidraw* 拔下鍵盤的接收器，發現他是 /dev/hidraw4 和 /dev/hidraw5，再插上去。拔下滑鼠接收器，發現他是 /dev/hidraw2。
並找到鍵盤的權限是 rw-rw----，滑鼠是 rw-------。
$ chmod 660 /dev/hidraw2 拔下滑鼠接收器，插上。
沒用。
我猜這個方法會失敗應該是因為他在我改之前就已經先跳錯誤了，等我改完它右沒有偵測，我就得把它拔下來在插上去，我又會看到錯誤訊息&amp;hellip;&amp;hellip; (looping
於是我上網找答案
網路上的解 我 Google ubuntu logitech permission error 第一個就是我要的！</description>
    </item>
    
    <item>
      <title>libreoffice-code-format-plugin-install</title>
      <link>https://blog.simbafs.cc/posts/linux/libreoffice-code-format-plugin-install/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/libreoffice-code-format-plugin-install/</guid>
      <description>安裝 去 https://extensions.libreoffice.org/en/extensions/show/code-highlighter 下載最新的外掛 把檔名前面的前綴刪掉， 例如：ea4db15f_codehighlighter.oxt -&amp;gt; codehighlighter.oxt
安裝相依性套件 sudo apt install libreoffice-script-provider-python python3-pip sudo pip3 install pygments 安裝外掛 工具 &amp;gt; 擴充套件管理員 &amp;gt; 加入 &amp;gt; 選擇你的檔案
使用 插入文字方塊 插入 &amp;gt; 文字方塊
貼上程式碼 選擇文字方塊，不是文字（按文字方塊的邊邊） format 工具 &amp;gt; highlight code &amp;gt; 選得語言、style
參考資料 Libreoffice extensions issue</description>
    </item>
    
    <item>
      <title>strapi-quick-start</title>
      <link>https://blog.simbafs.cc/posts/nodejs/strapi-quick-start/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/strapi-quick-start/</guid>
      <description>strapi 是一個 headless CMS (content management system)，透過 web 介面就可以建立一個 api server
strapi 什麼是 headless CMS headless CMS 顧名思義是「無頭的 內容管理系統」，意思是沒有前端、只有後端，它就是一個 DB 的 web 界面 + api server。headless CMS 專注於處理 api 的部份，前端的部份一律不關心。這對於前後端分離有很大的幫助，基本上 headless CMS 已經解決了後端 80% 的工作，剩下的就是一些客製化的邏輯，像是登入、特殊的計算等等。
strapi 的優點 他的界面完善 支援多種 DB MySQL &amp;gt;= 5.6
MariaDB &amp;gt;= 10.1
PostgreSQL &amp;gt;= 10
SQLite &amp;gt;= 3
MongoDB &amp;gt;= 3.6
存取權限控制 外掛 quickstart 以下步驟是補充 官網的 quick start
安裝
$ npx create-strapi-app my-project --quickstart; cd my-project</description>
    </item>
    
    <item>
      <title>node-vm</title>
      <link>https://blog.simbafs.cc/posts/nodejs/node-vm/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/node-vm/</guid>
      <description>node.js VM 模組 VM 是 node.js 的核心模組，提供安全的環境 (沙箱) 來測試不信任的程式碼。
基本概念 在 VM 模組裡面，有兩個基本的物件，script 和 context。script 是經過「編譯」程式，context 是給在沙箱裡面的程式碼的全域物件 (global) 。沙箱中的程式只能存取透過 context 指定的物件。
建立 script VM 模組提供 Script 建構子，可以透過他來建立 Script 物件。
const vm = require(&amp;#39;vm&amp;#39;); const script = new vm.Script(&amp;#39;i++&amp;#39;); 也可以用 vm.createScript
const vm = require(&amp;#39;vm&amp;#39;); const script = vm.createScript(&amp;#39;i++&amp;#39;); vm.Script
vm.createScript 在 nodejs docs 上我沒有找到，但是我在自己的電腦上 (node v14.15.0) 測試是可以用的
建立 context vm 模組沒有提供建立 context 的建構子，我們只能透過 vm.createContext 來建立 context。
注意 vm.createContext 不是 pure function，除了會回傳 context 以外，還會把傳入的物件變成 context，兩者傳入 vm.</description>
    </item>
    
    <item>
      <title>hCaptcha</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hcaptcha/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hcaptcha/</guid>
      <description>前情提要 我們社團的短網址服務裡面常常出現一些奇怪的網址，我猜可能是有機器人在刷，所以我想加入 captcha 減少這類問題。我選擇的是 hCaptcha 這套，能不依賴 Google 就盡量不要。
安裝步驟 申請帳號 先到 hCaptcha 註冊、新增一個網站，複製 sitekey (Sites &amp;gt; site setting) 和 secret key (Settings)，我們等等會用到
前端 首先引入 script ，在 &amp;lt;head&amp;gt; 加入 &amp;lt;script src=&amp;#34;https://hcaptcha.com/1/api.js&amp;#34; async defer&amp;gt;&amp;lt;/script&amp;gt; 接著在你的 &amp;lt;form&amp;gt; 裡面加入，這邊的 your_site_key 就是剛剛複製的那個。記得 &amp;lt;form&amp;gt; 的 method 要設成 post &amp;lt;div class=&amp;#34;h-captcha&amp;#34; data-sitekey=&amp;#34;your_site_key&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 後端（node express） SECRET
首先，你要把剛剛的 SECRET 給 server 知道，我用的是 dotenv，當然其他的套件也是可以。
簡而言之，剛剛複製下來的 SECRET 就是用在這裡。
驗證 後端我選用的套件是 express-hcaptcha ，它提供一個 middleware 驗證 hcaptcha 的 token。 按照 README.md 的說明，應該是像這樣就可以了，當驗證通過時就會執行第二個 middleware</description>
    </item>
    
    <item>
      <title>docker login error</title>
      <link>https://blog.simbafs.cc/posts/linux/docker/docker-login-error/</link>
      <pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/docker/docker-login-error/</guid>
      <description>錯誤說明 昨天我在 terminal 登入 docker 的時候發現不知道為什麼不能登入，我先透過網頁登入確認過密碼沒有問題，也不是打錯字的關係，但還是不能當入。總是會有類似以下的錯誤訊息。
Error saving credentials: error storing credentials - err: exit status 1, out: `exit status 1: gpg: simbafs: 已跳過: 沒有公鑰 gpg: [stdin]: encryption failed: 沒有公鑰 Password encryption aborted.` 解決方法 經過搜尋之後，我按照 https://github.com/docker/docker-credential-helpers/issues/102#issuecomment-388634452 的方法成功登入了，但是在這之前要先安裝 gpg 和 pass
apt install gnupg2 pass 接下來是我用的指令
apt install gnupg2 wget https://github.com/docker/docker-credential-helpers/releases/download/v0.6.3/docker-credential-pass-v0.6.3-amd64.tar.gz tar xvf docker-credential-pass-v0.6.3-amd64.tar.gz chmod 755 docker-credential-pass sudo mv docker-credential-pass /usr/bin/ ass insert docker-credential-helpers/docker-pass-initialized-check pass insert docker-credential-helpers/docker-pass-initialized-check pass show docker-credential-helpers/docker-pass-initialized-check docker-credential-pass list docker login 參考連結 https://github.</description>
    </item>
    
    <item>
      <title>connect to ethernet in docker container</title>
      <link>https://blog.simbafs.cc/posts/linux/docker/connect-to-ethernet-in-docker-container/</link>
      <pubDate>Sat, 28 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/docker/connect-to-ethernet-in-docker-container/</guid>
      <description>如何在 docker container 裡連接 ethernet 今天突然有個需求是在一個已經開啟的 container 弄東西，需要網路，但是不知道為什麼一直不上，後來發現是 docker 沒有設定 DNS 的問題，只要在外面輸入兩行指令就可以了
DOCKER_OPTS=&amp;#34;--dns 8.8.8.8&amp;#34; systemctl restart docker 然後重新啟動 docker</description>
    </item>
    
    <item>
      <title>docker commit</title>
      <link>https://blog.simbafs.cc/posts/linux/docker/docker-commit/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/docker/docker-commit/</guid>
      <description>前言 上次提到可以用 Dockerfile 建立 docker image，但我們還有令一個方法可以建立 docker image，那就是 docker commit 指令
和 Dockerfile 差別 docker commit 有點像是手動版的 Dockerfile，在用 Dockerfile 建構 docker image 的時候，docker build 的工作就像是自動根據 Dockerfile 操作 docker commit。 Dockerfile 比較適合用在自動化交付和部屬，例如說你有一份程式碼，要將他包成 Docker 就很適合用 Dockerfile 自動化操作，因為程式碼會改變，但是包裝的流程基本上都是一樣的。 docker commit 適合用在建構環境，因為會有比較麻煩的操作，如果寫成 Dockerfile 會比較麻煩，當然如果可以的話還是寫成 Dockerfile 會比較好，因為更新的時候會比較方便。 在建構 image 的時候要用哪個方法就看個人取捨了。
docker commit 指令 docker commit 可以把運行中的 comtainer 轉成 images，有點類似令存新檔的概念。先來看看參數吧！
參數 $ docker commit --help Usage:	docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] Create a new image from a container&amp;#39;s changes Options: -a, --author string Author (e.</description>
    </item>
    
    <item>
      <title>bash number loop</title>
      <link>https://blog.simbafs.cc/posts/linux/bash/bash-number-loop/</link>
      <pubDate>Sun, 15 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/bash/bash-number-loop/</guid>
      <description>今天在某的地方剛好看到一個 bash 的小技巧，當我們要從 1 數到 100 時，通常會用 seq 指令來做，但是如果我們的需求剛剛好是每次遞增（遞減）1 的話，就可以使用 {start..end} 縮寫，下面兩個範例的效果是一樣的：
# for 迴圈 + seq 的寫法 for i in $(seq 1 1 100); do echo $i done # 用 {start..end} echo {1..100} 這個技巧也可以用在建立檔案，像這樣：
touch user{1..100} </description>
    </item>
    
    <item>
      <title>bash completion</title>
      <link>https://blog.simbafs.cc/posts/linux/bash/bash-completion/</link>
      <pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/bash/bash-completion/</guid>
      <description>需求 今天寫了一個 bash script 幫我管理 mongodb docker，在使用的時候一些子命令，像是 up、down、clean。我希望可以讓 bash 當我自動補齊這些選項。
bash_completion bash_completion 是一個可以幫我們做程式化補齊的工具，像是 git 就有使用到這個工具，在 commit、push 的時候按 tab 都會顯示出當下我們可以用的東西，像是 git push&amp;lt;tab&amp;gt;&amp;lt;tab&amp;gt; 就會自動補齊 origin 而不是給我們看檔案（bash 預設只會補齊檔案和命令）。我們這次只須要用基本的 complete 就可以了
complete complete 可以幫命令加上簡單的自動完成，其實 bash_completion 也是去呼叫這個命令來達成自動補齊。complete 傻用非常簡單，像下面這樣就可以幫 mongodb 這個命令加上自動補齊
complete -W &amp;#34;up down clean&amp;#34; mongodb -W 選項代表後面是字詞列表，用 -F 後面可以接一個函數，但是這個我沒研究，也許下一個專案就是研究 complete 也說不定。</description>
    </item>
    
    <item>
      <title>Mongoose Model</title>
      <link>https://blog.simbafs.cc/posts/nodejs/mongoose-model/</link>
      <pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/mongoose-model/</guid>
      <description>Mongoose Model 環境設定 這是這次實驗用的 code
const mongoose = require(&amp;#39;mongoose&amp;#39;); mongoose.connect(&amp;#39;mongodb://127.0.0.1:27017&amp;#39;, {useNewUrlParser: true, useUnifiedTopology: true}) .then(() =&amp;gt; console.log(&amp;#39;Connected to DB&amp;#39;)) .catch(e =&amp;gt; console.error(e)); const requiredString = { type: String, required: true } const UserSchema = new mongoose.Schema({ username: requiredString, password: requiredString }); const UserModel = mongoose.model(&amp;#39;User&amp;#39;, UserSchema); mongo db 用 docker 開一個實驗用的 server
version: &amp;#39;3&amp;#39; services: db: image: &amp;#39;mongo&amp;#39; container_name: &amp;#39;aurl-mongodb&amp;#39; volumes: - ./data/mongo:/data/db - ./data/dump:/dump ports: - &amp;#39;27017:27017&amp;#39; 取得原 schema 在一般操作的時候都是用 UserModel 在操作資料庫，當要取得 schema 的時候當然也是從他裡面找最方便，當然也可以把 schema 特別弄出來，但是有點麻煩，以這次的例子說明，原本的 UserSchema 會存在 UserModel.</description>
    </item>
    
    <item>
      <title>docker 基礎指令</title>
      <link>https://blog.simbafs.cc/posts/linux/docker/docker-%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/docker/docker-%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/</guid>
      <description>Install apt install docker docker.io docker-compose What is docker Docker 是一個容器化的技術，基本上使用的時候可以把他當成虛擬機，雖然他們的使用的技術完全不一樣。對新手來說，在 Docker 裡面有四個重要的名詞：dockerfile, docker image, docker container, docker-compose。
dockerfile
純文字檔，定義建立 docker image 的步驟，有點像是一個 bash shell。通常命名成 Dockerfile ，在 build 的時候會預設用這個，也可以用 -f 來指定其他的檔案。 docker image
這是透過 docker build 編譯出來的東西。可以想成 docker container 的藍圖，在 docker pull 的時候也是下載 docker image 而不是 dockerfile。基本上 image 裡面已經包括了編譯好的執行檔和基本的環境設定，所以在 docker 外面是不用做他設定的，這也是 docker 的魅力所在。 docker container
每個 docker image 可以產生很多個 container，也就是執行中的程式。在這裡你已經可以用 docker 來建立各種服務了。這裡也可以想像成虛擬機，用 docker exec -it container_name bash 可以進到 container 裡面(如果裡面有 bash 的話) docker-compose</description>
    </item>
    
    <item>
      <title>mxlinux boot with systemd</title>
      <link>https://blog.simbafs.cc/posts/linux/mxlinux-boot-with-systemd/</link>
      <pubDate>Sat, 05 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/mxlinux-boot-with-systemd/</guid>
      <description>問題 在 mxlinux 裡面，預設的 init 不是 systmed，這導致如果想用 systemctl 的時候就會跳出錯誤說
System has not been booted with systemd as init system 像是在安裝 mongodb-org 的時候他就要用到 systemctl 然後就會出錯。
解法 其實 mxlinux 已經幫我們想好解法了，在開機選項時選 Advence &amp;gt; Systemd 就會以 systemd 開機</description>
    </item>
    
    <item>
      <title>node require from project root</title>
      <link>https://blog.simbafs.cc/posts/nodejs/node-require-from-project-root/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/node-require-from-project-root/</guid>
      <description>問題 在寫一個專案的時候，有時候會有一些小程式重複在不同的檔案裡用到，這時候我們會把他打包成模組放在 lib/。但是如果資料夾結構有點點複雜的時候， require() 的路徑就會很複雜：
. ├── index.js ├── lib │ └── random.js └── routes └── page └── signup └── index.js 在 index.js 裡面如果要引入 random.js 就會變成這樣
const random = require(&amp;#39;../../lib/random.js&amp;#39;); 爛解法 如果我們想要直接用 require(&#39;lib/random&#39;) 的話做簡單的方式是上傳 npm，但是這樣稍嫌麻煩，而且別的專案不一定用的到。每一次修改都要上傳 npm 很不方便。
好解法 在 linux 裡面要把執行檔做成指令有兩個方法
放到 /usr/bin 之類的地方 把這個路徑直接加到 PATH 裡面 在 node 裡面也有 path 設定，module.paths，在 require 時會去這個裡面的目路尋找檔案。所以如果要達成上述的功能的話就只要加這行就可以了
module.paths.push(process.cwd()); 這樣就可以直接用 require(&#39;lib/random&#39;) 引入了
參考資料 https://github.com/nodejs/node/issues/4223
https://github.com/nodejs/node/issues/1979
https://www.npmjs.com/package/rooty
^^^
這個是在 github issue 裡面看到的，沒試過，但是應該也可以用吧？只是我覺得沒有 paths 的解法來的優雅。</description>
    </item>
    
    <item>
      <title>vim auto comment plugin</title>
      <link>https://blog.simbafs.cc/posts/linux/vim/vim-auto-comment-plugin/</link>
      <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/vim/vim-auto-comment-plugin/</guid>
      <description>套件 nerdcommenter
好用的指令 在每次動作前都要按 &amp;lt;leader&amp;gt;，預設是 反斜線 \
c&amp;lt;space&amp;gt; 簡單來說就是 toggle 你的註解
cA 跳到行尾並在行尾加上註解</description>
    </item>
    
    <item>
      <title>文章更新時間錯亂問題</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hexo/%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E6%99%82%E9%96%93%E9%8C%AF%E4%BA%82%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hexo/%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E6%99%82%E9%96%93%E9%8C%AF%E4%BA%82%E5%95%8F%E9%A1%8C/</guid>
      <description>問題 在設定完 GitHub Action 之後，我發現我的文章的更新時間都錯了，會全部變成當天日期。但是本地生成的就沒有這個問題，經過一番盤查和猜測後，我發現問題是因為 git 不會把 modified date 紀錄，因為每台電腦的時區都是不一樣的，紀錄起來沒有意義。但是我們需要這項 meta data，所以我們就要自己想法紀錄
解法 v1.0 首先，因為每一篇文章 hexo 都會紀錄建立時間，所以我們可以直接把他抓出來，然後把檔案的更新時間設成這個時間就可以啦！
更改檔案的 modified time 這個功能只要用我們最熟悉的 touch 就可以做到了。一般我們使用 touch 的時候會把 modified time 改成當下時間，那要改任意時間只要加上 -t 選項就可以啦
-t STAMP use [[CC]YY]MMDDhhmm[.ss] instead of current time 假設我們有個檔案 tmp ，我想把他的日期改成 1999/3/23 12:32:33 ，那我可以這樣下指令
ted timeouch -t&amp;#39;19993231232.33&amp;#39; tmp 抓出檔名、日期 # git create time grep -rnw source/_posts -e &amp;#39;date&amp;#39; output:（這裡的 date: 後面我多加了一個空白，原因後面會說）
source/_posts/hexo-installation.md:3:date: 2020-02-10 17:26:45 source/_posts/blessed.md:3:date: 2020-02-17 23:24:10 source/_posts/bash.md:3:date: 2020-02-16 22:15:10 source/_posts/hexo-cli-extras.</description>
    </item>
    
    <item>
      <title>express 重複 send</title>
      <link>https://blog.simbafs.cc/posts/nodejs/express-%E9%87%8D%E8%A4%87-send/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/express-%E9%87%8D%E8%A4%87-send/</guid>
      <description>問題 在 express route 裡面，我通常會在 res.send() 之類的函式前面都會加一個 return 防止因為程式邏輯漏洞造成重複送出然後噴 error。像是這樣
route.get(&amp;#39;/&amp;#39;, (req, res, next) =&amp;gt; { return res.send(&amp;#39;Hello world&amp;#39;); }); 但是如果我們用到 Promise 的時候 return 並不會跳出整個 route，所以我們需要另一個方法，我的想法是一個變數儲存是否送出，然後在每次送出前都判斷，送出候更改變數值
+--------------------------+ | is sent( flag === false) | +-+------------------------+ |no | +-+----+ | send | +-+----+ | +-+-----------+ | change flag | +-------------+ route.get(&amp;#39;/&amp;#39;, (req, res, next) =&amp;gt; { let flag = false; doSomePromise() .then(() =&amp;gt; { // do something if(!flag){ res.send(&amp;#39;Hello world&amp;#39;); flag = true; } }) }) 這樣就不會噴一堆 error 啦！</description>
    </item>
    
    <item>
      <title>加入 google search 和 sitemap</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hexo/%E5%8A%A0%E5%85%A5-google-search-%E5%92%8C-sitemap/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hexo/%E5%8A%A0%E5%85%A5-google-search-%E5%92%8C-sitemap/</guid>
      <description>前置設定 npm 安裝 hexo-generator-sitemap npm i -S hexo-generator-sitemap 設定插件 將以下內容加到 _config.yml
注意空白
# sitemap sitemap: path: sitemap.xml 驗證網域 如果你的 hexo 是架在自己的網域可以跳過這步
因為我的 hexo 是 託管在 GitHub page，在 Google Search Console 驗證的時候沒辦法用網域，所以要放一個特別的檔案到我們的網站根目錄
首先到 Google Search Console 新增一個網域 選擇右邊，輸入你的網址 下載提供的 html 並放到 source/ 資料夾 忽略 接下來會遇到 hexo 在生成的時候把這個 html 也放到模板裡面，所以我們要把他加入忽略清單裡面
在 _config.yml 裡面找到 skip_render
把直接檔名寫在後面或是用清單都可以 注意空白
# 直接寫 skip_render: &amp;#39;googlebabababababa.html&amp;#39; # 或是用清單 skip_render: - &amp;#39;googlebabababababa.html&amp;#39; 按下驗證，完成 Sitemap 驗證好了之後進入 Google Search Console，在側邊欄找到 索引 -&amp;gt; Sitemap 輸入 sitemap.</description>
    </item>
    
    <item>
      <title>GitHub Action 自動部署 hexo</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hexo/github-action-%E8%87%AA%E5%8B%95%E9%83%A8%E7%BD%B2-hexo/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hexo/github-action-%E8%87%AA%E5%8B%95%E9%83%A8%E7%BD%B2-hexo/</guid>
      <description>前言 本來部署 hexo 都是手動下指令，但是這樣在手機上因為沒辦法裝 hexo ,所以一直不能在手機上寫文章。剛好想到 GitHub Action 可以滿足我的需求，上網查了一下資料發現蠻多人有和我一樣的需求，這次參考的是 owlran 大大的文章。
ssh key 因為要部署到 GitHub repo，最方便的方法當然是 ssh key 啦。
ssh-keygen 首先隨便找個資料夾產生一組 ssh key
ssh-keygen -f deploy-key GitHub 再來要讓 GitHub 知道你的 ssh key（public/secret 都要）
public key public key 是要放在你的 &amp;lt;username&amp;gt;.github.io 的 repo 下
.ggithub.io -&amp;gt; settings -&amp;gt; Deploy keys -&amp;gt; add deploy key
新增一個 ssh key，名字叫 DEPLOY_KEY_PUB
把 depoly-key.pub 的內容貼上，記得下面的勾勾（Allow write access ）要選起來
secret key secret key 要放在你存放部落格檔案的 repo，owlran 大大是放在同一個 repo 不同 branch，我是放在兩個不同 repo，其中放部落格檔案的 repo 我設成 private repo（因為我放了一些 gitalk 要用的 clientSecret，這個不能公開）。</description>
    </item>
    
    <item>
      <title>React update state on props change</title>
      <link>https://blog.simbafs.cc/posts/nodejs/react/react-update-state-on-props-change/</link>
      <pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/react/react-update-state-on-props-change/</guid>
      <description>問題 今天在研究 React 遇到一個問題 當我從外面更新 props 的時候 component 內的 state 不會更新
function Input(props){ const [text, setText] = React.useState(props.text); return ( &amp;lt;input type=&amp;#34;text&amp;#34; value={text}&amp;gt; ) } 如同上面程式，第二行的 useState 不會隨著 props 更新而更新
解法 後來找到解法，加上一個 useEffect 監聽 props.text 然後更新 state 就好了
function Input(props){ const [text, setText] = React.useState(props.text); React.useEffect(() =&amp;gt; { setText(props.text); }, [props.text]); return ( &amp;lt;input type=&amp;#34;text&amp;#34; value={text}&amp;gt; ) } 如此一來 state 就會和 props 同步了
參考資料 https://stackoverflow.com/questions/54865764/react-usestate-does-not-reload-state-from-props https://zh-hant.reactjs.org/docs/hooks-effect.html</description>
    </item>
    
    <item>
      <title>讓 YCM 接受 jsx</title>
      <link>https://blog.simbafs.cc/posts/linux/vim/%E8%AE%93-ycm-%E6%8E%A5%E5%8F%97-jsx/</link>
      <pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/vim/%E8%AE%93-ycm-%E6%8E%A5%E5%8F%97-jsx/</guid>
      <description>最近寫ˋreact 的時候只要遇到 jsx 語法 YCM 就會跳出這個錯誤
Cannot use JSX unless the &amp;#39;--jsx&amp;#39; flag is provided. (FixIt) 研究之後發現這是要給 tsserver 一個 --jsx 的 flag 就可以解決 爬文半個小時後發現只要在專案下的 jsconfig.json
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;target&amp;#34;: &amp;#34;es6&amp;#34;, &amp;#34;checkJs&amp;#34;: true + }, + &amp;#34;compilerOptions&amp;#34;: { + &amp;#34;jsx&amp;#34;: &amp;#34;react&amp;#34; } } </description>
    </item>
    
    <item>
      <title>webpack-react</title>
      <link>https://blog.simbafs.cc/posts/nodejs/react/webpack-react/</link>
      <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/react/webpack-react/</guid>
      <description>前言 最近開始想學 react 在這之前當然要先把開發環境搞好 其中 react 最重要的就是 webpack 和 babel 了 babel 負責編譯 webpack 負責串街所有工作
安裝套件 建立一個專案並初始化 mkdir react-test cd react-test npm init -y git init -y 安裝開發用套件 npm i -D \ @babel/core \ @babel/cli \ @babel/preset-env \ @babel/preset-react \ babel-loader \ react \ react-dom \ webpack package.json 加入以下的 script
{ &amp;#34;dev&amp;#34;: &amp;#34;webpack --mode development&amp;#34;, &amp;#34;watch&amp;#34;: &amp;#34;webpack --mode development --watch&amp;#34;, &amp;#34;depoly&amp;#34;: &amp;#34;webpack --mode production&amp;#34; } webpack.config.js 建立 webpack.config.js 這是最小的版本了 沒有任何的擴充</description>
    </item>
    
    <item>
      <title>nginx-ui</title>
      <link>https://blog.simbafs.cc/posts/linux/server/nginx-ui/</link>
      <pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/server/nginx-ui/</guid>
      <description>前幾天發現一個專案 nginx ui 他是一個可以讓你在網頁上更改 nginx config 的專案 安裝：
docker pull schenkd/nginx-ui 啟動；
docker run -p 8080:8080 -v /etc/nginx:/etc/nginx schenkd/nginx-ui 然後打開瀏覽器 http://localhost:8080 就可以看到管理頁面了 很陽春，就是不用 ssh 進 server，沒什麼特點 我應該是不會用這套</description>
    </item>
    
    <item>
      <title>HTML form button</title>
      <link>https://blog.simbafs.cc/posts/frontend/html-form-button/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/frontend/html-form-button/</guid>
      <description>HTML 的 form 裡的按鈕預設是 submit 所以要加上 type=&amp;quot;button&amp;quot; 它才不會太心急送出表單
按鈕的 css 「按下」 selector 好像可已用 :active、:focus 但是我兩個失敗了</description>
    </item>
    
    <item>
      <title>mxlinux-change-workspace</title>
      <link>https://blog.simbafs.cc/posts/linux/mxlinux-change-workspace/</link>
      <pubDate>Fri, 08 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/mxlinux-change-workspace/</guid>
      <description>切換工作區 今天想要在 mxlinux 中快速的切換工作區 我看到可以用滑鼠滾輪切換 可是我想要的是鍵盤快捷鍵 上網查了一下 發現可以透過 Ctrl+Alt+up/down/home/end 來切換
參考資料 https://unix.stackexchange.com/questions/270334/how-to-move-a-window-to-another-workspace-in-xfce</description>
    </item>
    
    <item>
      <title>gpg</title>
      <link>https://blog.simbafs.cc/posts/linux/gpg/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/gpg/</guid>
      <description>今天心血來潮想設定 GPG，網路上查了一個教學，無疑的又遇到一個坑
坑 &amp;amp; 解法 我按照他的作法弄完後就是沒辦法 commit 他說 GPG 無法簽章 後來我發現是我的 name 填錯（應該啦，我猜的） 總而言之就重新產生 GPG key 就好了 name 和 git 設定的一樣
指令 $ gpg --full-gen-key $ gpg --list-secret-keys $ gpg --armor --export &amp;lt;secret key&amp;gt; 刪除金鑰 在刪除的時候分成兩步驟，刪除私鑰、刪除公鑰。在刪除之前要先知道要刪除的金鑰的 ID
gpg --list-keys 找到那串很長的文字，那就是 ID，複製起來，他起來也許會像這樣
JFDKSA8FEWHE29HFVC92UHFPA93WOHFVDOPA39U2 再來用兩個指令就可以刪除了，注意一定要先刪私鑰。
gpg --delete-secret-key &amp;lt;ID&amp;gt; gpg --delete-key &amp;lt;ID&amp;gt; </description>
    </item>
    
    <item>
      <title>meta-tag</title>
      <link>https://blog.simbafs.cc/posts/frontend/meta-tag/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/frontend/meta-tag/</guid>
      <description>今天為了幫 Let&amp;rsquo;s Remind Daniel 做 SEO 在 免費資源網路社群 找到了一個工具可以直接生成 還有一個可以測試的工具
連結 生成 測試</description>
    </item>
    
    <item>
      <title>firefox-event-listener-breakpoint</title>
      <link>https://blog.simbafs.cc/posts/frontend/firefox-event-listener-breakpoint/</link>
      <pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/frontend/firefox-event-listener-breakpoint/</guid>
      <description>問題 最近在用 jquery 但是不知道為什麼每次 debugger 都會跳出一個通知 很煩
解決 後來尋線發現原來是 firefox 好心的 debugger 在 DOM 發生改變的時候通知我 在 裡面 Debugger 頁籤左下有個拉頁叫「Event Listener Breakpoints」 把裡面的東西都點掉就好了 就是那個 DOM Mutation 心得 我原本還以為是 jquery 的問題 原來是好心的 firefox 啊</description>
    </item>
    
    <item>
      <title>jquery</title>
      <link>https://blog.simbafs.cc/posts/frontend/jquery/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/frontend/jquery/</guid>
      <description>今天寫 jquery 遇到了一些坑
1. submit .submit() 是要加在 form 上而不是 submit button 上
2. this 在 jquery 裡有時後會用到 handler 正常情況下可以用 arrow function 但是如果用到 this 就不能用 arrow function 了 （這不只是 jquery, JS 都是這樣）</description>
    </item>
    
    <item>
      <title>remind-daniel</title>
      <link>https://blog.simbafs.cc/posts/nodejs/remind-daniel/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/remind-daniel/</guid>
      <description>今天終於把登入做完了 我覺得最重要的是找好的教學文章、去看沒有人看得懂的程式碼</description>
    </item>
    
    <item>
      <title>sqlite</title>
      <link>https://blog.simbafs.cc/posts/nodejs/sqlite/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/sqlite/</guid>
      <description>昨天是試著去理解 sqlite3，我發現他的 callback function 真的太煩了 於是我試著去尋找 async 的版本，還真找到了 這個套件把整個 sqlite 包成 async 了</description>
    </item>
    
    <item>
      <title>isolate</title>
      <link>https://blog.simbafs.cc/posts/linux/isolate/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/isolate/</guid>
      <description>我有一個放了很久的計畫，就是自己寫一個 OJ，因為我覺得現在的那個太難用了。 我很快的建立 repo 但是卻完全沒有進展，我寫了一個 shell script 幫忙編譯執行程式之後我就在也沒有動過他了 我沒有繼續動工的原因是我不知道如何隔離使用者提交的程式碼 我想過 docker 可是據說還是不安全 還有 chroot 但是我不知道有沒有比 docker 安全而且設定好麻煩
昨天去考 TOI　入營考（當然沒進）的時候，我終於看到大名鼎鼎的 CMS 了！ 出來之後我發現他是用一個叫 isolate 的程式來做沙箱測試 而且這好像是 IOI 自己寫的，應該是蠻安全的（吧？） 今天成功編譯過後把心得寫下來</description>
    </item>
    
    <item>
      <title>youtube-dl</title>
      <link>https://blog.simbafs.cc/posts/linux/youtube-dl/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/youtube-dl/</guid>
      <description>最近在下載 youtube 音樂，每次下載都要把檔案重新改名，很麻煩。所以就想要寫一個 shell script 來幫我解決。 首先改名字我相信 youtube-dl 一定有提供這個選項，於是開始查文件。 看到 -o ，接下來講遇到的坑
-o 坑 -o 後面接的是一個 template string ，不是檔名，而且就算指定副檔名是 .mp3 了還是要寫成 %(ext)s</description>
    </item>
    
    <item>
      <title>blessed-landmine</title>
      <link>https://blog.simbafs.cc/posts/nodejs/blessed/blessed-landmine/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/blessed/blessed-landmine/</guid>
      <description>這是一篇我在用 blessed 時踩的一些雷 會持續的更新
1. 記得 render 今天在寫 API 時踩到兩次 更新了資料卻沒有 render 例如 textarea.setValue() 這個函式設定完之後他畫面不會更新 要自己 render
2. textarea.setValue() 只接受字串當參數 我個人覺得 blessed 缺少一個像是 jquery 的函式庫 沒有一個很好的 API 包裝 例如說這個函式 textarea.setValue() 就只吃字串 因為他用了 String.prototype.replace 這個函數 而且他沒有一個很好的防呆機制例如參數型別檢查 幸好是他的程式碼沒有做 uglify 還算簡單易懂 而且 node 的錯誤訊息的 stack 可以引導到真正出錯的地方</description>
    </item>
    
    <item>
      <title>ssh-tunnel</title>
      <link>https://blog.simbafs.cc/posts/linux/ssh-tunnel/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/ssh-tunnel/</guid>
      <description>昨天架好了 reverse ssh 讓我可以連回學校 server 今天來研究 ssh tunnel
簡介 ssh tunnel 分正反向 其實他們的差別只有在方向不一樣 連語法參數都一樣
正向 tunnel 正向的 tunnel 參數是 -L 語法：
ssh -L [bind_address:]port:host:hostport ssh -L [bind_address:]port:remote_socket ssh -L local_socket:host:hostport ssh -L local_socket:remote_socket 反向 tunnel ssh -R [bind_address:]port:host:hostport ssh -R [bind_address:]port:local_socket ssh -R remote_socket:host:hostport ssh -R remote_socket:local_socket ssh -R [bind_address:]port 心得 看起來好像很難 但是其實用下面這個就夠了 正向：
ssh -L &amp;lt;local port&amp;gt;:localhost:&amp;lt;remote port&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;remote&amp;gt; 反向;
ssh -R &amp;lt;remote port&amp;gt;:localhost:&amp;lt;local port&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;remote&amp;gt; 總而言之就是前面的和選項一樣 如果是 -L 那前面就是 local port 如果是 -R 那前面就是 remote port</description>
    </item>
    
    <item>
      <title>reverse-ssh</title>
      <link>https://blog.simbafs.cc/posts/linux/reverse-ssh/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/reverse-ssh/</guid>
      <description>一直以來連線回社辦的電腦都要走 webtty 再開 tmate 但是今天發現了一個新的方法可以透過反向的 ssh 連回社辦
reverse ssh 在社辦電腦
$ ssh -NfR 2222:localhost:22 simba@simba-vps 這可以建立一個連線 這時候到 simba-vps
$ ssh server@localhost -p 2222 就可以連線回社辦伺服器了
autossh 但是這樣做 ssh 連線有可能會超時然後斷掉 這時候可以透過 autossh 來幫我們自動建立連線 在社辦電腦
$ apt install autossh $ autossh -Mf 2222 -NR 1111:localhost:22 simba@simba-vps -p 22 這樣就可以在 vps 上
$ ssh server@localhost -p 1111 來連回社辦啦！ 最後可以把這堆在 vps 上再做一次就可以在 internet 連回社辦伺服器了
參考網址 https://stackoverflow.com/questions/15983795/how-do-i-establish-a-bidirectional-ssh-tunnel
https://ez3c.tw/2043
https://www.ubuntu-tw.org/modules/newbb/viewtopic.php?viewmode=compact&amp;amp;topic_id=17538&amp;amp;forum=7
http://blog.adahsu.net/2007/11/ssh-reverse-tunnel.html
https://codertw.com/%E4%BC%BA%E6%9C%8D%E5%99%A8/377688/
這篇講 ssh tunnel 最清楚
https://yu-jack.github.io/2019/01/08/ssh-tunnel/</description>
    </item>
    
    <item>
      <title>unix-socket</title>
      <link>https://blog.simbafs.cc/posts/nodejs/unix-socket/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/unix-socket/</guid>
      <description>今天心血來潮在看 unix socket 突然想到 node 可不可以把 服務監聽在一個 socket file 這樣在設定的時候就不用記哪個服務是幾 port
node 部份 監聽在 unix socket 查完資料後發現其實只要把原本填 port 的地方改成 socket file 的路徑就好了 像這樣
const express = require(&amp;#39;express&amp;#39;); const app = express(); app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; { res.send(&amp;#39;Hello World\n&amp;#39;); }); app.listen(&amp;#39;/tmp/express.sock&amp;#39;); 刪除 socket file 因為每次的 listen 都會新增一個 socket file 相當於佔用一個 port 如果不刪除的話就相當於 port 被佔用了 會噴錯 所以每次程式結束的時候要把這個 socket file 刪掉 然後在 /tmp 下的檔案會在開機後自動刪掉 所以如果部屬後發什麼問題重開機就對了！ 修改完的 code 長這樣
const fs = require(&amp;#39;fs&amp;#39;); const express = require(&amp;#39;express&amp;#39;); const app = express(); app.</description>
    </item>
    
    <item>
      <title>blessed切換畫面</title>
      <link>https://blog.simbafs.cc/posts/nodejs/blessed/blessed%E5%88%87%E6%8F%9B%E7%95%AB%E9%9D%A2/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/blessed/blessed%E5%88%87%E6%8F%9B%E7%95%AB%E9%9D%A2/</guid>
      <description>今天完成了新版本的 treetify 看這 同時我設計好了右邊的 edit 但是我的問題是他要根據情況不同切換不同的頁面 來看看我的一些想法：
從 screen.children[2] 把他會掉，可是會出錯不行 有一個元件 Carousel 好像可以但是他其實是用方向鍵控制所以也不行 終於我想了一個方法，接下來來介紹 這是測試程式碼 const blessed = require(&amp;#39;blessed&amp;#39;); const contrib = require(&amp;#39;blessed-contrib&amp;#39;); const screen = blessed.screen({ title: &amp;#39;JSON viewer&amp;#39;, debug: true }); const grid = new contrib.grid({ rows: 1, cols: 2, screen: screen }); const tree = grid.set(0, 0, 1, 1, blessed.box, { border: {type: &amp;#39;line&amp;#39;}, content: &amp;#39;Tree&amp;#39;, label: &amp;#39;Tree&amp;#39; }); const edit = grid.set(0, 1, 1, 1, blessed.box, { border: {type: &amp;#39;line&amp;#39;}, content: &amp;#39;Edit&amp;#39;, label: &amp;#39;Edit&amp;#39; }); const box2 = blessed.</description>
    </item>
    
    <item>
      <title>blessed-contrib-tree</title>
      <link>https://blog.simbafs.cc/posts/nodejs/blessed/blessed-contrib-tree/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/blessed/blessed-contrib-tree/</guid>
      <description>Tree 想說先想一個專案來練練手 熟悉一下 blessed 突然看到 blessed-contrib 裡有個元件叫 tree 想說可以做成 JSON viewer 於是就開工了！
其中最重要的部份就是搞定樹狀結構 因為他有特定的格式和選項 下面是官方的範例
範例 { extended: true, children: { &amp;#39;Fruit&amp;#39;: { children: { &amp;#39;Banana&amp;#39;: {}, &amp;#39;Apple&amp;#39;: {}, &amp;#39;Cherry&amp;#39;: {}, &amp;#39;Exotics&amp;#39;: { children: { &amp;#39;Mango&amp;#39;: {}, &amp;#39;Papaya&amp;#39;: {}, &amp;#39;Kiwi&amp;#39;: { name: &amp;#39;Kiwi(notthebird!)&amp;#39;, myCustomProperty: &amp;#34;hairyfruit&amp;#34; } } }, &amp;#39;Pear&amp;#39;: {} } }, &amp;#39;Vegetables&amp;#39;: { children: { &amp;#39;Peas&amp;#39;: {}, &amp;#39;Lettuce&amp;#39;: {}, &amp;#39;Pepper&amp;#39;: {} } } } } 每個節點都是物件 他的子節點存在 children 裡 如果是空物件代表這是葉節點 extended 屬性是是否展開，預設 true name 是顯示出來的字，如果要改再設，預設是 index myCustomProperty 直翻是自訂屬性，應該是當 tree.</description>
    </item>
    
    <item>
      <title>blessed</title>
      <link>https://blog.simbafs.cc/posts/nodejs/blessed/blessed/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/blessed/blessed/</guid>
      <description>某天我有一個問題 gtop 的圖畫界面是怎麼做的，我知道他是用 node 寫的，對他別有興趣 我上 github 看他的 package.json 發現他的 depandence 只有三個
... &amp;#34;dependencies&amp;#34;: { &amp;#34;blessed&amp;#34;: &amp;#34;^0.1.81&amp;#34;, &amp;#34;blessed-contrib&amp;#34;: &amp;#34;^4.8.16&amp;#34;, &amp;#34;systeminformation&amp;#34;: &amp;#34;^4.14.4&amp;#34; }, ... 其中 systeminformation 很顯然是取得系統資訊 那 GUI 的 library 應該就是 blessed 和 blessed-contrib 了 去 blessed 的 github 看看 沒想到這是一個超強大的函式庫 可是網路上的教學卻很少 只好自己看 docs 啦
接下來是我測試的一些程式碼和截圖</description>
    </item>
    
    <item>
      <title>server-tool</title>
      <link>https://blog.simbafs.cc/posts/linux/server/server-tool/</link>
      <pubDate>Sun, 16 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/server/server-tool/</guid>
      <description>用 bash 寫 log 分析工具 因為我們的 server 不知道是為什麼一直受到 DDoS 攻擊
我想知道是什麼時段容易受到攻擊和每次多久、來自那個 ip
於是我花了一點時間寫了幾個簡單的 script</description>
    </item>
    
    <item>
      <title>ddos</title>
      <link>https://blog.simbafs.cc/posts/linux/server/ddos/</link>
      <pubDate>Thu, 13 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/server/ddos/</guid>
      <description>伺服器被 DDoS 惹 今天早上把社團的 reverse proxy server 換成 nginx
下午心血來潮看看 log 檔 因為沒有寫好的工具
首先把 log 檔 cp 到我的電腦再來處理</description>
    </item>
    
    <item>
      <title>nginx-reverse-proxy-setup</title>
      <link>https://blog.simbafs.cc/posts/linux/server/nginx-reverse-proxy-setup/</link>
      <pubDate>Thu, 13 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/linux/server/nginx-reverse-proxy-setup/</guid>
      <description>nginx 反向代理伺服器 (reverse proxy) 之前社網 server 因為學校防火牆限制只能對外開 80 443 兩個 port
而且我們只有一個 ip (203.64.138.177)
所以要用 reverse proxy 來代理我們的多項服務
原本我只會用 apache2 後來不知道是不是因為 apache 太肥導致有時候回應時間會很久
所以我起了將 proxy server 換成 nginx 的想法</description>
    </item>
    
    <item>
      <title>hexo-config</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hexo/hexo-config/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hexo/hexo-config/</guid>
      <description>各種設定值嘗試 Highlight - # highlight: rainbow + highlight: rainbow var a = 7122; console.log(a); var a = 7122; console.log(a); int a = 7122; cout &amp;lt;&amp;lt; a; </description>
    </item>
    
    <item>
      <title>audo-depoly-by-github-action</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hexo/audo-depoly-by-github-action/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hexo/audo-depoly-by-github-action/</guid>
      <description>自動部屬部落格 參考網址：https://op30132.github.io/2020/02/05/github-action/ 生成公私鑰時不用在部落格根目錄，記的不要加入 git，要刪掉
name: HEXO CI on: push: branches: - master jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [12.x] steps: - uses: actions/checkout@v1 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node-version }} - name: Configuration environment env: HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}} run: | mkdir -p ~/.ssh/ echo &amp;#34;$HEXO_DEPLOY_PRI&amp;#34; | tr -d &amp;#39;\r&amp;#39; &amp;gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &amp;gt;&amp;gt; ~/.ssh/known_hosts git config --global user.name &amp;#34;simba-fs&amp;#34; git config --global user.</description>
    </item>
    
    <item>
      <title>gitalk</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hexo/gitalk/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hexo/gitalk/</guid>
      <description>啟用 gitalk 留言 到這個網址填資料 加入下面的片段到_config.yml disqus: enabled: false gitalk: enabled: true owner: &amp;lt;username&amp;gt; repo: &amp;lt;username&amp;gt;.github.io admin: [&amp;#39;&amp;lt;username&amp;gt;&amp;#39;] clientID: &amp;lt;clientID&amp;gt; clientSecret: &amp;lt;clientSecret&amp;gt; 加入下面的片段到themes/cactus/layout/_partial/comments.ejs &amp;lt;% if(page.comments &amp;amp;&amp;amp; theme.gitalk.enabled){ %&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&amp;#34;&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div id=&amp;#34;gitalk-container&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var gitalk = new Gitalk({ clientID: &amp;#39;&amp;lt;%= theme.gitalk.clientID %&amp;gt;&amp;#39;, clientSecret: &amp;#39;&amp;lt;%= theme.gitalk.clientSecret %&amp;gt;&amp;#39;, id: md5(window.location.pathname), repo: &amp;#39;&amp;lt;%= theme.gitalk.repo %&amp;gt;&amp;#39;, owner: &amp;#39;&amp;lt;%= theme.gitalk.owner %&amp;gt;&amp;#39;, admin: &amp;#39;&amp;lt;%= theme.gitalk.admin %&amp;gt;&amp;#39;, distractionFreeMode: &amp;#39;&amp;lt;%= theme.gitalk.on %&amp;gt;&amp;#39; }) gitalk.</description>
    </item>
    
    <item>
      <title>hexo-cli-extras</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hexo/hexo-cli-extras/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hexo/hexo-cli-extras/</guid>
      <description>好用的插件 因為 hexo 本身沒有提供編輯器
所以每次在編輯文章時都需要打路徑
這個插件他會去找到你的文章
然後給你選要編輯那一個
這只是其中一個功能
還有重新命名、刪除、隔離和加入
隔離是將其他文章暫時隔離，加入是將文章加回來</description>
    </item>
    
    <item>
      <title>hexo-installation</title>
      <link>https://blog.simbafs.cc/posts/nodejs/hexo/hexo-installation/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/posts/nodejs/hexo/hexo-installation/</guid>
      <description>把 hexo 部屬到 gh-page 執行
$ npm i hexo -g $ hexo init blog $ cd blog 修改 _config.yml 刪除最後兩行，改成
deploy: type: git repo: git@github.com:&amp;lt;username&amp;gt;/&amp;lt;repo&amp;gt; branch: master 執行
$ npm i hexo-deployer-git $ hexo depoly 在 repo 設定中 GitHub Pages 隨便選一個 Jekyll theme，這樣才不會 404
地雷：在之後都部屬要加上 -g
$ hexo d -g 不然不會生效
完成!
將原始碼保存 執行
$ git checkout -b hexo $ git add . $ git commit -m init $ git push -u origin hexo 完成</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.simbafs.cc/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/about/</guid>
      <description>🖐️ 哈囉！問世界安好 本名: 陳宏彰 常用網名: simba-fs、SimbaFs 原 JS 愛好者 目前 Go 愛好者 vim is the best editor 前端好難 Golang、NodeJS、nextjs 五迷 目前最喜歡「成名在望」 成大物理系大二 成功高中電子計算機研習社 擔任 退休網管兼教學 🛠 作品 NCKU Extended
成大系統瀏覽器擴充套件
擴充成大系統的功能
目前功能還不多，有其他想法歡迎發 Issue
telegrary Telegrary = Telegram + diary
Telegrary 是一個 Telegram 機器人，讓你可以在 Telegram 上管理日記。同時 Telegrary 提供了一個 CLI 界面，讓你可以在終端機管理日記。
📬 聯絡方式 mail: me@simbafs.cc Discord id: SimbaFs#2030 telegram: @simbafs twitter: @simbafs </description>
    </item>
    
    
    <item>
      <title>Resource</title>
      <link>https://blog.simbafs.cc/resource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simbafs.cc/resource/</guid>
      <description>resource</description>
    </item>
    
    
  </channel>
</rss>
