<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>golang on Simba&#39;s Blog</title>
    <link>https://blog.simba-fs.dev/posts/golang/</link>
    <description>Recent content in golang on Simba&#39;s Blog</description>
    <image>
      <url>https://blog.simba-fs.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.simba-fs.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 21 Feb 2022 18:54:55 +0800</lastBuildDate><atom:link href="https://blog.simba-fs.dev/posts/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang Plguin</title>
      <link>https://blog.simba-fs.dev/posts/golang/plguin/</link>
      <pubDate>Mon, 21 Feb 2022 18:54:55 +0800</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/golang/plguin/</guid>
      <description>Go 動態載入程式 Go 是一個編譯式的語言，也就是說他不像 JS 那樣可以動態執行程式碼。像是 Hexo 和 Hugo，前者因為是 JS 寫的，因此支援非常豐富的外掛，但後者因為是 Go 寫的，因此在不使用其他直譯式程式語言的情況下，很難製作外掛。
另一個 Go 寫的軟體 ponzu 則是在加入一段程式碼後，重新編譯自己。這麼做解決了外掛的問題，而且又不會失去 Go 的快速，但是就必須保留整個主程式的原始碼，而且也不那麼的「動態」
 ponzu 這個軟體兩年沒人維護了，很多東西都怪怪的，超級難編譯
 Plugin in Go 在 1.8 版的時候，Go 推出了 Plguin 套件，可以將外掛和主程式分開編譯，如果外掛有更動，不需要重新編譯主程式；主程式也可以動態載入外掛。
外掛 如果要將一個 package 編譯成外掛，首先他的 package 必須是 main，但是裡面的函式 main、init 都不會被執行，只有大寫開頭的變數、型態、函式會被暴露給主程式。
編譯外掛時，需要加上 -buildmode=plguin，這樣 go build 就會將原始碼編譯成 .so（share object）檔，這樣就可以被主程式呼叫。
主程式 主程式要載入外掛前，需要引用 plugin 套件
import &amp;#34;plugin&amp;#34; 用 func Open(path string) (*Plugin, error) 可以載入一個編譯過的外掛，如果重複呼叫這個函式，除了第二次外都會回傳第一次載入的結果，也就是說假如你在很多個 gorutine 中載入同一個外掛，go 會保證他是「安全」的。注意看，path 是個字串，因此你可以動態產生外掛的路徑，不需要寫死。
載入完了之後，用 func (p *Plugin) Lookup(symName string) (Symbol, error) 可以取得外掛暴露出來的變數、函式，因為 symName 是字串，因此這裡也可以動態選擇要的變數。現在你有一個型態是 Symbol 的變數了，其實這個 Symbol 就是 interface{} 所以不管要做什麼事，你都要先用 symbol.</description>
    </item>
    
    <item>
      <title>ExecCmd</title>
      <link>https://blog.simba-fs.dev/posts/golang/exec-cmd/</link>
      <pubDate>Tue, 19 Oct 2021 00:06:19 +0800</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/golang/exec-cmd/</guid>
      <description>Golang 執行外部命令 package main  import ( 	&amp;#34;fmt&amp;#34; 	&amp;#34;os/exec&amp;#34; )  func checkErr(err error) { 	if err != nil { 	panic(err) 	} }  func main() { 	pw := exec.Command(&amp;#34;wc&amp;#34;)  	stdin, err := pw.StdinPipe() 	checkErr(err)  	fmt.Fprintln(stdin, &amp;#34;fjasdfkjsad\njdfaksdfjksdfjkasdfj\ndjfkajsdk&amp;#34;)  	output, err := pw.Output() 	checkErr(err)  	fmt.Println(string(output)) } </description>
    </item>
    
    <item>
      <title>Aconf</title>
      <link>https://blog.simba-fs.dev/posts/golang/aconf/</link>
      <pubDate>Fri, 24 Sep 2021 08:46:37 +0800</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/golang/aconf/</guid>
      <description>aconf 是個可以直接幫你解決所有「設定」問題的套件，設定可以有預設、從命令列參數、環境變數和設定檔，設定檔還有官方支援四種格式，dotEnv、HCL、toml、yaml 和 json。
而且設定檔還可以有不只一個，他可以把多個設定檔合成，相當方便
基本使用 定義 struct 首先我們需要一個 struct 來定義我們的設定
type Config struct { 	Addr string `default:&amp;#34;:3000&amp;#34;` 	Title string `default:&amp;#34;Aconf Testing&amp;#34;` 	SysAdmin []string `default:&amp;#34;simba-fs,peter&amp;#34;` } 載入設定 再來，我們可以設定要從哪些來源載入設定值
loader := aconfig.LoaderFor(&amp;amp;config, aconfig.Config{ 	// 這四個預設都是關閉的，如果你想關閉任何一個隨時都可以關閉他 	// SkipDefaults: false, 	// SkipFiles: false, 	// SkipEnv: false, 	// SkipFlags: false, 	EnvPrefix: &amp;#34;APP&amp;#34;, 	FlagPrefix: &amp;#34;app&amp;#34;, 	Files: []string{&amp;#34;~/.config/app.toml&amp;#34;, &amp;#34;app.toml&amp;#34;}, 	FileDecoders: map[string]aconfig.FileDecoder{ 	&amp;#34;.toml&amp;#34;: aconfigtoml.New(), 	}, })  if err := loader.</description>
    </item>
    
    <item>
      <title>Golang Parse All Files In Directory Into Templates</title>
      <link>https://blog.simba-fs.dev/posts/golang/golang-parse-all-files-in-directory-into-templates/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/golang/golang-parse-all-files-in-directory-into-templates/</guid>
      <description>在用 gin 寫伺服器的時候，我發現模板並不會被 go build 打包進執行檔裡面，所以在執行的時候就找不到檔案，當然這個問題可以用字串的形式直接把模板放進 golang 原始碼裡面，但是這樣程式碼一複雜就會不好用，這時候就可以用 golang 的 embed 函式庫把檔案「嵌入」到原始碼裡面。但是問題又來了，嵌入了之後要怎麼把字串變成模板物件呢？
Embed  embed 套件是 1.16 新出的功能，所以如果想用的話記得要更新 go 到 1.16 以上
 embed 嵌入檔案的方式是透過特殊格式的註解宣告，直接看官方範例：
package main  import ( 	&amp;#34;embed&amp;#34; )  //go:embed hello.txt var s string  //go:embed hello.txt var b []byte  //go:embed hello.txt var f embed.FS  func main() { 	print(s) 	print(string(b)) 	data, _ := f.ReadFile(&amp;#34;hello.txt&amp;#34;) 	print(string(data)) } 可以看到，embed 可以把檔案讀成三種格式 string、[]byte、embed.FS，前兩者只能讀「一個」檔案，如果你只用這兩個的話引入時要用 _ &amp;quot;embed&amp;quot;。embed.</description>
    </item>
    
  </channel>
</rss>
