<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Simba&#39;s Blog</title>
    <link>https://blog.simba-fs.dev/posts/nodejs/</link>
    <description>Recent content on Simba&#39;s Blog</description>
    <image>
      <url>https://blog.simba-fs.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.simba-fs.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 28 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.simba-fs.dev/posts/nodejs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>strapi-quick-start</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/strapi-quick-start/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/strapi-quick-start/</guid>
      <description>strapi 是一個 headless CMS (content management system)，透過 web 介面就可以建立一個 api server
strapi 什麼是 headless CMS headless CMS 顧名思義是「無頭的 內容管理系統」，意思是沒有前端、只有後端，它就是一個 DB 的 web 界面 + api server。headless CMS 專注於處理 api 的部份，前端的部份一律不關心。這對於前後端分離有很大的幫助，基本上 headless CMS 已經解決了後端 80% 的工作，剩下的就是一些客製化的邏輯，像是登入、特殊的計算等等。
strapi 的優點  他的界面完善 支援多種 DB   MySQL &amp;gt;= 5.6
MariaDB &amp;gt;= 10.1
PostgreSQL &amp;gt;= 10
SQLite &amp;gt;= 3
MongoDB &amp;gt;= 3.6
 存取權限控制 外掛  quickstart 以下步驟是補充 官網的 quick start
 安裝
$ npx create-strapi-app my-project --quickstart; cd my-project</description>
    </item>
    
    <item>
      <title>node-vm</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/node-vm/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/node-vm/</guid>
      <description>node.js VM 模組 VM 是 node.js 的核心模組，提供安全的環境 (沙箱) 來測試不信任的程式碼。
基本概念 在 VM 模組裡面，有兩個基本的物件，script 和 context。script 是經過「編譯」程式，context 是給在沙箱裡面的程式碼的全域物件 (global) 。沙箱中的程式只能存取透過 context 指定的物件。
建立 script VM 模組提供 Script 建構子，可以透過他來建立 Script 物件。
const vm = require(&amp;#39;vm&amp;#39;); const script = new vm.Script(&amp;#39;i++&amp;#39;); 也可以用 vm.createScript
const vm = require(&amp;#39;vm&amp;#39;); const script = vm.createScript(&amp;#39;i++&amp;#39;);  vm.Script
vm.createScript 在 nodejs docs 上我沒有找到，但是我在自己的電腦上 (node v14.15.0) 測試是可以用的
 建立 context vm 模組沒有提供建立 context 的建構子，我們只能透過 vm.createContext 來建立 context。
注意 vm.createContext 不是 pure function，除了會回傳 context 以外，還會把傳入的物件變成 context，兩者傳入 vm.</description>
    </item>
    
    <item>
      <title>hCaptcha</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/hcaptcha/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/hcaptcha/</guid>
      <description>前情提要 我們社團的短網址服務裡面常常出現一些奇怪的網址，我猜可能是有機器人在刷，所以我想加入 captcha 減少這類問題。我選擇的是 hCaptcha 這套，能不依賴 Google 就盡量不要。
安裝步驟 申請帳號 先到 hCaptcha 註冊、新增一個網站，複製 sitekey (Sites &amp;gt; site setting) 和 secret key (Settings)，我們等等會用到
前端  首先引入 script ，在 &amp;lt;head&amp;gt; 加入  &amp;lt;script src=&amp;#34;https://hcaptcha.com/1/api.js&amp;#34; async defer&amp;gt;&amp;lt;/script&amp;gt; 接著在你的 &amp;lt;form&amp;gt; 裡面加入，這邊的 your_site_key 就是剛剛複製的那個。記得 &amp;lt;form&amp;gt; 的 method 要設成 post  &amp;lt;div class=&amp;#34;h-captcha&amp;#34; data-sitekey=&amp;#34;your_site_key&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 後端（node express）   SECRET
首先，你要把剛剛的 SECRET 給 server 知道，我用的是 dotenv，當然其他的套件也是可以。
簡而言之，剛剛複製下來的 SECRET 就是用在這裡。
  驗證 後端我選用的套件是 express-hcaptcha ，它提供一個 middleware 驗證 hcaptcha 的 token。 按照 README.</description>
    </item>
    
    <item>
      <title>Mongoose Model</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/mongoose-model/</link>
      <pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/mongoose-model/</guid>
      <description>Mongoose Model 環境設定 這是這次實驗用的 code
const mongoose = require(&amp;#39;mongoose&amp;#39;); mongoose.connect(&amp;#39;mongodb://127.0.0.1:27017&amp;#39;, {useNewUrlParser: true, useUnifiedTopology: true}) .then(() =&amp;gt; console.log(&amp;#39;Connected to DB&amp;#39;)) .catch(e =&amp;gt; console.error(e)); const requiredString = { type: String, required: true } const UserSchema = new mongoose.Schema({ username: requiredString, password: requiredString }); const UserModel = mongoose.model(&amp;#39;User&amp;#39;, UserSchema); mongo db 用 docker 開一個實驗用的 server
version: &#39;3&#39; services: db: image: &#39;mongo&#39; container_name: &#39;aurl-mongodb&#39; volumes: - ./data/mongo:/data/db - ./data/dump:/dump ports: - &#39;27017:27017&#39; 取得原 schema 在一般操作的時候都是用 UserModel 在操作資料庫，當要取得 schema 的時候當然也是從他裡面找最方便，當然也可以把 schema 特別弄出來，但是有點麻煩，以這次的例子說明，原本的 UserSchema 會存在 UserModel.</description>
    </item>
    
    <item>
      <title>node require from project root</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/node-require-from-project-root/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/node-require-from-project-root/</guid>
      <description>問題 在寫一個專案的時候，有時候會有一些小程式重複在不同的檔案裡用到，這時候我們會把他打包成模組放在 lib/。但是如果資料夾結構有點點複雜的時候， require() 的路徑就會很複雜：
. ├── index.js ├── lib │ └── random.js └── routes └── page └── signup └── index.js 在 index.js 裡面如果要引入 random.js 就會變成這樣
const random = require(&amp;#39;../../lib/random.js&amp;#39;); 爛解法 如果我們想要直接用 require(&#39;lib/random&#39;) 的話做簡單的方式是上傳 npm，但是這樣稍嫌麻煩，而且別的專案不一定用的到。每一次修改都要上傳 npm 很不方便。
好解法 在 linux 裡面要把執行檔做成指令有兩個方法
 放到 /usr/bin 之類的地方 把這個路徑直接加到 PATH 裡面  在 node 裡面也有 path 設定，module.paths，在 require 時會去這個裡面的目路尋找檔案。所以如果要達成上述的功能的話就只要加這行就可以了
module.paths.push(process.cwd()); 這樣就可以直接用 require(&#39;lib/random&#39;) 引入了
參考資料 https://github.com/nodejs/node/issues/4223
https://github.com/nodejs/node/issues/1979
https://www.npmjs.com/package/rooty
^^^
這個是在 github issue 裡面看到的，沒試過，但是應該也可以用吧？只是我覺得沒有 paths 的解法來的優雅。</description>
    </item>
    
    <item>
      <title>express 重複 send</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/express-%E9%87%8D%E8%A4%87-send/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/express-%E9%87%8D%E8%A4%87-send/</guid>
      <description>問題 在 express route 裡面，我通常會在 res.send() 之類的函式前面都會加一個 return 防止因為程式邏輯漏洞造成重複送出然後噴 error。像是這樣
route.get(&amp;#39;/&amp;#39;, (req, res, next) =&amp;gt; { return res.send(&amp;#39;Hello world&amp;#39;); }); 但是如果我們用到 Promise 的時候 return 並不會跳出整個 route，所以我們需要另一個方法，我的想法是一個變數儲存是否送出，然後在每次送出前都判斷，送出候更改變數值
+--------------------------+ | is sent( flag === false) | +-+------------------------+ |no | +-+----+ | send | +-+----+ | +-+-----------+ | change flag | +-------------+ route.get(&amp;#39;/&amp;#39;, (req, res, next) =&amp;gt; { let flag = false; doSomePromise() .then(() =&amp;gt; { // do something  if(!flag){ res.send(&amp;#39;Hello world&amp;#39;); flag = true; } }) }) 這樣就不會噴一堆 error 啦！</description>
    </item>
    
    <item>
      <title>remind-daniel</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/remind-daniel/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/remind-daniel/</guid>
      <description>今天終於把登入做完了 我覺得最重要的是找好的教學文章、去看沒有人看得懂的程式碼</description>
    </item>
    
    <item>
      <title>sqlite</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/sqlite/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/sqlite/</guid>
      <description>昨天是試著去理解 sqlite3，我發現他的 callback function 真的太煩了 於是我試著去尋找 async 的版本，還真找到了 這個套件把整個 sqlite 包成 async 了</description>
    </item>
    
    <item>
      <title>unix-socket</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/unix-socket/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/unix-socket/</guid>
      <description>今天心血來潮在看 unix socket 突然想到 node 可不可以把 服務監聽在一個 socket file 這樣在設定的時候就不用記哪個服務是幾 port
node 部份 監聽在 unix socket 查完資料後發現其實只要把原本填 port 的地方改成 socket file 的路徑就好了 像這樣
const express = require(&amp;#39;express&amp;#39;); const app = express(); app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; { res.send(&amp;#39;Hello World\n&amp;#39;); }); app.listen(&amp;#39;/tmp/express.sock&amp;#39;); 刪除 socket file 因為每次的 listen 都會新增一個 socket file 相當於佔用一個 port 如果不刪除的話就相當於 port 被佔用了 會噴錯 所以每次程式結束的時候要把這個 socket file 刪掉 然後在 /tmp 下的檔案會在開機後自動刪掉 所以如果部屬後發什麼問題重開機就對了！ 修改完的 code 長這樣
const fs = require(&amp;#39;fs&amp;#39;); const express = require(&amp;#39;express&amp;#39;); const app = express(); app.</description>
    </item>
    
  </channel>
</rss>
