<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Simba&#39;s Blog</title>
    <link>https://blog.simba-fs.dev/posts/</link>
    <description>Recent content in Posts on Simba&#39;s Blog</description>
    <image>
      <url>https://blog.simba-fs.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.simba-fs.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 30 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.simba-fs.dev/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang Parse All Files In Directory Into Templates</title>
      <link>https://blog.simba-fs.dev/posts/golang/golang-parse-all-files-in-directory-into-templates/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/golang/golang-parse-all-files-in-directory-into-templates/</guid>
      <description>在用 gin 寫伺服器的時候，我發現模板並不會被 go build 打包進執行檔裡面，所以在執行的時候就找不到檔案，當然這個問題可以用字串的形式直接把模板放進 golang 原始碼裡面，但是這樣程式碼一複雜就會不好用，這時候就可以用 golang 的 embed 函式庫把檔案「嵌入」到原始碼裡面。但是問題又來了，嵌入了之後要怎麼把字串變成模板物件呢？
Embed  embed 套件是 1.16 新出的功能，所以如果想用的話記得要更新 go 到 1.16 以上
 embed 嵌入檔案的方式是透過特殊格式的註解宣告，直接看官方範例：
package main import ( &amp;#34;embed&amp;#34; ) //go:embed hello.txt var s string //go:embed hello.txt var b []byte //go:embed hello.txt var f embed.FS func main() { print(s) print(string(b)) data, _ := f.ReadFile(&amp;#34;hello.txt&amp;#34;) print(string(data)) } 可以看到，embed 可以把檔案讀成三種格式 string、[]byte、embed.FS，前兩者只能讀「一個」檔案，如果你只用這兩個的話引入時要用 _ &amp;quot;embed&amp;quot;。embed.FS 除了可以嵌入多個檔案之外，因為實做了 fs.FS 所以可以使用當作一個檔案系統操作。
Tmeplate No Recursive 最簡單的方法，你可以直接使用
// go:embed view/* var f embed.</description>
    </item>
    
    <item>
      <title>ssh on gitea with docker</title>
      <link>https://blog.simba-fs.dev/posts/linux/server/ssh-on-gitea-with-docker/</link>
      <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/server/ssh-on-gitea-with-docker/</guid>
      <description>Gitea 是一個開源的 git 伺服器，他的界面幾乎和 GitHub 一模一樣，但是完全開源而且非常輕，甚至一片樹梅派就可以開伺服器了。Gitea 因為是使用 Golang 編寫的，所以提供各種平台的執行檔。我選擇透過 docker 裝 Gitea 伺服器，但是這樣有一個問題，gitea 伺服器開在 container 內，沒辦法使用標準的 22 port，所以 git clone 就必須加上一個醜醜的數字，像是這樣
git clone git@domain:10022:user/repo.git 這個問題 Gitea 官方已經有提供完整的教學了，但是是英文版，我這篇文章是我讀完消化過後的中文版教學
容器 ssh 穿透 因為 Gitea 的 ssh 是跑在容器裡，我沒辦法讓他和 host 共用 22 port，所以要透過 host 「轉發」連線。
1. 建立 git 使用者 先在 host 建立一個名叫 git 的使用者，因為這個帳號會被對應到容器內的 git 使用者，所以要有一樣的 UID, GID
sudo adduser git grep git /etc/passwd 記好 git 的 UID 和 GID
git:x:1002:1002:,,,:/home/git:/bin/bash ------^^^^ ^^^^ ------GID UID 2.</description>
    </item>
    
    <item>
      <title>taiwan-town-location</title>
      <link>https://blog.simba-fs.dev/posts/other/taiwan-town-location/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/other/taiwan-town-location/</guid>
      <description>這是一個給經緯度吐地址的 api，甚至路段都會出來，搭配 web geolocation api 蠻不錯的，精確度不錯。可以不知道有沒有 rate limited 的問題，目前看起來連 token 都不用。
網址 https://api.nlsc.gov.tw/other/TownVillagePointQuery/
用法 https://api.nlsc.gov.tw/other/TownVillagePointQuery/經度/緯度
舉例： request GET https://api.nlsc.gov.tw/other/TownVillagePointQuery/121.46278679999999/25.0169826 response &amp;lt;townVillageItem&amp;gt; &amp;lt;ctyCode&amp;gt;F&amp;lt;/ctyCode&amp;gt; &amp;lt;ctyName&amp;gt;新北市&amp;lt;/ctyName&amp;gt; &amp;lt;townCode&amp;gt;F14&amp;lt;/townCode&amp;gt; &amp;lt;townName&amp;gt;板橋區&amp;lt;/townName&amp;gt; &amp;lt;officeCode&amp;gt;FA&amp;lt;/officeCode&amp;gt; &amp;lt;officeName&amp;gt;板橋&amp;lt;/officeName&amp;gt; &amp;lt;sectCode&amp;gt;0008&amp;lt;/sectCode&amp;gt; &amp;lt;sectName&amp;gt;民權段&amp;lt;/sectName&amp;gt; &amp;lt;villageCode&amp;gt;65000010020&amp;lt;/villageCode&amp;gt; &amp;lt;villageName&amp;gt;漢生里&amp;lt;/villageName&amp;gt; &amp;lt;/townVillageItem&amp;gt; 參考資料 https://data.gov.tw/dataset/101898</description>
    </item>
    
    <item>
      <title>Cast Phone Screen to Computer</title>
      <link>https://blog.simba-fs.dev/posts/linux/software/cast-phone-screen-to-computer/</link>
      <pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/software/cast-phone-screen-to-computer/</guid>
      <description>有沒有一種經驗是某的應用程式手機板操作勉強算順暢，但是一電腦上就炸開，反應慢到靠北、界面又很難用（沒錯 messenger 我正在看著你）。這個時候相信你會和我一樣想把手機畫面投影到電腦上的一個視窗裡面，最好可以互動、可以打字。有人第一個想法是在手機開 VNC 伺服器，但是這個方法有點麻煩，這篇文章介紹的是目前我覺得最佳解決方案。
SCRCPY 這個軟體支援有線（ USB debug ）、無線（ WIFI ）的連接，還支援螢幕錄影和傳檔案。最重要的是，開在電腦上的視窗可以調整大小，不需要侷限在一個小小的視窗內，你最大可以放大到全螢幕！在某種意義上你獲得了一台和電腦一樣大的手機。
Installation 安裝流程意外的簡單，只需要用 apt 就可以安裝了，或是你可以自己 build，稍微看了一下 說明 ，看起來不困難，但是既然 apt 就可以安裝了我們就省一點時間
$ sudo apt install scrcpy USB debug 首先無論是有線無線都要先打開手機的 USB debug 選項，在開發人員選項裡面，詳細步驟請看 官方文件。
USB 如果不介意有一條線插著~~（順便充電）~~的話，投影畫面非常簡單，只有兩個步驟：
 插上 USB 並且無論跳出什麼都按「同意」「OK」 打開終端機，執行 scrcpy 然後就會有一個視窗跳出來，你現在就可以在電腦上滑手機了！  Wireless 無線的話比較麻煩，首先是必須要可以連線，看是在同一個區域網路或是 VPN、ssh tunnel 都可以。再來是因為連線設定頗麻煩，所以我把相關的步驟寫成一個 script，下載後給予執行權限就可以執行了（當然要安裝 scrcpy ）。有線的方式一樣很簡單，不用加任何選項就可以連接了。
如果要啟用無線，只需要加上 -w 選項（用預設的 ip 192.168.43.1)
如果 ip 不是預設的話，可以加上 -i IP 來指定其他的 ip
加上 -f 可以開啟全螢幕
參連連結 https://github.com/Genymobile/scrcpy https://developer.android.com/studio/debug/dev-options https://gist.github.com/simba-fs/9132289f63368ad325d6a2ef62be7a20</description>
    </item>
    
    <item>
      <title>YouComopleteMe install</title>
      <link>https://blog.simba-fs.dev/posts/linux/vim/youcomopleteme-install/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/vim/youcomopleteme-install/</guid>
      <description>下載 source code  編輯 ~/.vimrc  Plug &amp;#39;Valloric/YouCompleteMe&amp;#39;接著按下 esc:w | so %載入設定 接著 :PlugInstall下載 source code 存檔離開  編譯  執行 sudo apt install python3-dev build-essential 進入 ~/.vim/plugged/YouCompleteMe 執行 ./install.py --help 並挑選需要的選項 執行 ./install.py &amp;lt;你要的選項&amp;gt;  </description>
    </item>
    
    <item>
      <title>firefox touch screen scroll</title>
      <link>https://blog.simba-fs.dev/posts/linux/software/firefox-touch-screen-scroll/</link>
      <pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/software/firefox-touch-screen-scroll/</guid>
      <description>再換了觸控筆電後，在 firefox 一直有個問題：觸控往下滑會被當成選取，要卷動一定要用右邊的 scroll bar
解決方案 按照 https://askubuntu.com/questions/853910/ubuntu-16-and-touchscreen-scrolling-in-firefox 的最佳解法，真的加上 MOZ_USE_XINPUT2=1 的環境變數就可以了。
另外在設定 ~/.local/share/applications/firefox.desktop 的時候要注意有不只一個 Exec，改完如果沒有生效可以重開機看看。</description>
    </item>
    
    <item>
      <title>beginning of kotlin</title>
      <link>https://blog.simba-fs.dev/posts/kotlin/beginning-of-kotlin/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/kotlin/beginning-of-kotlin/</guid>
      <description>val vs var    kotlin JS     val const   var let    a..b    kotlin JS     a..b Array(b-a+1).fill(0).map(i =&amp;gt; i + a)    when kotlin fun main (){ val luckyNum = 4 val yourNum = (1..6).random() val result = when(yourNum){ luckyNum -&amp;gt; &amp;#34;You get the lucky num ${luckyNum}&amp;#34; 1 -&amp;gt; &amp;#34;Sorry, you get 1&amp;#34; 2 -&amp;gt; &amp;#34;Sorry, you get 2&amp;#34; 3 -&amp;gt; &amp;#34;Sorry, you get 3&amp;#34; 4 -&amp;gt; &amp;#34;Sorry, you get 4&amp;#34; 5 -&amp;gt; &amp;#34;Sorry, you get 5&amp;#34; 6 -&amp;gt; &amp;#34;Sorry, you get 6&amp;#34; else -&amp;gt; &amp;#34;Sorry, you get a number out of 1.</description>
    </item>
    
    <item>
      <title>college-exam-interview-and-written-test</title>
      <link>https://blog.simba-fs.dev/posts/other/college-exam-interview-and-written-test/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/other/college-exam-interview-and-written-test/</guid>
      <description>師大科技系面試  兩關各十分鐘
 第一關：  自我介紹 一分鐘補充說明（有利備審、競賽）解決問題的經驗 自由談話時間  第二關：  自我介紹一分鐘 科技系分幾組？差別在哪？你會選哪組？ 我看你的自傳有寫「專案開發」，有例子嗎？ 如果團隊合作時有人擺爛，你會怎麼做？（20秒）  心得 這個系是團體面試，三個教授對三個考生，輪流回答問題，因為我是那組第一個，所以幾乎都是我先回答，教授沒有問什麼很難得問題，另外系主任看起來人很好。</description>
    </item>
    
    <item>
      <title>logitech-mouse-permission-error</title>
      <link>https://blog.simba-fs.dev/posts/linux/software/logitech-mouse-permission-error/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/software/logitech-mouse-permission-error/</guid>
      <description>前言 我的無線華和滑鼠和鍵盤都是羅技的，在我的 Ubuntu 筆電上一直都沒有問題。有一次我想改我的鍵盤被配置，但是因為 logitech unifying 沒有 Linux 版，所以我另一個軟體叫 solaar，功能是差不多的。 當我裝好軟體以後，鍵盤滑鼠操作都沒問題，只有插上滑鼠的接收器以後都對跳出一個 permission error 的錯誤視窗。雖然在 solaar 裡面就無法看到我的滑鼠就是了，但是完全不影響使用，所以我就擺在那邊放它爛，反正就是多按一個叉叉。
嘗試自己解 今天閒閒沒事做剛好來看看這個怎麼解。我一開始想說，把他的 permission 改成和鍵盤一樣就啦！於是我進行了下面的操作
$ ls /dev/hidraw* 拔下鍵盤的接收器，發現他是 /dev/hidraw4 和 /dev/hidraw5，再插上去。拔下滑鼠接收器，發現他是 /dev/hidraw2。
並找到鍵盤的權限是 rw-rw----，滑鼠是 rw-------。
$ chmod 660 /dev/hidraw2 拔下滑鼠接收器，插上。
沒用。
我猜這個方法會失敗應該是因為他在我改之前就已經先跳錯誤了，等我改完它右沒有偵測，我就得把它拔下來在插上去，我又會看到錯誤訊息&amp;hellip;&amp;hellip; (looping
於是我上網找答案
網路上的解 我 Google ubuntu logitech permission error 第一個就是我要的！</description>
    </item>
    
    <item>
      <title>libreoffice-code-format-plugin-install</title>
      <link>https://blog.simba-fs.dev/posts/linux/software/libreoffice-code-format-plugin-install/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/software/libreoffice-code-format-plugin-install/</guid>
      <description>安裝  去 https://extensions.libreoffice.org/en/extensions/show/code-highlighter 下載最新的外掛 把檔名前面的前綴刪掉，   例如：ea4db15f_codehighlighter.oxt -&amp;gt; codehighlighter.oxt
 安裝相依性套件  sudo apt install libreoffice-script-provider-python python3-pip sudo pip3 install pygments 安裝外掛   工具 &amp;gt; 擴充套件管理員 &amp;gt; 加入 &amp;gt; 選擇你的檔案
 使用  插入文字方塊   插入 &amp;gt; 文字方塊
 貼上程式碼 選擇文字方塊，不是文字（按文字方塊的邊邊） format   工具 &amp;gt; highlight code &amp;gt; 選得語言、style
 參考資料 Libreoffice extensions issue</description>
    </item>
    
    <item>
      <title>strapi-quick-start</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/strapi-quick-start/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/strapi-quick-start/</guid>
      <description>strapi 是一個 headless CMS (content management system)，透過 web 介面就可以建立一個 api server
strapi 什麼是 headless CMS headless CMS 顧名思義是「無頭的 內容管理系統」，意思是沒有前端、只有後端，它就是一個 DB 的 web 界面 + api server。headless CMS 專注於處理 api 的部份，前端的部份一律不關心。這對於前後端分離有很大的幫助，基本上 headless CMS 已經解決了後端 80% 的工作，剩下的就是一些客製化的邏輯，像是登入、特殊的計算等等。
strapi 的優點  他的界面完善 支援多種 DB   MySQL &amp;gt;= 5.6
MariaDB &amp;gt;= 10.1
PostgreSQL &amp;gt;= 10
SQLite &amp;gt;= 3
MongoDB &amp;gt;= 3.6
 存取權限控制 外掛  quickstart 以下步驟是補充 官網的 quick start
 安裝
$ npx create-strapi-app my-project --quickstart; cd my-project</description>
    </item>
    
    <item>
      <title>node-vm</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/node-vm/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/node-vm/</guid>
      <description>node.js VM 模組 VM 是 node.js 的核心模組，提供安全的環境 (沙箱) 來測試不信任的程式碼。
基本概念 在 VM 模組裡面，有兩個基本的物件，script 和 context。script 是經過「編譯」程式，context 是給在沙箱裡面的程式碼的全域物件 (global) 。沙箱中的程式只能存取透過 context 指定的物件。
建立 script VM 模組提供 Script 建構子，可以透過他來建立 Script 物件。
const vm = require(&amp;#39;vm&amp;#39;); const script = new vm.Script(&amp;#39;i++&amp;#39;); 也可以用 vm.createScript
const vm = require(&amp;#39;vm&amp;#39;); const script = vm.createScript(&amp;#39;i++&amp;#39;);  vm.Script
vm.createScript 在 nodejs docs 上我沒有找到，但是我在自己的電腦上 (node v14.15.0) 測試是可以用的
 建立 context vm 模組沒有提供建立 context 的建構子，我們只能透過 vm.createContext 來建立 context。
注意 vm.createContext 不是 pure function，除了會回傳 context 以外，還會把傳入的物件變成 context，兩者傳入 vm.</description>
    </item>
    
    <item>
      <title>hCaptcha</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/hcaptcha/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/hcaptcha/</guid>
      <description>前情提要 我們社團的短網址服務裡面常常出現一些奇怪的網址，我猜可能是有機器人在刷，所以我想加入 captcha 減少這類問題。我選擇的是 hCaptcha 這套，能不依賴 Google 就盡量不要。
安裝步驟 申請帳號 先到 hCaptcha 註冊、新增一個網站，複製 sitekey (Sites &amp;gt; site setting) 和 secret key (Settings)，我們等等會用到
前端  首先引入 script ，在 &amp;lt;head&amp;gt; 加入  &amp;lt;script src=&amp;#34;https://hcaptcha.com/1/api.js&amp;#34; async defer&amp;gt;&amp;lt;/script&amp;gt; 接著在你的 &amp;lt;form&amp;gt; 裡面加入，這邊的 your_site_key 就是剛剛複製的那個。記得 &amp;lt;form&amp;gt; 的 method 要設成 post  &amp;lt;div class=&amp;#34;h-captcha&amp;#34; data-sitekey=&amp;#34;your_site_key&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 後端（node express）   SECRET
首先，你要把剛剛的 SECRET 給 server 知道，我用的是 dotenv，當然其他的套件也是可以。
簡而言之，剛剛複製下來的 SECRET 就是用在這裡。
  驗證 後端我選用的套件是 express-hcaptcha ，它提供一個 middleware 驗證 hcaptcha 的 token。 按照 README.</description>
    </item>
    
    <item>
      <title>docker login error</title>
      <link>https://blog.simba-fs.dev/posts/linux/docker/docker-login-error/</link>
      <pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/docker/docker-login-error/</guid>
      <description>錯誤說明 昨天我在 terminal 登入 docker 的時候發現不知道為什麼不能登入，我先透過網頁登入確認過密碼沒有問題，也不是打錯字的關係，但還是不能當入。總是會有類似以下的錯誤訊息。
Error saving credentials: error storing credentials - err: exit status 1, out: `exit status 1: gpg: simbafs: 已跳過: 沒有公鑰 gpg: [stdin]: encryption failed: 沒有公鑰 Password encryption aborted.` 解決方法 經過搜尋之後，我按照 https://github.com/docker/docker-credential-helpers/issues/102#issuecomment-388634452 的方法成功登入了，但是在這之前要先安裝 gpg 和 pass
apt install gnupg2 pass 接下來是我用的指令
apt install gnupg2 wget https://github.com/docker/docker-credential-helpers/releases/download/v0.6.3/docker-credential-pass-v0.6.3-amd64.tar.gz tar xvf docker-credential-pass-v0.6.3-amd64.tar.gz chmod 755 docker-credential-pass sudo mv docker-credential-pass /usr/bin/ ass insert docker-credential-helpers/docker-pass-initialized-check pass insert docker-credential-helpers/docker-pass-initialized-check pass show docker-credential-helpers/docker-pass-initialized-check docker-credential-pass list docker login 參考連結  https://github.</description>
    </item>
    
    <item>
      <title>connect to ethernet in docker container</title>
      <link>https://blog.simba-fs.dev/posts/linux/docker/connect-to-ethernet-in-docker-container/</link>
      <pubDate>Sat, 28 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/docker/connect-to-ethernet-in-docker-container/</guid>
      <description>如何在 docker container 裡連接 ethernet 今天突然有個需求是在一個已經開啟的 container 弄東西，需要網路，但是不知道為什麼一直不上，後來發現是 docker 沒有設定 DNS 的問題，只要在外面輸入兩行指令就可以了
DOCKER_OPTS=&amp;#34;--dns 8.8.8.8&amp;#34; systemctl restart docker 然後重新啟動 docker</description>
    </item>
    
    <item>
      <title>docker commit</title>
      <link>https://blog.simba-fs.dev/posts/linux/docker/docker-commit/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/docker/docker-commit/</guid>
      <description>前言 上次提到可以用 Dockerfile 建立 docker image，但我們還有令一個方法可以建立 docker image，那就是 docker commit 指令
和 Dockerfile 差別 docker commit 有點像是手動版的 Dockerfile，在用 Dockerfile 建構 docker image 的時候，docker build 的工作就像是自動根據 Dockerfile 操作 docker commit。 Dockerfile 比較適合用在自動化交付和部屬，例如說你有一份程式碼，要將他包成 Docker 就很適合用 Dockerfile 自動化操作，因為程式碼會改變，但是包裝的流程基本上都是一樣的。 docker commit 適合用在建構環境，因為會有比較麻煩的操作，如果寫成 Dockerfile 會比較麻煩，當然如果可以的話還是寫成 Dockerfile 會比較好，因為更新的時候會比較方便。 在建構 image 的時候要用哪個方法就看個人取捨了。
docker commit 指令 docker commit 可以把運行中的 comtainer 轉成 images，有點類似令存新檔的概念。先來看看參數吧！
參數 $ docker commit --help Usage:	docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] Create a new image from a container&amp;#39;s changes Options: -a, --author string Author (e.</description>
    </item>
    
    <item>
      <title>bash number loop</title>
      <link>https://blog.simba-fs.dev/posts/linux/bash/bash-number-loop/</link>
      <pubDate>Sun, 15 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/bash/bash-number-loop/</guid>
      <description>今天在某的地方剛好看到一個 bash 的小技巧，當我們要從 1 數到 100 時，通常會用 seq 指令來做，但是如果我們的需求剛剛好是每次遞增（遞減）1 的話，就可以使用 {start..end} 縮寫，下面兩個範例的效果是一樣的：
# for 迴圈 + seq 的寫法 for i in $(seq 1 1 100); do echo $i done # 用 {start..end} echo {1..100} 這個技巧也可以用在建立檔案，像這樣：
touch user{1..100} </description>
    </item>
    
    <item>
      <title>bash completion</title>
      <link>https://blog.simba-fs.dev/posts/linux/bash/bash-completion/</link>
      <pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/bash/bash-completion/</guid>
      <description>需求 今天寫了一個 bash script 幫我管理 mongodb docker，在使用的時候一些子命令，像是 up、down、clean。我希望可以讓 bash 當我自動補齊這些選項。
bash_completion bash_completion 是一個可以幫我們做程式化補齊的工具，像是 git 就有使用到這個工具，在 commit、push 的時候按 tab 都會顯示出當下我們可以用的東西，像是 git push&amp;lt;tab&amp;gt;&amp;lt;tab&amp;gt; 就會自動補齊 origin 而不是給我們看檔案（bash 預設只會補齊檔案和命令）。我們這次只須要用基本的 complete 就可以了
complete complete 可以幫命令加上簡單的自動完成，其實 bash_completion 也是去呼叫這個命令來達成自動補齊。complete 傻用非常簡單，像下面這樣就可以幫 mongodb 這個命令加上自動補齊
complete -W &amp;#34;up down clean&amp;#34; mongodb -W 選項代表後面是字詞列表，用 -F 後面可以接一個函數，但是這個我沒研究，也許下一個專案就是研究 complete 也說不定。</description>
    </item>
    
    <item>
      <title>Mongoose Model</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/mongoose-model/</link>
      <pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/mongoose-model/</guid>
      <description>Mongoose Model 環境設定 這是這次實驗用的 code
const mongoose = require(&amp;#39;mongoose&amp;#39;); mongoose.connect(&amp;#39;mongodb://127.0.0.1:27017&amp;#39;, {useNewUrlParser: true, useUnifiedTopology: true}) .then(() =&amp;gt; console.log(&amp;#39;Connected to DB&amp;#39;)) .catch(e =&amp;gt; console.error(e)); const requiredString = { type: String, required: true } const UserSchema = new mongoose.Schema({ username: requiredString, password: requiredString }); const UserModel = mongoose.model(&amp;#39;User&amp;#39;, UserSchema); mongo db 用 docker 開一個實驗用的 server
version: &#39;3&#39; services: db: image: &#39;mongo&#39; container_name: &#39;aurl-mongodb&#39; volumes: - ./data/mongo:/data/db - ./data/dump:/dump ports: - &#39;27017:27017&#39; 取得原 schema 在一般操作的時候都是用 UserModel 在操作資料庫，當要取得 schema 的時候當然也是從他裡面找最方便，當然也可以把 schema 特別弄出來，但是有點麻煩，以這次的例子說明，原本的 UserSchema 會存在 UserModel.</description>
    </item>
    
    <item>
      <title>docker 基礎指令</title>
      <link>https://blog.simba-fs.dev/posts/linux/docker/docker-%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/docker/docker-%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/</guid>
      <description>Install apt install docker docker.io docker-compose What is docker Docker 是一個容器化的技術，基本上使用的時候可以把他當成虛擬機，雖然他們的使用的技術完全不一樣。對新手來說，在 Docker 裡面有四個重要的名詞：dockerfile, docker image, docker container, docker-compose。
 dockerfile
純文字檔，定義建立 docker image 的步驟，有點像是一個 bash shell。通常命名成 Dockerfile ，在 build 的時候會預設用這個，也可以用 -f 來指定其他的檔案。 docker image
這是透過 docker build 編譯出來的東西。可以想成 docker container 的藍圖，在 docker pull 的時候也是下載 docker image 而不是 dockerfile。基本上 image 裡面已經包括了編譯好的執行檔和基本的環境設定，所以在 docker 外面是不用做他設定的，這也是 docker 的魅力所在。 docker container
每個 docker image 可以產生很多個 container，也就是執行中的程式。在這裡你已經可以用 docker 來建立各種服務了。這裡也可以想像成虛擬機，用 docker exec -it container_name bash 可以進到 container 裡面(如果裡面有 bash 的話) docker-compose</description>
    </item>
    
    <item>
      <title>mxlinux boot with systemd</title>
      <link>https://blog.simba-fs.dev/posts/linux/mxlinux-boot-with-systemd/</link>
      <pubDate>Sat, 05 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/mxlinux-boot-with-systemd/</guid>
      <description>問題 在 mxlinux 裡面，預設的 init 不是 systmed，這導致如果想用 systemctl 的時候就會跳出錯誤說
System has not been booted with systemd as init system 像是在安裝 mongodb-org 的時候他就要用到 systemctl 然後就會出錯。
解法 其實 mxlinux 已經幫我們想好解法了，在開機選項時選 Advence &amp;gt; Systemd 就會以 systemd 開機</description>
    </item>
    
    <item>
      <title>node require from project root</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/node-require-from-project-root/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/node-require-from-project-root/</guid>
      <description>問題 在寫一個專案的時候，有時候會有一些小程式重複在不同的檔案裡用到，這時候我們會把他打包成模組放在 lib/。但是如果資料夾結構有點點複雜的時候， require() 的路徑就會很複雜：
. ├── index.js ├── lib │ └── random.js └── routes └── page └── signup └── index.js 在 index.js 裡面如果要引入 random.js 就會變成這樣
const random = require(&amp;#39;../../lib/random.js&amp;#39;); 爛解法 如果我們想要直接用 require(&#39;lib/random&#39;) 的話做簡單的方式是上傳 npm，但是這樣稍嫌麻煩，而且別的專案不一定用的到。每一次修改都要上傳 npm 很不方便。
好解法 在 linux 裡面要把執行檔做成指令有兩個方法
 放到 /usr/bin 之類的地方 把這個路徑直接加到 PATH 裡面  在 node 裡面也有 path 設定，module.paths，在 require 時會去這個裡面的目路尋找檔案。所以如果要達成上述的功能的話就只要加這行就可以了
module.paths.push(process.cwd()); 這樣就可以直接用 require(&#39;lib/random&#39;) 引入了
參考資料 https://github.com/nodejs/node/issues/4223
https://github.com/nodejs/node/issues/1979
https://www.npmjs.com/package/rooty
^^^
這個是在 github issue 裡面看到的，沒試過，但是應該也可以用吧？只是我覺得沒有 paths 的解法來的優雅。</description>
    </item>
    
    <item>
      <title>vim auto comment plugin</title>
      <link>https://blog.simba-fs.dev/posts/linux/vim/vim-auto-comment-plugin/</link>
      <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/vim/vim-auto-comment-plugin/</guid>
      <description>套件 nerdcommenter
好用的指令 在每次動作前都要按 &amp;lt;leader&amp;gt;，預設是 反斜線 \
c&amp;lt;space&amp;gt; 簡單來說就是 toggle 你的註解
cA 跳到行尾並在行尾加上註解</description>
    </item>
    
    <item>
      <title>文章更新時間錯亂問題</title>
      <link>https://blog.simba-fs.dev/posts/hexo/%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E6%99%82%E9%96%93%E9%8C%AF%E4%BA%82%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/hexo/%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E6%99%82%E9%96%93%E9%8C%AF%E4%BA%82%E5%95%8F%E9%A1%8C/</guid>
      <description>問題 在設定完 GitHub Action 之後，我發現我的文章的更新時間都錯了，會全部變成當天日期。但是本地生成的就沒有這個問題，經過一番盤查和猜測後，我發現問題是因為 git 不會把 modified date 紀錄，因為每台電腦的時區都是不一樣的，紀錄起來沒有意義。但是我們需要這項 meta data，所以我們就要自己想法紀錄
解法 v1.0 首先，因為每一篇文章 hexo 都會紀錄建立時間，所以我們可以直接把他抓出來，然後把檔案的更新時間設成這個時間就可以啦！
更改檔案的 modified time 這個功能只要用我們最熟悉的 touch 就可以做到了。一般我們使用 touch 的時候會把 modified time 改成當下時間，那要改任意時間只要加上 -t 選項就可以啦
-t STAMP use [[CC]YY]MMDDhhmm[.ss] instead of current time 假設我們有個檔案 tmp ，我想把他的日期改成 1999/3/23 12:32:33 ，那我可以這樣下指令
ted timeouch -t&#39;19993231232.33&#39; tmp 抓出檔名、日期 # git create time grep -rnw source/_posts -e &amp;#39;date&amp;#39; output:（這裡的 date: 後面我多加了一個空白，原因後面會說）
source/_posts/hexo-installation.md:3:date: 2020-02-10 17:26:45 source/_posts/blessed.md:3:date: 2020-02-17 23:24:10 source/_posts/bash.md:3:date: 2020-02-16 22:15:10 source/_posts/hexo-cli-extras.</description>
    </item>
    
    <item>
      <title>express 重複 send</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/express-%E9%87%8D%E8%A4%87-send/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/express-%E9%87%8D%E8%A4%87-send/</guid>
      <description>問題 在 express route 裡面，我通常會在 res.send() 之類的函式前面都會加一個 return 防止因為程式邏輯漏洞造成重複送出然後噴 error。像是這樣
route.get(&amp;#39;/&amp;#39;, (req, res, next) =&amp;gt; { return res.send(&amp;#39;Hello world&amp;#39;); }); 但是如果我們用到 Promise 的時候 return 並不會跳出整個 route，所以我們需要另一個方法，我的想法是一個變數儲存是否送出，然後在每次送出前都判斷，送出候更改變數值
+--------------------------+ | is sent( flag === false) | +-+------------------------+ |no | +-+----+ | send | +-+----+ | +-+-----------+ | change flag | +-------------+ route.get(&amp;#39;/&amp;#39;, (req, res, next) =&amp;gt; { let flag = false; doSomePromise() .then(() =&amp;gt; { // do something  if(!flag){ res.send(&amp;#39;Hello world&amp;#39;); flag = true; } }) }) 這樣就不會噴一堆 error 啦！</description>
    </item>
    
    <item>
      <title>加入 google search 和 sitemap</title>
      <link>https://blog.simba-fs.dev/posts/hexo/%E5%8A%A0%E5%85%A5-google-search-%E5%92%8C-sitemap/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/hexo/%E5%8A%A0%E5%85%A5-google-search-%E5%92%8C-sitemap/</guid>
      <description>前置設定 npm 安裝 hexo-generator-sitemap npm i -S hexo-generator-sitemap 設定插件 將以下內容加到 _config.yml
 注意空白
 # sitemap sitemap: path: sitemap.xml 驗證網域 如果你的 hexo 是架在自己的網域可以跳過這步
因為我的 hexo 是 託管在 GitHub page，在 Google Search Console 驗證的時候沒辦法用網域，所以要放一個特別的檔案到我們的網站根目錄
 首先到 Google Search Console 新增一個網域 選擇右邊，輸入你的網址  下載提供的 html 並放到 source/ 資料夾  忽略 接下來會遇到 hexo 在生成的時候把這個 html 也放到模板裡面，所以我們要把他加入忽略清單裡面
在 _config.yml 裡面找到 skip_render
把直接檔名寫在後面或是用清單都可以   注意空白
 # 直接寫 skip_render: &amp;#39;googlebabababababa.html&amp;#39; # 或是用清單 skip_render: - &amp;#39;googlebabababababa.</description>
    </item>
    
    <item>
      <title>GitHub Action 自動部署 hexo</title>
      <link>https://blog.simba-fs.dev/posts/hexo/github-action-%E8%87%AA%E5%8B%95%E9%83%A8%E7%BD%B2-hexo/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/hexo/github-action-%E8%87%AA%E5%8B%95%E9%83%A8%E7%BD%B2-hexo/</guid>
      <description>前言 本來部署 hexo 都是手動下指令，但是這樣在手機上因為沒辦法裝 hexo ,所以一直不能在手機上寫文章。剛好想到 GitHub Action 可以滿足我的需求，上網查了一下資料發現蠻多人有和我一樣的需求，這次參考的是 owlran 大大的文章。
ssh key 因為要部署到 GitHub repo，最方便的方法當然是 ssh key 啦。
ssh-keygen 首先隨便找個資料夾產生一組 ssh key
ssh-keygen -f deploy-key GitHub 再來要讓 GitHub 知道你的 ssh key（public/secret 都要）
public key public key 是要放在你的 &amp;lt;username&amp;gt;.github.io 的 repo 下
 .ggithub.io -&amp;gt; settings -&amp;gt; Deploy keys -&amp;gt; add deploy key
 新增一個 ssh key，名字叫 DEPLOY_KEY_PUB
把 depoly-key.pub 的內容貼上，記得下面的勾勾（Allow write access ）要選起來
secret key secret key 要放在你存放部落格檔案的 repo，owlran 大大是放在同一個 repo 不同 branch，我是放在兩個不同 repo，其中放部落格檔案的 repo 我設成 private repo（因為我放了一些 gitalk 要用的 clientSecret，這個不能公開）。</description>
    </item>
    
    <item>
      <title>React update state on props change</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/react/react-update-state-on-props-change/</link>
      <pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/react/react-update-state-on-props-change/</guid>
      <description>問題 今天在研究 React 遇到一個問題 當我從外面更新 props 的時候 component 內的 state 不會更新
function Input(props){ const [text, setText] = React.useState(props.text); return ( &amp;lt;input type=&amp;#34;text&amp;#34; value={text}&amp;gt; ) } 如同上面程式，第二行的 useState 不會隨著 props 更新而更新
解法 後來找到解法，加上一個 useEffect 監聽 props.text 然後更新 state 就好了
function Input(props){ const [text, setText] = React.useState(props.text); React.useEffect(() =&amp;gt; { setText(props.text); }, [props.text]); return ( &amp;lt;input type=&amp;#34;text&amp;#34; value={text}&amp;gt; ) } 如此一來 state 就會和 props 同步了
參考資料 https://stackoverflow.com/questions/54865764/react-usestate-does-not-reload-state-from-props https://zh-hant.reactjs.org/docs/hooks-effect.html</description>
    </item>
    
    <item>
      <title>讓 YCM 接受 jsx</title>
      <link>https://blog.simba-fs.dev/posts/linux/vim/%E8%AE%93-ycm-%E6%8E%A5%E5%8F%97-jsx/</link>
      <pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/vim/%E8%AE%93-ycm-%E6%8E%A5%E5%8F%97-jsx/</guid>
      <description>最近寫ˋreact 的時候只要遇到 jsx 語法 YCM 就會跳出這個錯誤
Cannot use JSX unless the &#39;--jsx&#39; flag is provided. (FixIt) 研究之後發現這是要給 tsserver 一個 --jsx 的 flag 就可以解決 爬文半個小時後發現只要在專案下的 jsconfig.json
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;target&amp;#34;: &amp;#34;es6&amp;#34;, &amp;#34;checkJs&amp;#34;: true + }, + &amp;#34;compilerOptions&amp;#34;: { + &amp;#34;jsx&amp;#34;: &amp;#34;react&amp;#34;  } } </description>
    </item>
    
    <item>
      <title>webpack-react</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/react/webpack-react/</link>
      <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/react/webpack-react/</guid>
      <description>前言 最近開始想學 react 在這之前當然要先把開發環境搞好 其中 react 最重要的就是 webpack 和 babel 了 babel 負責編譯 webpack 負責串街所有工作
安裝套件 建立一個專案並初始化 mkdir react-test cd react-test npm init -y git init -y 安裝開發用套件 npm i -D \ @babel/core \ @babel/cli \ @babel/preset-env \ @babel/preset-react \ babel-loader \ react \ react-dom \ webpack package.json 加入以下的 script
{ &amp;#34;dev&amp;#34;: &amp;#34;webpack --mode development&amp;#34;, &amp;#34;watch&amp;#34;: &amp;#34;webpack --mode development --watch&amp;#34;, &amp;#34;depoly&amp;#34;: &amp;#34;webpack --mode production&amp;#34; } webpack.config.js 建立 webpack.config.js 這是最小的版本了 沒有任何的擴充</description>
    </item>
    
    <item>
      <title>nginx-ui</title>
      <link>https://blog.simba-fs.dev/posts/linux/server/nginx-ui/</link>
      <pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/server/nginx-ui/</guid>
      <description>前幾天發現一個專案 nginx ui 他是一個可以讓你在網頁上更改 nginx config 的專案 安裝：
docker pull schenkd/nginx-ui 啟動；
docker run -p 8080:8080 -v /etc/nginx:/etc/nginx schenkd/nginx-ui 然後打開瀏覽器 http://localhost:8080 就可以看到管理頁面了 很陽春，就是不用 ssh 進 server，沒什麼特點 我應該是不會用這套</description>
    </item>
    
    <item>
      <title>HTML form button</title>
      <link>https://blog.simba-fs.dev/posts/frontend/html-form-button/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/frontend/html-form-button/</guid>
      <description>HTML 的 form 裡的按鈕預設是 submit 所以要加上 type=&amp;quot;button&amp;quot; 它才不會太心急送出表單
按鈕的 css 「按下」 selector 好像可已用 :active、:focus 但是我兩個失敗了</description>
    </item>
    
    <item>
      <title>mxlinux-change-workspace</title>
      <link>https://blog.simba-fs.dev/posts/linux/mxlinux-change-workspace/</link>
      <pubDate>Fri, 08 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/mxlinux-change-workspace/</guid>
      <description>切換工作區 今天想要在 mxlinux 中快速的切換工作區 我看到可以用滑鼠滾輪切換 可是我想要的是鍵盤快捷鍵 上網查了一下 發現可以透過 Ctrl+Alt+up/down/home/end 來切換
參考資料 https://unix.stackexchange.com/questions/270334/how-to-move-a-window-to-another-workspace-in-xfce</description>
    </item>
    
    <item>
      <title>gpg</title>
      <link>https://blog.simba-fs.dev/posts/linux/gpg/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/gpg/</guid>
      <description>今天心血來潮想設定 GPG，網路上查了一個教學，無疑的又遇到一個坑
坑 &amp;amp; 解法 我按照他的作法弄完後就是沒辦法 commit 他說 GPG 無法簽章 後來我發現是我的 name 填錯（應該啦，我猜的） 總而言之就重新產生 GPG key 就好了 name 和 git 設定的一樣
指令 $ gpg --full-gen-key $ gpg --list-secret-keys $ gpg --armor --export &amp;lt;secret key&amp;gt; 刪除金鑰 在刪除的時候分成兩步驟，刪除私鑰、刪除公鑰。在刪除之前要先知道要刪除的金鑰的 ID
gpg --list-keys 找到那串很長的文字，那就是 ID，複製起來，他起來也許會像這樣
JFDKSA8FEWHE29HFVC92UHFPA93WOHFVDOPA39U2 再來用兩個指令就可以刪除了，注意一定要先刪私鑰。
gpg --delete-secret-key &amp;lt;ID&amp;gt; gpg --delete-key &amp;lt;ID&amp;gt; </description>
    </item>
    
    <item>
      <title>meta-tag</title>
      <link>https://blog.simba-fs.dev/posts/frontend/meta-tag/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/frontend/meta-tag/</guid>
      <description>今天為了幫 Let&amp;rsquo;s Remind Daniel 做 SEO 在 免費資源網路社群 找到了一個工具可以直接生成 還有一個可以測試的工具
連結 生成 測試</description>
    </item>
    
    <item>
      <title>firefox-event-listener-breakpoint</title>
      <link>https://blog.simba-fs.dev/posts/frontend/firefox-event-listener-breakpoint/</link>
      <pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/frontend/firefox-event-listener-breakpoint/</guid>
      <description>問題 最近在用 jquery 但是不知道為什麼每次 debugger 都會跳出一個通知 很煩
解決 後來尋線發現原來是 firefox 好心的 debugger 在 DOM 發生改變的時候通知我 在 裡面 Debugger 頁籤左下有個拉頁叫「Event Listener Breakpoints」 把裡面的東西都點掉就好了 就是那個 DOM Mutation 心得 我原本還以為是 jquery 的問題 原來是好心的 firefox 啊</description>
    </item>
    
    <item>
      <title>jquery</title>
      <link>https://blog.simba-fs.dev/posts/frontend/jquery/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/frontend/jquery/</guid>
      <description>今天寫 jquery 遇到了一些坑
1. submit .submit() 是要加在 form 上而不是 submit button 上
2. this 在 jquery 裡有時後會用到 handler 正常情況下可以用 arrow function 但是如果用到 this 就不能用 arrow function 了 （這不只是 jquery, JS 都是這樣）</description>
    </item>
    
    <item>
      <title>remind-daniel</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/remind-daniel/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/remind-daniel/</guid>
      <description>今天終於把登入做完了 我覺得最重要的是找好的教學文章、去看沒有人看得懂的程式碼</description>
    </item>
    
    <item>
      <title>sqlite</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/sqlite/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/sqlite/</guid>
      <description>昨天是試著去理解 sqlite3，我發現他的 callback function 真的太煩了 於是我試著去尋找 async 的版本，還真找到了 這個套件把整個 sqlite 包成 async 了</description>
    </item>
    
    <item>
      <title>isolate</title>
      <link>https://blog.simba-fs.dev/posts/linux/isolate/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/isolate/</guid>
      <description>我有一個放了很久的計畫，就是自己寫一個 OJ，因為我覺得現在的那個太難用了。 我很快的建立 repo 但是卻完全沒有進展，我寫了一個 shell script 幫忙編譯執行程式之後我就在也沒有動過他了 我沒有繼續動工的原因是我不知道如何隔離使用者提交的程式碼 我想過 docker 可是據說還是不安全 還有 chroot 但是我不知道有沒有比 docker 安全而且設定好麻煩
昨天去考 TOI　入營考（當然沒進）的時候，我終於看到大名鼎鼎的 CMS 了！ 出來之後我發現他是用一個叫 isolate 的程式來做沙箱測試 而且這好像是 IOI 自己寫的，應該是蠻安全的（吧？） 今天成功編譯過後把心得寫下來</description>
    </item>
    
    <item>
      <title>youtube-dl</title>
      <link>https://blog.simba-fs.dev/posts/linux/youtube-dl/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/youtube-dl/</guid>
      <description>最近在下載 youtube 音樂，每次下載都要把檔案重新改名，很麻煩。所以就想要寫一個 shell script 來幫我解決。 首先改名字我相信 youtube-dl 一定有提供這個選項，於是開始查文件。 看到 -o ，接下來講遇到的坑
-o 坑 -o 後面接的是一個 template string ，不是檔名，而且就算指定副檔名是 .mp3 了還是要寫成 %(ext)s</description>
    </item>
    
    <item>
      <title>blessed-landmine</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/blessed/blessed-landmine/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/blessed/blessed-landmine/</guid>
      <description>這是一篇我在用 blessed 時踩的一些雷 會持續的更新
1. 記得 render 今天在寫 API 時踩到兩次 更新了資料卻沒有 render 例如 textarea.setValue() 這個函式設定完之後他畫面不會更新 要自己 render
2. textarea.setValue() 只接受字串當參數 我個人覺得 blessed 缺少一個像是 jquery 的函式庫 沒有一個很好的 API 包裝 例如說這個函式 textarea.setValue() 就只吃字串 因為他用了 String.prototype.replace 這個函數 而且他沒有一個很好的防呆機制例如參數型別檢查 幸好是他的程式碼沒有做 uglify 還算簡單易懂 而且 node 的錯誤訊息的 stack 可以引導到真正出錯的地方</description>
    </item>
    
    <item>
      <title>ssh-tunnel</title>
      <link>https://blog.simba-fs.dev/posts/linux/ssh-tunnel/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/ssh-tunnel/</guid>
      <description>昨天架好了 reverse ssh 讓我可以連回學校 server 今天來研究 ssh tunnel
簡介 ssh tunnel 分正反向 其實他們的差別只有在方向不一樣 連語法參數都一樣
正向 tunnel 正向的 tunnel 參數是 -L 語法：
ssh -L [bind_address:]port:host:hostport ssh -L [bind_address:]port:remote_socket ssh -L local_socket:host:hostport ssh -L local_socket:remote_socket 反向 tunnel ssh -R [bind_address:]port:host:hostport ssh -R [bind_address:]port:local_socket ssh -R remote_socket:host:hostport ssh -R remote_socket:local_socket ssh -R [bind_address:]port 心得 看起來好像很難 但是其實用下面這個就夠了 正向：
ssh -L &amp;lt;local port&amp;gt;:localhost:&amp;lt;remote port&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;remote&amp;gt; 反向;
ssh -R &amp;lt;remote port&amp;gt;:localhost:&amp;lt;local port&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;remote&amp;gt; 總而言之就是前面的和選項一樣 如果是 -L 那前面就是 local port 如果是 -R 那前面就是 remote port</description>
    </item>
    
    <item>
      <title>reverse-ssh</title>
      <link>https://blog.simba-fs.dev/posts/linux/reverse-ssh/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/reverse-ssh/</guid>
      <description>一直以來連線回社辦的電腦都要走 webtty 再開 tmate 但是今天發現了一個新的方法可以透過反向的 ssh 連回社辦
reverse ssh 在社辦電腦
$ ssh -NfR 2222:localhost:22 simba@simba-vps 這可以建立一個連線 這時候到 simba-vps
$ ssh server@localhost -p 2222 就可以連線回社辦伺服器了
autossh 但是這樣做 ssh 連線有可能會超時然後斷掉 這時候可以透過 autossh 來幫我們自動建立連線 在社辦電腦
$ apt install autossh $ autossh -Mf 2222 -NR 1111:localhost:22 simba@simba-vps -p 22 這樣就可以在 vps 上
$ ssh server@localhost -p 1111 來連回社辦啦！ 最後可以把這堆在 vps 上再做一次就可以在 internet 連回社辦伺服器了
參考網址 https://stackoverflow.com/questions/15983795/how-do-i-establish-a-bidirectional-ssh-tunnel
https://ez3c.tw/2043
https://www.ubuntu-tw.org/modules/newbb/viewtopic.php?viewmode=compact&amp;amp;topic_id=17538&amp;amp;forum=7
http://blog.adahsu.net/2007/11/ssh-reverse-tunnel.html
https://codertw.com/%E4%BC%BA%E6%9C%8D%E5%99%A8/377688/
這篇講 ssh tunnel 最清楚
https://yu-jack.github.io/2019/01/08/ssh-tunnel/</description>
    </item>
    
    <item>
      <title>unix-socket</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/unix-socket/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/unix-socket/</guid>
      <description>今天心血來潮在看 unix socket 突然想到 node 可不可以把 服務監聽在一個 socket file 這樣在設定的時候就不用記哪個服務是幾 port
node 部份 監聽在 unix socket 查完資料後發現其實只要把原本填 port 的地方改成 socket file 的路徑就好了 像這樣
const express = require(&amp;#39;express&amp;#39;); const app = express(); app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; { res.send(&amp;#39;Hello World\n&amp;#39;); }); app.listen(&amp;#39;/tmp/express.sock&amp;#39;); 刪除 socket file 因為每次的 listen 都會新增一個 socket file 相當於佔用一個 port 如果不刪除的話就相當於 port 被佔用了 會噴錯 所以每次程式結束的時候要把這個 socket file 刪掉 然後在 /tmp 下的檔案會在開機後自動刪掉 所以如果部屬後發什麼問題重開機就對了！ 修改完的 code 長這樣
const fs = require(&amp;#39;fs&amp;#39;); const express = require(&amp;#39;express&amp;#39;); const app = express(); app.</description>
    </item>
    
    <item>
      <title>blessed切換畫面</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/blessed/blessed%E5%88%87%E6%8F%9B%E7%95%AB%E9%9D%A2/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/blessed/blessed%E5%88%87%E6%8F%9B%E7%95%AB%E9%9D%A2/</guid>
      <description>今天完成了新版本的 treetify 看這 同時我設計好了右邊的 edit 但是我的問題是他要根據情況不同切換不同的頁面 來看看我的一些想法：
 從 screen.children[2] 把他會掉，可是會出錯不行 有一個元件 Carousel 好像可以但是他其實是用方向鍵控制所以也不行 終於我想了一個方法，接下來來介紹 這是測試程式碼  const blessed = require(&amp;#39;blessed&amp;#39;); const contrib = require(&amp;#39;blessed-contrib&amp;#39;); const screen = blessed.screen({ title: &amp;#39;JSON viewer&amp;#39;, debug: true }); const grid = new contrib.grid({ rows: 1, cols: 2, screen: screen }); const tree = grid.set(0, 0, 1, 1, blessed.box, { border: {type: &amp;#39;line&amp;#39;}, content: &amp;#39;Tree&amp;#39;, label: &amp;#39;Tree&amp;#39; }); const edit = grid.set(0, 1, 1, 1, blessed.</description>
    </item>
    
    <item>
      <title>blessed-contrib-tree</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/blessed/blessed-contrib-tree/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/blessed/blessed-contrib-tree/</guid>
      <description>Tree 想說先想一個專案來練練手 熟悉一下 blessed 突然看到 blessed-contrib 裡有個元件叫 tree 想說可以做成 JSON viewer 於是就開工了！
其中最重要的部份就是搞定樹狀結構 因為他有特定的格式和選項 下面是官方的範例
範例 { extended: true, children: { &amp;#39;Fruit&amp;#39;: { children: { &amp;#39;Banana&amp;#39;: {}, &amp;#39;Apple&amp;#39;: {}, &amp;#39;Cherry&amp;#39;: {}, &amp;#39;Exotics&amp;#39;: { children: { &amp;#39;Mango&amp;#39;: {}, &amp;#39;Papaya&amp;#39;: {}, &amp;#39;Kiwi&amp;#39;: { name: &amp;#39;Kiwi(notthebird!)&amp;#39;, myCustomProperty: &amp;#34;hairyfruit&amp;#34; } } }, &amp;#39;Pear&amp;#39;: {} } }, &amp;#39;Vegetables&amp;#39;: { children: { &amp;#39;Peas&amp;#39;: {}, &amp;#39;Lettuce&amp;#39;: {}, &amp;#39;Pepper&amp;#39;: {} } } } } 每個節點都是物件 他的子節點存在 children 裡 如果是空物件代表這是葉節點 extended 屬性是是否展開，預設 true name 是顯示出來的字，如果要改再設，預設是 index myCustomProperty 直翻是自訂屬性，應該是當 tree.</description>
    </item>
    
    <item>
      <title>blessed</title>
      <link>https://blog.simba-fs.dev/posts/nodejs/blessed/blessed/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/nodejs/blessed/blessed/</guid>
      <description>某天我有一個問題 gtop 的圖畫界面是怎麼做的，我知道他是用 node 寫的，對他別有興趣 我上 github 看他的 package.json 發現他的 depandence 只有三個
... &amp;#34;dependencies&amp;#34;: { &amp;#34;blessed&amp;#34;: &amp;#34;^0.1.81&amp;#34;, &amp;#34;blessed-contrib&amp;#34;: &amp;#34;^4.8.16&amp;#34;, &amp;#34;systeminformation&amp;#34;: &amp;#34;^4.14.4&amp;#34; }, ... 其中 systeminformation 很顯然是取得系統資訊 那 GUI 的 library 應該就是 blessed 和 blessed-contrib 了 去 blessed 的 github 看看 沒想到這是一個超強大的函式庫 可是網路上的教學卻很少 只好自己看 docs 啦
接下來是我測試的一些程式碼和截圖</description>
    </item>
    
    <item>
      <title>server-tool</title>
      <link>https://blog.simba-fs.dev/posts/linux/server/server-tool/</link>
      <pubDate>Sun, 16 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/server/server-tool/</guid>
      <description>用 bash 寫 log 分析工具 因為我們的 server 不知道是為什麼一直受到 DDoS 攻擊
我想知道是什麼時段容易受到攻擊和每次多久、來自那個 ip
於是我花了一點時間寫了幾個簡單的 script</description>
    </item>
    
    <item>
      <title>ddos</title>
      <link>https://blog.simba-fs.dev/posts/linux/server/ddos/</link>
      <pubDate>Thu, 13 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/server/ddos/</guid>
      <description>伺服器被 DDoS 惹 今天早上把社團的 reverse proxy server 換成 nginx
下午心血來潮看看 log 檔 因為沒有寫好的工具
首先把 log 檔 cp 到我的電腦再來處理</description>
    </item>
    
    <item>
      <title>nginx-reverse-proxy-setup</title>
      <link>https://blog.simba-fs.dev/posts/linux/server/nginx-reverse-proxy-setup/</link>
      <pubDate>Thu, 13 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/linux/server/nginx-reverse-proxy-setup/</guid>
      <description>nginx 反向代理伺服器 (reverse proxy) 之前社網 server 因為學校防火牆限制只能對外開 80 443 兩個 port
而且我們只有一個 ip (203.64.138.177)
所以要用 reverse proxy 來代理我們的多項服務
原本我只會用 apache2 後來不知道是不是因為 apache 太肥導致有時候回應時間會很久
所以我起了將 proxy server 換成 nginx 的想法</description>
    </item>
    
    <item>
      <title>hexo-config</title>
      <link>https://blog.simba-fs.dev/posts/hexo/hexo-config/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/hexo/hexo-config/</guid>
      <description>各種設定值嘗試 Highlight - # highlight: rainbow + highlight: rainbow var a = 7122; console.log(a); var a = 7122; console.log(a); int a = 7122; cout &amp;lt;&amp;lt; a; </description>
    </item>
    
    <item>
      <title>audo-depoly-by-github-action</title>
      <link>https://blog.simba-fs.dev/posts/hexo/audo-depoly-by-github-action/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/hexo/audo-depoly-by-github-action/</guid>
      <description>自動部屬部落格 參考網址：https://op30132.github.io/2020/02/05/github-action/ 生成公私鑰時不用在部落格根目錄，記的不要加入 git，要刪掉
name: HEXO CI on: push: branches: - master jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [12.x] steps: - uses: actions/checkout@v1 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node-version }} - name: Configuration environment env: HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}} run: |mkdir -p ~/.ssh/ echo &amp;#34;$HEXO_DEPLOY_PRI&amp;#34; | tr -d &amp;#39;\r&amp;#39; &amp;gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &amp;gt;&amp;gt; ~/.ssh/known_hosts git config --global user.name &amp;#34;simba-fs&amp;#34; git config --global user.</description>
    </item>
    
    <item>
      <title>gitalk</title>
      <link>https://blog.simba-fs.dev/posts/hexo/gitalk/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/hexo/gitalk/</guid>
      <description>啟用 gitalk 留言  到這個網址填資料 加入下面的片段到_config.yml  disqus: enabled: false gitalk: enabled: true owner: &amp;lt;username&amp;gt; repo: &amp;lt;username&amp;gt;.github.io admin: [&#39;&amp;lt;username&amp;gt;&#39;] clientID: &amp;lt;clientID&amp;gt; clientSecret: &amp;lt;clientSecret&amp;gt; 加入下面的片段到themes/cactus/layout/_partial/comments.ejs  &amp;lt;% if(page.comments &amp;amp;&amp;amp; theme.gitalk.enabled){ %&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&amp;quot;&amp;gt; &amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div id=&amp;quot;gitalk-container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var gitalk = new Gitalk({ clientID: &#39;&amp;lt;%= theme.gitalk.clientID %&amp;gt;&#39;, clientSecret: &#39;&amp;lt;%= theme.gitalk.clientSecret %&amp;gt;&#39;, id: md5(window.location.pathname), repo: &#39;&amp;lt;%= theme.gitalk.repo %&amp;gt;&#39;, owner: &#39;&amp;lt;%= theme.gitalk.owner %&amp;gt;&#39;, admin: &#39;&amp;lt;%= theme.gitalk.admin %&amp;gt;&#39;, distractionFreeMode: &#39;&amp;lt;%= theme.</description>
    </item>
    
    <item>
      <title>hexo-cli-extras</title>
      <link>https://blog.simba-fs.dev/posts/hexo/hexo-cli-extras/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/hexo/hexo-cli-extras/</guid>
      <description>好用的插件 因為 hexo 本身沒有提供編輯器
所以每次在編輯文章時都需要打路徑
這個插件他會去找到你的文章
然後給你選要編輯那一個
這只是其中一個功能
還有重新命名、刪除、隔離和加入
隔離是將其他文章暫時隔離，加入是將文章加回來</description>
    </item>
    
    <item>
      <title>hexo-installation</title>
      <link>https://blog.simba-fs.dev/posts/hexo/hexo-installation/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.simba-fs.dev/posts/hexo/hexo-installation/</guid>
      <description>把 hexo 部屬到 gh-page 執行
$ npm i hexo -g $ hexo init blog $ cd blog 修改 _config.yml 刪除最後兩行，改成
deploy: type: git repo: git@github.com:&amp;lt;username&amp;gt;/&amp;lt;repo&amp;gt; branch: master 執行
$ npm i hexo-deployer-git $ hexo depoly 在 repo 設定中 GitHub Pages 隨便選一個 Jekyll theme，這樣才不會 404
 地雷：在之後都部屬要加上 -g
 $ hexo d -g 不然不會生效
完成!
將原始碼保存 執行
$ git checkout -b hexo $ git add . $ git commit -m init $ git push -u origin hexo 完成</description>
    </item>
    
  </channel>
</rss>
